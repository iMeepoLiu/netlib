/*
 * Copyright 2020, 2021, Ludovic Henry
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Please contact git@ludovic.dev or visit ludovic.dev if you need additional
 * information or have any questions.
 */

#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

#include "dev_ludovic_netlib_lapack_JNILAPACK.h"

#define UNUSED __attribute__((unused))

#define TRUE 1
#define FALSE 0

static jfieldID booleanW_val_fieldID;
static jfieldID intW_val_fieldID;
static jfieldID floatW_val_fieldID;
static jfieldID doubleW_val_fieldID;
static jfieldID StringW_val_fieldID;

static void (*dbdsdc_)(const char *uplo, const char *compq, int *n, double *d, double *e, double *u, int *ldu, double *vt, int *ldvt, double *q, int *iq, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dbdsdc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dbdsdc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dbdsdcK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring compq, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray q, jint offsetq, jintArray iq, jint offsetiq, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dbdsdc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  double *__nq = NULL;
  int *__niq = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldu = ldu;
  __nldvt = ldvt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__niq = (*env)->GetPrimitiveArrayCritical(env, iq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dbdsdc_(__nuplo, __ncompq, &__nn, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nq + offsetq, __niq + offsetiq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niq) (*env)->ReleasePrimitiveArrayCritical(env, iq, __niq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dbdsqr_)(const char *uplo, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, double *vt, int *ldvt, double *u, int *ldu, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dbdsqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dbdsqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dbdsqrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint ncvt, jint nru, jint ncc, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dbdsqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nncvt __attribute__((aligned(8)));
  int __nnru __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nvt = NULL;
  double *__nu = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nncvt = ncvt;
  __nnru = nru;
  __nncc = ncc;
  __nldvt = ldvt;
  __nldu = ldu;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dbdsqr_(__nuplo, &__nn, &__nncvt, &__nnru, &__nncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &__nldvt, __nu + offsetu, &__nldu, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ddisna_)(const char *job, int *m, int *n, double *d, double *sep, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ddisna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ddisna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ddisnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jint m, jint n, jdoubleArray d, jint offsetd, jdoubleArray sep, jint offsetsep, jobject info) {
  if (!ddisna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nsep = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) { __failed = TRUE; goto done; }
  ddisna_(__njob, &__nm, &__nn, __nd + offsetd, __nsep + offsetsep, &__ninfo);
done:
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbbrd_)(const char *vect, int *m, int *n, int *ncc, int *kl, int *ku, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *pt, int *ldpt, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbbrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbbrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbbrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint ncc, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray pt, jint offsetpt, jint ldpt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgbbrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldpt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nq = NULL;
  double *__npt = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nncc = ncc;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nldq = ldq;
  __nldpt = ldpt;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__npt = (*env)->GetPrimitiveArrayCritical(env, pt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgbbrd_(__nvect, &__nm, &__nn, &__nncc, &__nkl, &__nku, __nab + offsetab, &__nldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __npt + offsetpt, &__nldpt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__npt) (*env)->ReleasePrimitiveArrayCritical(env, pt, __npt, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbcon_)(const char *norm, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgbcon_(__nnorm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbequ_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  if (!dgbequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nrowcnd = 0;
  double __ncolcnd = 0;
  double __namax = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nrowcnd = (*env)->GetDoubleField(env, rowcnd, doubleW_val_fieldID);
  __ncolcnd = (*env)->GetDoubleField(env, colcnd, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dgbequ_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!__failed) (*env)->SetDoubleField(env, colcnd, doubleW_val_fieldID, __ncolcnd);
  if (!__failed) (*env)->SetDoubleField(env, rowcnd, doubleW_val_fieldID, __nrowcnd);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbrfs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nafb = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgbrfs_(__ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbsv_)(int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgbsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgbsv_(&__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbsvx_)(const char *fact, const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jobject equed, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgbsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nafb = NULL;
  int *__nipiv = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgbsvx_(__nfact, __ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbtf2_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbtf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbtf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dgbtf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dgbtf2_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbtrf_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbtrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbtrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dgbtrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dgbtrf_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgbtrs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgbtrs_(__ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgebak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, double *scale, int *m, double *v, int *ldv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgebak(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgebak_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jdoubleArray scale, jint offsetscale, jint m, jdoubleArray v, jint offsetv, jint ldv, jobject info) {
  if (!dgebak_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nside = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nscale = NULL;
  double *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nm = m;
  __nldv = ldv;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  dgebak_(__njob, __nside, &__nn, &__nilo, &__nihi, __nscale + offsetscale, &__nm, __nv + offsetv, &__nldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgebal_)(const char *job, int *n, double *a, int *lda, int *ilo, int *ihi, double *scale, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgebal(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgebal_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jdoubleArray a, jint offseta, jint lda, jobject ilo, jobject ihi, jdoubleArray scale, jint offsetscale, jobject info) {
  if (!dgebal_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nscale = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  dgebal_(__njob, &__nn, __na + offseta, &__nlda, &__nilo, &__nihi, __nscale + offsetscale, &__ninfo);
done:
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgebd2_)(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgebd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgebd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebd2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgebd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntauq = NULL;
  double *__ntaup = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgebd2_(&__nm, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgebrd_)(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgebrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgebrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgebrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntauq = NULL;
  double *__ntaup = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgebrd_(&__nm, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgecon_)(const char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgecon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgecon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray a, jint offseta, jint lda, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgecon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgecon_(__nnorm, &__nn, __na + offseta, &__nlda, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeequ_)(int *m, int *n, double *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  if (!dgeequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nrowcnd = 0;
  double __ncolcnd = 0;
  double __namax = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nrowcnd = (*env)->GetDoubleField(env, rowcnd, doubleW_val_fieldID);
  __ncolcnd = (*env)->GetDoubleField(env, colcnd, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dgeequ_(&__nm, &__nn, __na + offseta, &__nlda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!__failed) (*env)->SetDoubleField(env, colcnd, doubleW_val_fieldID, __ncolcnd);
  if (!__failed) (*env)->SetDoubleField(env, rowcnd, doubleW_val_fieldID, __nrowcnd);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*dgees_)(const char *jobvs, const char *sort, const char *select, int *n, double *a, int *lda, int *sdim, double *wr, double *wi, double *vs, int *ldvs, double *work, int *lwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgees(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeesK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvs, UNUSED jstring sort, UNUSED jstring select, UNUSED jint n, UNUSED jdoubleArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jobject sdim, UNUSED jdoubleArray wr, UNUSED jint offsetwr, UNUSED jdoubleArray wi, UNUSED jint offsetwi, UNUSED jdoubleArray vs, UNUSED jint offsetvs, UNUSED jint ldvs, UNUSED jdoubleArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dgeesx_)(const char *jobvs, const char *sort, const char *select, const char *sense, int *n, double *a, int *lda, int *sdim, double *wr, double *wi, double *vs, int *ldvs, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeesx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeesxK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvs, UNUSED jstring sort, UNUSED jstring select, UNUSED jstring sense, UNUSED jint n, UNUSED jdoubleArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jobject sdim, UNUSED jdoubleArray wr, UNUSED jint offsetwr, UNUSED jdoubleArray wi, UNUSED jint offsetwi, UNUSED jdoubleArray vs, UNUSED jint offsetvs, UNUSED jint ldvs, UNUSED jobject rconde, UNUSED jobject rcondv, UNUSED jdoubleArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jintArray iwork, UNUSED jint offsetiwork, UNUSED jint liwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*dgeev_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgeev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeev_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jdoubleArray scale, jint offsetscale, jobject abnrm, jdoubleArray rconde, jint offsetrconde, jdoubleArray rcondv, jint offsetrcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgeevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nbalanc = NULL;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  const char *__nsense = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  double __nabnrm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nscale = NULL;
  double *__nrconde = NULL;
  double *__nrcondv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetDoubleField(env, abnrm, doubleW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgeevx_(__nbalanc, __njobvl, __njobvr, __nsense, &__nn, __na + offseta, &__nlda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nilo, &__nihi, __nscale + offsetscale, &__nabnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, __failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, __failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, abnrm, doubleW_val_fieldID, __nabnrm);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgegs_)(const char *jobvsl, const char *jobvsr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgegs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgegs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgegsK(JNIEnv *env, UNUSED jobject obj, jstring jobvsl, jstring jobvsr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vsl, jint offsetvsl, jint ldvsl, jdoubleArray vsr, jint offsetvsr, jint ldvsr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgegs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvsl = NULL;
  const char *__njobvsr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvsl __attribute__((aligned(8)));
  int __nldvsr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nvsl = NULL;
  double *__nvsr = NULL;
  double *__nwork = NULL;
  if (!(__njobvsl = (*env)->GetStringUTFChars(env, jobvsl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvsr = (*env)->GetStringUTFChars(env, jobvsr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvsl = ldvsl;
  __nldvsr = ldvsr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvsl = (*env)->GetPrimitiveArrayCritical(env, vsl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvsr = (*env)->GetPrimitiveArrayCritical(env, vsr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgegs_(__njobvsl, __njobvsr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvsl + offsetvsl, &__nldvsl, __nvsr + offsetvsr, &__nldvsr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvsr) (*env)->ReleasePrimitiveArrayCritical(env, vsr, __nvsr, __failed ? JNI_ABORT : 0);
  if (__nvsl) (*env)->ReleasePrimitiveArrayCritical(env, vsl, __nvsl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvsr) (*env)->ReleaseStringUTFChars(env, jobvsr, __njobvsr);
  if (__njobvsl) (*env)->ReleaseStringUTFChars(env, jobvsl, __njobvsl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgegv_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgegv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgegv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgegvK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgegv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgegv_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgehd2_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgehd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgehd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgehd2K(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgehd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgehd2_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgehrd_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgehrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgehrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgehrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgehrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgehrd_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelq2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgelq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgelq2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelqf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgelqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgelqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgels_)(const char *trans, int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgels(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgels_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgels_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgels_(__ntrans, &__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelsd_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelsd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelsd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray s, jint offsets, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgelsd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__ns = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgelsd_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __ns + offsets, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelss_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelss(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelss_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelssK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray s, jint offsets, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgelss_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__ns = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgelss_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __ns + offsets, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelsx_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *jpvt, double *rcond, int *rank, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelsx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelsx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsxK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgelsx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  int *__njpvt = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgelsx_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __njpvt + offsetjpvt, &__nrcond, &__nrank, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgelsy_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *jpvt, double *rcond, int *rank, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgelsy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgelsy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsyK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgelsy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  int *__njpvt = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgelsy_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __njpvt + offsetjpvt, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeql2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeql2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeql2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeql2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgeql2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeql2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeqlf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeqlf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeqlf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqlfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgeqlf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeqlf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeqp3_)(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeqp3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeqp3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqp3K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgeqp3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__njpvt = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeqp3_(&__nm, &__nn, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeqpf_)(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeqpf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeqpf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqpfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgeqpf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__njpvt = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeqpf_(&__nm, &__nn, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeqr2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeqr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeqr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgeqr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeqr2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgeqrf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgeqrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgeqrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgeqrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgeqrf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgerfs_)(const char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgerfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgerfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgerfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgerfs_(__ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgerq2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgerq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgerq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dgerq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgerq2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgerqf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgerqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgerqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgerqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgerqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgesc2_)(int *n, double *a, int *lda, double *rhs, int *ipiv, int *jpiv, double *scale);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgesc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgesc2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesc2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray rhs, jint offsetrhs, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject scale) {
  if (!dgesc2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nscale = 0;
  double *__na = NULL;
  double *__nrhs = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nn = n;
  __nlda = lda;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  dgesc2_(&__nn, __na + offseta, &__nlda, __nrhs + offsetrhs, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__nscale);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgesdd_)(const char *jobz, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgesdd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgesdd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesddK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgesdd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ns = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldu = ldu;
  __nldvt = ldvt;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgesdd_(__njobz, &__nm, &__nn, __na + offseta, &__nlda, __ns + offsets, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgesv_)(int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgesv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgesv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgesv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgesv_(&__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgesvd_)(const char *jobu, const char *jobvt, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgesvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgesvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobvt, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgesvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobvt = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ns = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvt = (*env)->GetStringUTFChars(env, jobvt, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldu = ldu;
  __nldvt = ldvt;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgesvd_(__njobu, __njobvt, &__nm, &__nn, __na + offseta, &__nlda, __ns + offsets, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvt) (*env)->ReleaseStringUTFChars(env, jobvt, __njobvt);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgesvx_)(const char *fact, const char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgesvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgesvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jobject equed, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgesvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  int *__nipiv = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgesvx_(__nfact, __ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgetc2_)(int *n, double *a, int *lda, int *ipiv, int *jpiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgetc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgetc2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetc2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject info) {
  if (!dgetc2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  dgetc2_(&__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__ninfo);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgetf2_)(int *m, int *n, double *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgetf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgetf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dgetf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dgetf2_(&__nm, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgetrf_)(int *m, int *n, double *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgetrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgetrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dgetrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dgetrf_(&__nm, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgetri_)(int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgetri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgetri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetriK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgetri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgetri_(&__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgetrs_)(const char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgetrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgetrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgetrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgetrs_(__ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggbak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, double *lscale, double *rscale, int *m, double *v, int *ldv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggbak(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggbak_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggbakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jint m, jdoubleArray v, jint offsetv, jint ldv, jobject info) {
  if (!dggbak_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nside = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nlscale = NULL;
  double *__nrscale = NULL;
  double *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nm = m;
  __nldv = ldv;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  dggbak_(__njob, __nside, &__nn, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nm, __nv + offsetv, &__nldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggbal_)(const char *job, int *n, double *a, int *lda, double *b, int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggbal(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggbal_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggbalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject ilo, jobject ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dggbal_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nlscale = NULL;
  double *__nrscale = NULL;
  double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggbal_(__njob, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*dgges_)(const char *jobvsl, const char *jobvsr, const char *sort, const char *selctg, int *n, double *a, int *lda, double *b, int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *work, int *lwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgges(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggesK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvsl, UNUSED jstring jobvsr, UNUSED jstring sort, UNUSED jstring selctg, UNUSED jint n, UNUSED jdoubleArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jdoubleArray b, UNUSED jint offsetb, UNUSED jint ldb, UNUSED jobject sdim, UNUSED jdoubleArray alphar, UNUSED jint offsetalphar, UNUSED jdoubleArray alphai, UNUSED jint offsetalphai, UNUSED jdoubleArray beta, UNUSED jint offsetbeta, UNUSED jdoubleArray vsl, UNUSED jint offsetvsl, UNUSED jint ldvsl, UNUSED jdoubleArray vsr, UNUSED jint offsetvsr, UNUSED jint ldvsr, UNUSED jdoubleArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dggesx_)(const char *jobvsl, const char *jobvsr, const char *sort, const char *selctg, const char *sense, int *n, double *a, int *lda, double *b, int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggesx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggesxK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvsl, UNUSED jstring jobvsr, UNUSED jstring sort, UNUSED jstring selctg, UNUSED jstring sense, UNUSED jint n, UNUSED jdoubleArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jdoubleArray b, UNUSED jint offsetb, UNUSED jint ldb, UNUSED jobject sdim, UNUSED jdoubleArray alphar, UNUSED jint offsetalphar, UNUSED jdoubleArray alphai, UNUSED jint offsetalphai, UNUSED jdoubleArray beta, UNUSED jint offsetbeta, UNUSED jdoubleArray vsl, UNUSED jint offsetvsl, UNUSED jint ldvsl, UNUSED jdoubleArray vsr, UNUSED jint offsetvsr, UNUSED jint ldvsr, UNUSED jdoubleArray rconde, UNUSED jint offsetrconde, UNUSED jdoubleArray rcondv, UNUSED jint offsetrcondv, UNUSED jdoubleArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jintArray iwork, UNUSED jint offsetiwork, UNUSED jint liwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*dggev_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dggev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggev_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jobject abnrm, jobject bbnrm, jdoubleArray rconde, jint offsetrconde, jdoubleArray rcondv, jint offsetrcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  if (!dggevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nbalanc = NULL;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  const char *__nsense = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  double __nabnrm = 0;
  double __nbbnrm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nlscale = NULL;
  double *__nrscale = NULL;
  double *__nrconde = NULL;
  double *__nrcondv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nbwork = NULL; jboolean *__jbwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetDoubleField(env, abnrm, doubleW_val_fieldID);
  __nbbnrm = (*env)->GetDoubleField(env, bbnrm, doubleW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__jbwork = (*env)->GetPrimitiveArrayCritical(env, bwork, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, bwork);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nbwork = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nbwork[i] = __jbwork[i]; }
  } while(0);
  dggevx_(__nbalanc, __njobvl, __njobvr, __nsense, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nabnrm, &__nbbnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nbwork + offsetbwork, &__ninfo);
done:
  if (__nbwork) { free(__nbwork); } if (__jbwork) (*env)->ReleasePrimitiveArrayCritical(env, bwork, __nbwork, JNI_ABORT);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, __failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, bbnrm, doubleW_val_fieldID, __nbbnrm);
  if (!__failed) (*env)->SetDoubleField(env, abnrm, doubleW_val_fieldID, __nabnrm);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggglm_)(int *n, int *m, int *p, double *a, int *lda, double *b, int *ldb, double *d, double *x, double *y, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggglm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggglm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggglmK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray d, jint offsetd, jdoubleArray x, jint offsetx, jdoubleArray y, jint offsety, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dggglm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nd = NULL;
  double *__nx = NULL;
  double *__ny = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nm = m;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggglm_(&__nn, &__nm, &__np, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nd + offsetd, __nx + offsetx, __ny + offsety, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgghrd_)(const char *compq, const char *compz, int *n, int *ilo, int *ihi, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgghrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgghrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgghrdK(JNIEnv *env, UNUSED jobject obj, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject info) {
  if (!dgghrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompq = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nq = NULL;
  double *__nz = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dgghrd_(__ncompq, __ncompz, &__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgglse_)(int *m, int *n, int *p, double *a, int *lda, double *b, int *ldb, double *c, double *d, double *x, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgglse(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgglse_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgglseK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jdoubleArray d, jint offsetd, jdoubleArray x, jint offsetx, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dgglse_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  double *__nd = NULL;
  double *__nx = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dgglse_(&__nm, &__nn, &__np, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, __nd + offsetd, __nx + offsetx, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggqrf_)(int *n, int *m, int *p, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggqrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggqrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggqrfK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray taua, jint offsettaua, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray taub, jint offsettaub, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dggqrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntaua = NULL;
  double *__nb = NULL;
  double *__ntaub = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nm = m;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggqrf_(&__nn, &__nm, &__np, __na + offseta, &__nlda, __ntaua + offsettaua, __nb + offsetb, &__nldb, __ntaub + offsettaub, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggrqf_)(int *m, int *p, int *n, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggrqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggrqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint p, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray taua, jint offsettaua, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray taub, jint offsettaub, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dggrqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntaua = NULL;
  double *__nb = NULL;
  double *__ntaub = NULL;
  double *__nwork = NULL;
  __nm = m;
  __np = p;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggrqf_(&__nm, &__np, &__nn, __na + offseta, &__nlda, __ntaua + offsettaua, __nb + offsetb, &__nldb, __ntaub + offsettaub, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggsvd_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *n, int *p, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggsvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggsvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggsvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint n, jint p, jobject k, jobject l, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alpha, jint offsetalpha, jdoubleArray beta, jint offsetbeta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dggsvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nk = 0;
  int __nl = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalpha = NULL;
  double *__nbeta = NULL;
  double *__nu = NULL;
  double *__nv = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __np = p;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __nlda = lda;
  __nldb = ldb;
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dggsvd_(__njobu, __njobv, __njobq, &__nm, &__nn, &__np, &__nk, &__nl, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dggsvp_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, int *k, int *l, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, int *iwork, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dggsvp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dggsvp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggsvpK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble tola, jdouble tolb, jobject k, jobject l, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jintArray iwork, jint offsetiwork, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dggsvp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __ntola __attribute__((aligned(8)));
  double __ntolb __attribute__((aligned(8)));
  int __nk = 0;
  int __nl = 0;
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nu = NULL;
  double *__nv = NULL;
  double *__nq = NULL;
  int *__niwork = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __np = p;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ntola = tola;
  __ntolb = tolb;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dggsvp_(__njobu, __njobv, __njobq, &__nm, &__np, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ntola, &__ntolb, &__nk, &__nl, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __niwork + offsetiwork, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgtcon_)(const char *norm, int *n, double *dl, double *d, double *du, double *du2, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgtcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgtcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgtcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgtcon_(__nnorm, &__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgtrfs_)(const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgtrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgtrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray dlf, jint offsetdlf, jdoubleArray df, jint offsetdf, jdoubleArray duf, jint offsetduf, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgtrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndlf = NULL;
  double *__ndf = NULL;
  double *__nduf = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgtrfs_(__ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgtsv_)(int *n, int *nrhs, double *dl, double *d, double *du, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgtsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgtsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgtsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgtsv_(&__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgtsvx_)(const char *fact, const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgtsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgtsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray dlf, jint offsetdlf, jdoubleArray df, jint offsetdf, jdoubleArray duf, jint offsetduf, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dgtsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndlf = NULL;
  double *__ndf = NULL;
  double *__nduf = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dgtsvx_(__nfact, __ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgttrf_)(int *n, double *dl, double *d, double *du, double *du2, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgttrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgttrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dgttrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dgttrf_(&__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgttrs_)(const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgttrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgttrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgttrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dgttrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgttrs_(__ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dgtts2_)(int *itrans, int *n, int *nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dgtts2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dgtts2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtts2K(JNIEnv *env, UNUSED jobject obj, jint itrans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb) {
  if (!dgtts2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitrans __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__ndu2 = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  __nitrans = itrans;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dgtts2_(&__nitrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dhgeqz_)(const char *job, const char *compq, const char *compz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *t, int *ldt, double *alphar, double *alphai, double *beta, double *q, int *ldq, double *z, int *ldz, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dhgeqz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dhgeqz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhgeqzK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray t, jint offsett, jint ldt, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dhgeqz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompq = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nt = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nq = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __nldt = ldt;
  __nldq = ldq;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dhgeqz_(__njob, __ncompq, __ncompz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nt + offsett, &__nldt, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dhsein_)(const char *side, const char *eigsrc, const char *initv, int *select, int *n, double *h, int *ldh, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *ifaill, int *ifailr, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dhsein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dhsein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhseinK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring eigsrc, jstring initv, jbooleanArray select, jint offsetselect, jint n, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jintArray ifaill, jint offsetifaill, jintArray ifailr, jint offsetifailr, jobject info) {
  if (!dhsein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__neigsrc = NULL;
  const char *__ninitv = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__nh = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  int *__nifaill = NULL;
  int *__nifailr = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__neigsrc = (*env)->GetStringUTFChars(env, eigsrc, NULL))) { __failed = TRUE; goto done; }
  if (!(__ninitv = (*env)->GetStringUTFChars(env, initv, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldh = ldh;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifaill = (*env)->GetPrimitiveArrayCritical(env, ifaill, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifailr = (*env)->GetPrimitiveArrayCritical(env, ifailr, NULL))) { __failed = TRUE; goto done; }
  dhsein_(__nside, __neigsrc, __ninitv, __nselect + offsetselect, &__nn, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, __nifaill + offsetifaill, __nifailr + offsetifailr, &__ninfo);
done:
  if (__nifailr) (*env)->ReleasePrimitiveArrayCritical(env, ifailr, __nifailr, __failed ? JNI_ABORT : 0);
  if (__nifaill) (*env)->ReleasePrimitiveArrayCritical(env, ifaill, __nifaill, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ninitv) (*env)->ReleaseStringUTFChars(env, initv, __ninitv);
  if (__neigsrc) (*env)->ReleaseStringUTFChars(env, eigsrc, __neigsrc);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dhseqr_)(const char *job, const char *compz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, double *z, int *ldz, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dhseqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dhseqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhseqrK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dhseqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dhseqr_(__njob, __ncompz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*disnan_)(double *din);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_disnan(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return disnan_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_disnanK(JNIEnv *env, UNUSED jobject obj, jdouble din) {
  if (!disnan_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  double __ndin __attribute__((aligned(8)));
  __ndin = din;
  __ret = disnan_(&__ndin);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*dlabad_)(double *small, double *large);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlabad(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlabad_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlabadK(JNIEnv *env, UNUSED jobject obj, jobject small, jobject large) {
  if (!dlabad_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __nsmall = 0;
  double __nlarge = 0;
  __nsmall = (*env)->GetDoubleField(env, small, doubleW_val_fieldID);
  __nlarge = (*env)->GetDoubleField(env, large, doubleW_val_fieldID);
  dlabad_(&__nsmall, &__nlarge);
done:
  if (!__failed) (*env)->SetDoubleField(env, large, doubleW_val_fieldID, __nlarge);
  if (!__failed) (*env)->SetDoubleField(env, small, doubleW_val_fieldID, __nsmall);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlabrd_)(int *m, int *n, int *nb, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *x, int *ldx, double *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlabrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlabrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlabrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray y, jint offsety, jint ldy) {
  if (!dlabrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntauq = NULL;
  double *__ntaup = NULL;
  double *__nx = NULL;
  double *__ny = NULL;
  __nm = m;
  __nn = n;
  __nnb = nb;
  __nlda = lda;
  __nldx = ldx;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  dlabrd_(&__nm, &__nn, &__nnb, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nx + offsetx, &__nldx, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlacn2_)(int *n, double *v, double *x, int *isgn, double *est, int *kase, int *isave);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlacn2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlacn2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlacn2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray v, jint offsetv, jdoubleArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase, jintArray isave, jint offsetisave) {
  if (!dlacn2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nest = 0;
  int __nkase = 0;
  double *__nv = NULL;
  double *__nx = NULL;
  int *__nisgn = NULL;
  int *__nisave = NULL;
  __nn = n;
  __nest = (*env)->GetDoubleField(env, est, doubleW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisave = (*env)->GetPrimitiveArrayCritical(env, isave, NULL))) { __failed = TRUE; goto done; }
  dlacn2_(&__nn, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase, __nisave + offsetisave);
done:
  if (__nisave) (*env)->ReleasePrimitiveArrayCritical(env, isave, __nisave, __failed ? JNI_ABORT : 0);
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!__failed) (*env)->SetDoubleField(env, est, doubleW_val_fieldID, __nest);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlacon_)(int *n, double *v, double *x, int *isgn, double *est, int *kase);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlacon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlacon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaconK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray v, jint offsetv, jdoubleArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase) {
  if (!dlacon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nest = 0;
  int __nkase = 0;
  double *__nv = NULL;
  double *__nx = NULL;
  int *__nisgn = NULL;
  __nn = n;
  __nest = (*env)->GetDoubleField(env, est, doubleW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) { __failed = TRUE; goto done; }
  dlacon_(&__nn, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase);
done:
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!__failed) (*env)->SetDoubleField(env, est, doubleW_val_fieldID, __nest);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlacpy_)(const char *uplo, int *m, int *n, double *a, int *lda, double *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlacpy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlacpy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlacpyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb) {
  if (!dlacpy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dlacpy_(__nuplo, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dladiv_)(double *a, double *b, double *c, double *d, double *p, double *q);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dladiv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dladiv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dladivK(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jdouble d, jobject p, jobject q) {
  if (!dladiv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __na __attribute__((aligned(8)));
  double __nb __attribute__((aligned(8)));
  double __nc __attribute__((aligned(8)));
  double __nd __attribute__((aligned(8)));
  double __np = 0;
  double __nq = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nd = d;
  __np = (*env)->GetDoubleField(env, p, doubleW_val_fieldID);
  __nq = (*env)->GetDoubleField(env, q, doubleW_val_fieldID);
  dladiv_(&__na, &__nb, &__nc, &__nd, &__np, &__nq);
done:
  if (!__failed) (*env)->SetDoubleField(env, q, doubleW_val_fieldID, __nq);
  if (!__failed) (*env)->SetDoubleField(env, p, doubleW_val_fieldID, __np);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlae2_)(double *a, double *b, double *c, double *rt1, double *rt2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlae2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlae2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlae2K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jobject rt1, jobject rt2) {
  if (!dlae2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __na __attribute__((aligned(8)));
  double __nb __attribute__((aligned(8)));
  double __nc __attribute__((aligned(8)));
  double __nrt1 = 0;
  double __nrt2 = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nrt1 = (*env)->GetDoubleField(env, rt1, doubleW_val_fieldID);
  __nrt2 = (*env)->GetDoubleField(env, rt2, doubleW_val_fieldID);
  dlae2_(&__na, &__nb, &__nc, &__nrt1, &__nrt2);
done:
  if (!__failed) (*env)->SetDoubleField(env, rt2, doubleW_val_fieldID, __nrt2);
  if (!__failed) (*env)->SetDoubleField(env, rt1, doubleW_val_fieldID, __nrt1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaebz_)(int *ijob, int *nitmax, int *n, int *mmax, int *minp, int *nbmin, double *abstol, double *reltol, double *pivmin, double *d, double *e, double *e2, int *nval, double *ab, double *c, int *mout, int *nab, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaebz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaebz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaebzK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint nitmax, jint n, jint mmax, jint minp, jint nbmin, jdouble abstol, jdouble reltol, jdouble pivmin, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jintArray nval, jint offsetnval, jdoubleArray ab, jint offsetab, jdoubleArray c, jint offsetc, jobject mout, jintArray nab, jint offsetnab, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlaebz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nnitmax __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nmmax __attribute__((aligned(8)));
  int __nminp __attribute__((aligned(8)));
  int __nnbmin __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  double __nreltol __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  int __nmout = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ne2 = NULL;
  int *__nnval = NULL;
  double *__nab = NULL;
  double *__nc = NULL;
  int *__nnab = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nijob = ijob;
  __nnitmax = nitmax;
  __nn = n;
  __nmmax = mmax;
  __nminp = minp;
  __nnbmin = nbmin;
  __nabstol = abstol;
  __nreltol = reltol;
  __npivmin = pivmin;
  __nmout = (*env)->GetIntField(env, mout, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnval = (*env)->GetPrimitiveArrayCritical(env, nval, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnab = (*env)->GetPrimitiveArrayCritical(env, nab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlaebz_(&__nijob, &__nnitmax, &__nn, &__nmmax, &__nminp, &__nnbmin, &__nabstol, &__nreltol, &__npivmin, __nd + offsetd, __ne + offsete, __ne2 + offsete2, __nnval + offsetnval, __nab + offsetab, __nc + offsetc, &__nmout, __nnab + offsetnab, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nnab) (*env)->ReleasePrimitiveArrayCritical(env, nab, __nnab, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nnval) (*env)->ReleasePrimitiveArrayCritical(env, nval, __nnval, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, mout, intW_val_fieldID, __nmout);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed0_)(int *icompq, int *qsiz, int *n, double *d, double *e, double *q, int *ldq, double *qstore, int *ldqs, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint qsiz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray qstore, jint offsetqstore, jint ldqs, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlaed0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldqs __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nq = NULL;
  double *__nqstore = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nqsiz = qsiz;
  __nn = n;
  __nldq = ldq;
  __nldqs = ldqs;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlaed0_(&__nicompq, &__nqsiz, &__nn, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __nqstore + offsetqstore, &__nldqs, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed1_)(int *n, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlaed1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  int *__nindxq = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nldq = ldq;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ncutpnt = cutpnt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlaed1_(&__nn, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed2_)(int *k, int *n, int *n1, double *d, double *q, int *ldq, int *indxq, double *rho, double *z, double *dlamda, double *w, double *q2, int *indx, int *indxc, int *indxp, int *coltyp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed2K(JNIEnv *env, UNUSED jobject obj, jobject k, jint n, jint n1, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jdoubleArray z, jint offsetz, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray w, jint offsetw, jdoubleArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray indxc, jint offsetindxc, jintArray indxp, jint offsetindxp, jintArray coltyp, jint offsetcoltyp, jobject info) {
  if (!dlaed2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk = 0;
  int __nn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  int *__nindxq = NULL;
  double *__nz = NULL;
  double *__ndlamda = NULL;
  double *__nw = NULL;
  double *__nq2 = NULL;
  int *__nindx = NULL;
  int *__nindxc = NULL;
  int *__nindxp = NULL;
  int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nn = n;
  __nn1 = n1;
  __nldq = ldq;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxc = (*env)->GetPrimitiveArrayCritical(env, indxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) { __failed = TRUE; goto done; }
  dlaed2_(&__nk, &__nn, &__nn1, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, __nz + offsetz, __ndlamda + offsetdlamda, __nw + offsetw, __nq2 + offsetq2, __nindx + offsetindx, __nindxc + offsetindxc, __nindxp + offsetindxp, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, __failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, __failed ? JNI_ABORT : 0);
  if (__nindxc) (*env)->ReleasePrimitiveArrayCritical(env, indxc, __nindxc, __failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed3_)(int *k, int *n, int *n1, double *d, double *q, int *ldq, double *rho, double *dlamda, double *q2, int *indx, int *ctot, double *w, double *s, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed3K(JNIEnv *env, UNUSED jobject obj, jint k, jint n, jint n1, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdouble rho, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray ctot, jint offsetctot, jdoubleArray w, jint offsetw, jdoubleArray s, jint offsets, jobject info) {
  if (!dlaed3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  double *__ndlamda = NULL;
  double *__nq2 = NULL;
  int *__nindx = NULL;
  int *__nctot = NULL;
  double *__nw = NULL;
  double *__ns = NULL;
  __nk = k;
  __nn = n;
  __nn1 = n1;
  __nldq = ldq;
  __nrho = rho;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlaed3_(&__nk, &__nn, &__nn1, __nd + offsetd, __nq + offsetq, &__nldq, &__nrho, __ndlamda + offsetdlamda, __nq2 + offsetq2, __nindx + offsetindx, __nctot + offsetctot, __nw + offsetw, __ns + offsets, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, __failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed4_)(int *n, int *i, double *d, double *z, double *delta, double *rho, double *dlam, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dlam, jobject info) {
  if (!dlaed4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ni __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  double __ndlam = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__ndelta = NULL;
  __nn = n;
  __ni = i;
  __nrho = rho;
  __ndlam = (*env)->GetDoubleField(env, dlam, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  dlaed4_(&__nn, &__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndlam, &__ninfo);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, dlam, doubleW_val_fieldID, __ndlam);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed5_)(int *i, double *d, double *z, double *delta, double *rho, double *dlam);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed5K(JNIEnv *env, UNUSED jobject obj, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dlam) {
  if (!dlaed5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  double __ndlam = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__ndelta = NULL;
  __ni = i;
  __nrho = rho;
  __ndlam = (*env)->GetDoubleField(env, dlam, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  dlaed5_(&__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndlam);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, dlam, doubleW_val_fieldID, __ndlam);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed6_)(int *kniter, int *orgati, double *rho, double *d, double *z, double *finit, double *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed6K(JNIEnv *env, UNUSED jobject obj, jint kniter, jboolean orgati, jdouble rho, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdouble finit, jobject tau, jobject info) {
  if (!dlaed6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nkniter __attribute__((aligned(8)));
  int __norgati __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  double __nfinit __attribute__((aligned(8)));
  double __ntau = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  __nkniter = kniter;
  __norgati = orgati;
  __nrho = rho;
  __nfinit = finit;
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlaed6_(&__nkniter, &__norgati, &__nrho, __nd + offsetd, __nz + offsetz, &__nfinit, &__ntau, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed7_)(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed7(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed7_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint n, jint qsiz, jint tlvls, jint curlvl, jint curpbm, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray qstore, jint offsetqstore, jintArray qptr, jint offsetqptr, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlaed7_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __ntlvls __attribute__((aligned(8)));
  int __ncurlvl __attribute__((aligned(8)));
  int __ncurpbm __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  int *__nindxq = NULL;
  double *__nqstore = NULL;
  int *__nqptr = NULL;
  int *__nprmptr = NULL;
  int *__nperm = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nn = n;
  __nqsiz = qsiz;
  __ntlvls = tlvls;
  __ncurlvl = curlvl;
  __ncurpbm = curpbm;
  __nldq = ldq;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ncutpnt = cutpnt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlaed7_(&__nicompq, &__nn, &__nqsiz, &__ntlvls, &__ncurlvl, &__ncurpbm, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nqstore + offsetqstore, __nqptr + offsetqptr, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, __failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, __failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed8_)(int *icompq, int *k, int *n, int *qsiz, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *z, double *dlamda, double *q2, int *ldq2, double *w, int *perm, int *givptr, int *givcol, double *givnum, int *indxp, int *indx, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed8(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed8_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jobject k, jint n, jint qsiz, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray z, jint offsetz, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray q2, jint offsetq2, jint ldq2, jdoubleArray w, jint offsetw, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jintArray indxp, jint offsetindxp, jintArray indx, jint offsetindx, jobject info) {
  if (!dlaed8_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nk = 0;
  int __nn __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __nldq2 __attribute__((aligned(8)));
  int __ngivptr = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  int *__nindxq = NULL;
  double *__nz = NULL;
  double *__ndlamda = NULL;
  double *__nq2 = NULL;
  double *__nw = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  int *__nindxp = NULL;
  int *__nindx = NULL;
  __nicompq = icompq;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nn = n;
  __nqsiz = qsiz;
  __nldq = ldq;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ncutpnt = cutpnt;
  __nldq2 = ldq2;
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  dlaed8_(&__nicompq, &__nk, &__nn, &__nqsiz, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nz + offsetz, __ndlamda + offsetdlamda, __nq2 + offsetq2, &__nldq2, __nw + offsetw, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nindxp + offsetindxp, __nindx + offsetindx, &__ninfo);
done:
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaed9_)(int *k, int *kstart, int *kstop, int *n, double *d, double *q, int *ldq, double *rho, double *dlamda, double *w, double *s, int *lds, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaed9(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaed9_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed9K(JNIEnv *env, UNUSED jobject obj, jint k, jint kstart, jint kstop, jint n, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdouble rho, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray w, jint offsetw, jdoubleArray s, jint offsets, jint lds, jobject info) {
  if (!dlaed9_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk __attribute__((aligned(8)));
  int __nkstart __attribute__((aligned(8)));
  int __nkstop __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  int __nlds __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  double *__ndlamda = NULL;
  double *__nw = NULL;
  double *__ns = NULL;
  __nk = k;
  __nkstart = kstart;
  __nkstop = kstop;
  __nn = n;
  __nldq = ldq;
  __nrho = rho;
  __nlds = lds;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlaed9_(&__nk, &__nkstart, &__nkstop, &__nn, __nd + offsetd, __nq + offsetq, &__nldq, &__nrho, __ndlamda + offsetdlamda, __nw + offsetw, __ns + offsets, &__nlds, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaeda_)(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *q, int *qptr, double *z, double *ztemp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaeda(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaeda_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaedaK(JNIEnv *env, UNUSED jobject obj, jint n, jint tlvls, jint curlvl, jint curpbm, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jdoubleArray q, jint offsetq, jintArray qptr, jint offsetqptr, jdoubleArray z, jint offsetz, jdoubleArray ztemp, jint offsetztemp, jobject info) {
  if (!dlaeda_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ntlvls __attribute__((aligned(8)));
  int __ncurlvl __attribute__((aligned(8)));
  int __ncurpbm __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nprmptr = NULL;
  int *__nperm = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  double *__nq = NULL;
  int *__nqptr = NULL;
  double *__nz = NULL;
  double *__nztemp = NULL;
  __nn = n;
  __ntlvls = tlvls;
  __ncurlvl = curlvl;
  __ncurpbm = curpbm;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nztemp = (*env)->GetPrimitiveArrayCritical(env, ztemp, NULL))) { __failed = TRUE; goto done; }
  dlaeda_(&__nn, &__ntlvls, &__ncurlvl, &__ncurpbm, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nq + offsetq, __nqptr + offsetqptr, __nz + offsetz, __nztemp + offsetztemp, &__ninfo);
done:
  if (__nztemp) (*env)->ReleasePrimitiveArrayCritical(env, ztemp, __nztemp, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaein_)(int *rightv, int *noinit, int *n, double *h, int *ldh, double *wr, double *wi, double *vr, double *vi, double *b, int *ldb, double *work, double *eps3, double *smlnum, double *bignum, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaeinK(JNIEnv *env, UNUSED jobject obj, jboolean rightv, jboolean noinit, jint n, jdoubleArray h, jint offseth, jint ldh, jdouble wr, jdouble wi, jdoubleArray vr, jint offsetvr, jdoubleArray vi, jint offsetvi, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jdouble eps3, jdouble smlnum, jdouble bignum, jobject info) {
  if (!dlaein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nrightv __attribute__((aligned(8)));
  int __nnoinit __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  double __nwr __attribute__((aligned(8)));
  double __nwi __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __neps3 __attribute__((aligned(8)));
  double __nsmlnum __attribute__((aligned(8)));
  double __nbignum __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nvr = NULL;
  double *__nvi = NULL;
  double *__nb = NULL;
  double *__nwork = NULL;
  __nrightv = rightv;
  __nnoinit = noinit;
  __nn = n;
  __nldh = ldh;
  __nwr = wr;
  __nwi = wi;
  __nldb = ldb;
  __neps3 = eps3;
  __nsmlnum = smlnum;
  __nbignum = bignum;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvi = (*env)->GetPrimitiveArrayCritical(env, vi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaein_(&__nrightv, &__nnoinit, &__nn, __nh + offseth, &__nldh, &__nwr, &__nwi, __nvr + offsetvr, __nvi + offsetvi, __nb + offsetb, &__nldb, __nwork + offsetwork, &__neps3, &__nsmlnum, &__nbignum, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nvi) (*env)->ReleasePrimitiveArrayCritical(env, vi, __nvi, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaev2_)(double *a, double *b, double *c, double *rt1, double *rt2, double *cs1, double *sn1);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaev2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaev2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaev2K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jobject rt1, jobject rt2, jobject cs1, jobject sn1) {
  if (!dlaev2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __na __attribute__((aligned(8)));
  double __nb __attribute__((aligned(8)));
  double __nc __attribute__((aligned(8)));
  double __nrt1 = 0;
  double __nrt2 = 0;
  double __ncs1 = 0;
  double __nsn1 = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nrt1 = (*env)->GetDoubleField(env, rt1, doubleW_val_fieldID);
  __nrt2 = (*env)->GetDoubleField(env, rt2, doubleW_val_fieldID);
  __ncs1 = (*env)->GetDoubleField(env, cs1, doubleW_val_fieldID);
  __nsn1 = (*env)->GetDoubleField(env, sn1, doubleW_val_fieldID);
  dlaev2_(&__na, &__nb, &__nc, &__nrt1, &__nrt2, &__ncs1, &__nsn1);
done:
  if (!__failed) (*env)->SetDoubleField(env, sn1, doubleW_val_fieldID, __nsn1);
  if (!__failed) (*env)->SetDoubleField(env, cs1, doubleW_val_fieldID, __ncs1);
  if (!__failed) (*env)->SetDoubleField(env, rt2, doubleW_val_fieldID, __nrt2);
  if (!__failed) (*env)->SetDoubleField(env, rt1, doubleW_val_fieldID, __nrt1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaexc_)(int *wantq, int *n, double *t, int *ldt, double *q, int *ldq, int *j1, int *n1, int *n2, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jint j1, jint n1, jint n2, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlaexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nj1 __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nt = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  __nwantq = wantq;
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nj1 = j1;
  __nn1 = n1;
  __nn2 = n2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaexc_(&__nwantq, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, &__nj1, &__nn1, &__nn2, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlag2_)(double *a, int *lda, double *b, int *ldb, double *safmin, double *scale1, double *scale2, double *wr1, double *wr2, double *wi);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlag2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlag2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlag2K(JNIEnv *env, UNUSED jobject obj, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble safmin, jobject scale1, jobject scale2, jobject wr1, jobject wr2, jobject wi) {
  if (!dlag2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nsafmin __attribute__((aligned(8)));
  double __nscale1 = 0;
  double __nscale2 = 0;
  double __nwr1 = 0;
  double __nwr2 = 0;
  double __nwi = 0;
  double *__na = NULL;
  double *__nb = NULL;
  __nlda = lda;
  __nldb = ldb;
  __nsafmin = safmin;
  __nscale1 = (*env)->GetDoubleField(env, scale1, doubleW_val_fieldID);
  __nscale2 = (*env)->GetDoubleField(env, scale2, doubleW_val_fieldID);
  __nwr1 = (*env)->GetDoubleField(env, wr1, doubleW_val_fieldID);
  __nwr2 = (*env)->GetDoubleField(env, wr2, doubleW_val_fieldID);
  __nwi = (*env)->GetDoubleField(env, wi, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dlag2_(__na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nsafmin, &__nscale1, &__nscale2, &__nwr1, &__nwr2, &__nwi);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, wi, doubleW_val_fieldID, __nwi);
  if (!__failed) (*env)->SetDoubleField(env, wr2, doubleW_val_fieldID, __nwr2);
  if (!__failed) (*env)->SetDoubleField(env, wr1, doubleW_val_fieldID, __nwr1);
  if (!__failed) (*env)->SetDoubleField(env, scale2, doubleW_val_fieldID, __nscale2);
  if (!__failed) (*env)->SetDoubleField(env, scale1, doubleW_val_fieldID, __nscale1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlag2s_)(int *m, int *n, double *a, int *lda, float *sa, int *ldsa, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlag2s(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlag2s_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlag2sK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jfloatArray sa, jint offsetsa, jint ldsa, jobject info) {
  if (!dlag2s_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldsa __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  float *__nsa = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldsa = ldsa;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsa = (*env)->GetPrimitiveArrayCritical(env, sa, NULL))) { __failed = TRUE; goto done; }
  dlag2s_(&__nm, &__nn, __na + offseta, &__nlda, __nsa + offsetsa, &__nldsa, &__ninfo);
done:
  if (__nsa) (*env)->ReleasePrimitiveArrayCritical(env, sa, __nsa, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlags2_)(int *upper, double *a1, double *a2, double *a3, double *b1, double *b2, double *b3, double *csu, double *snu, double *csv, double *snv, double *csq, double *snq);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlags2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlags2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlags2K(JNIEnv *env, UNUSED jobject obj, jboolean upper, jdouble a1, jdouble a2, jdouble a3, jdouble b1, jdouble b2, jdouble b3, jobject csu, jobject snu, jobject csv, jobject snv, jobject csq, jobject snq) {
  if (!dlags2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nupper __attribute__((aligned(8)));
  double __na1 __attribute__((aligned(8)));
  double __na2 __attribute__((aligned(8)));
  double __na3 __attribute__((aligned(8)));
  double __nb1 __attribute__((aligned(8)));
  double __nb2 __attribute__((aligned(8)));
  double __nb3 __attribute__((aligned(8)));
  double __ncsu = 0;
  double __nsnu = 0;
  double __ncsv = 0;
  double __nsnv = 0;
  double __ncsq = 0;
  double __nsnq = 0;
  __nupper = upper;
  __na1 = a1;
  __na2 = a2;
  __na3 = a3;
  __nb1 = b1;
  __nb2 = b2;
  __nb3 = b3;
  __ncsu = (*env)->GetDoubleField(env, csu, doubleW_val_fieldID);
  __nsnu = (*env)->GetDoubleField(env, snu, doubleW_val_fieldID);
  __ncsv = (*env)->GetDoubleField(env, csv, doubleW_val_fieldID);
  __nsnv = (*env)->GetDoubleField(env, snv, doubleW_val_fieldID);
  __ncsq = (*env)->GetDoubleField(env, csq, doubleW_val_fieldID);
  __nsnq = (*env)->GetDoubleField(env, snq, doubleW_val_fieldID);
  dlags2_(&__nupper, &__na1, &__na2, &__na3, &__nb1, &__nb2, &__nb3, &__ncsu, &__nsnu, &__ncsv, &__nsnv, &__ncsq, &__nsnq);
done:
  if (!__failed) (*env)->SetDoubleField(env, snq, doubleW_val_fieldID, __nsnq);
  if (!__failed) (*env)->SetDoubleField(env, csq, doubleW_val_fieldID, __ncsq);
  if (!__failed) (*env)->SetDoubleField(env, snv, doubleW_val_fieldID, __nsnv);
  if (!__failed) (*env)->SetDoubleField(env, csv, doubleW_val_fieldID, __ncsv);
  if (!__failed) (*env)->SetDoubleField(env, snu, doubleW_val_fieldID, __nsnu);
  if (!__failed) (*env)->SetDoubleField(env, csu, doubleW_val_fieldID, __ncsu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlagtf_)(int *n, double *a, double *lambda, double *b, double *c, double *tol, double *d, int *in, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlagtf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlagtf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jdouble lambda, jdoubleArray b, jint offsetb, jdoubleArray c, jint offsetc, jdouble tol, jdoubleArray d, jint offsetd, jintArray in, jint offsetin, jobject info) {
  if (!dlagtf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nlambda __attribute__((aligned(8)));
  double __ntol __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  double *__nd = NULL;
  int *__nin = NULL;
  __nn = n;
  __nlambda = lambda;
  __ntol = tol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) { __failed = TRUE; goto done; }
  dlagtf_(&__nn, __na + offseta, &__nlambda, __nb + offsetb, __nc + offsetc, &__ntol, __nd + offsetd, __nin + offsetin, &__ninfo);
done:
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlagtm_)(const char *trans, int *n, int *nrhs, double *alpha, double *dl, double *d, double *du, double *x, int *ldx, double *beta, double *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlagtm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlagtm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtmK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdouble alpha, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray x, jint offsetx, jint ldx, jdouble beta, jdoubleArray b, jint offsetb, jint ldb) {
  if (!dlagtm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  double __nalpha __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nbeta __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  double *__nx = NULL;
  double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nalpha = alpha;
  __nldx = ldx;
  __nbeta = beta;
  __nldb = ldb;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dlagtm_(__ntrans, &__nn, &__nnrhs, &__nalpha, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nx + offsetx, &__nldx, &__nbeta, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlagts_)(int *job, int *n, double *a, double *b, double *c, double *d, int *in, double *y, double *tol, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlagts(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlagts_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtsK(JNIEnv *env, UNUSED jobject obj, jint job, jint n, jdoubleArray a, jint offseta, jdoubleArray b, jint offsetb, jdoubleArray c, jint offsetc, jdoubleArray d, jint offsetd, jintArray in, jint offsetin, jdoubleArray y, jint offsety, jobject tol, jobject info) {
  if (!dlagts_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __njob __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  double __ntol = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  double *__nd = NULL;
  int *__nin = NULL;
  double *__ny = NULL;
  __njob = job;
  __nn = n;
  __ntol = (*env)->GetDoubleField(env, tol, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  dlagts_(&__njob, &__nn, __na + offseta, __nb + offsetb, __nc + offsetc, __nd + offsetd, __nin + offsetin, __ny + offsety, &__ntol, &__ninfo);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, tol, doubleW_val_fieldID, __ntol);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlagv2_)(double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *csl, double *snl, double *csr, double *snr);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlagv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlagv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagv2K(JNIEnv *env, UNUSED jobject obj, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jobject csl, jobject snl, jobject csr, jobject snr) {
  if (!dlagv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __ncsl = 0;
  double __nsnl = 0;
  double __ncsr = 0;
  double __nsnr = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  __nlda = lda;
  __nldb = ldb;
  __ncsl = (*env)->GetDoubleField(env, csl, doubleW_val_fieldID);
  __nsnl = (*env)->GetDoubleField(env, snl, doubleW_val_fieldID);
  __ncsr = (*env)->GetDoubleField(env, csr, doubleW_val_fieldID);
  __nsnr = (*env)->GetDoubleField(env, snr, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  dlagv2_(__na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, &__ncsl, &__nsnl, &__ncsr, &__nsnr);
done:
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, snr, doubleW_val_fieldID, __nsnr);
  if (!__failed) (*env)->SetDoubleField(env, csr, doubleW_val_fieldID, __ncsr);
  if (!__failed) (*env)->SetDoubleField(env, snl, doubleW_val_fieldID, __nsnl);
  if (!__failed) (*env)->SetDoubleField(env, csl, doubleW_val_fieldID, __ncsl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlahqr_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlahqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlahqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahqrK(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject info) {
  if (!dlahqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nz = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlahqr_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlahr2_)(int *n, int *k, int *nb, double *a, int *lda, double *tau, double *t, int *ldt, double *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlahr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlahr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahr2K(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt, jdoubleArray y, jint offsety, jint ldy) {
  if (!dlahr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nt = NULL;
  double *__ny = NULL;
  __nn = n;
  __nk = k;
  __nnb = nb;
  __nlda = lda;
  __nldt = ldt;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  dlahr2_(&__nn, &__nk, &__nnb, __na + offseta, &__nlda, __ntau + offsettau, __nt + offsett, &__nldt, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlahrd_)(int *n, int *k, int *nb, double *a, int *lda, double *tau, double *t, int *ldt, double *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlahrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlahrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt, jdoubleArray y, jint offsety, jint ldy) {
  if (!dlahrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nt = NULL;
  double *__ny = NULL;
  __nn = n;
  __nk = k;
  __nnb = nb;
  __nlda = lda;
  __nldt = ldt;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  dlahrd_(&__nn, &__nk, &__nnb, __na + offseta, &__nlda, __ntau + offsettau, __nt + offsett, &__nldt, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaic1_)(int *job, int *j, double *x, double *sest, double *w, double *gamma, double *sestpr, double *s, double *c);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaic1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaic1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaic1K(JNIEnv *env, UNUSED jobject obj, jint job, jint j, jdoubleArray x, jint offsetx, jdouble sest, jdoubleArray w, jint offsetw, jdouble gamma, jobject sestpr, jobject s, jobject c) {
  if (!dlaic1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __njob __attribute__((aligned(8)));
  int __nj __attribute__((aligned(8)));
  double __nsest __attribute__((aligned(8)));
  double __ngamma __attribute__((aligned(8)));
  double __nsestpr = 0;
  double __ns = 0;
  double __nc = 0;
  double *__nx = NULL;
  double *__nw = NULL;
  __njob = job;
  __nj = j;
  __nsest = sest;
  __ngamma = gamma;
  __nsestpr = (*env)->GetDoubleField(env, sestpr, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  dlaic1_(&__njob, &__nj, __nx + offsetx, &__nsest, __nw + offsetw, &__ngamma, &__nsestpr, &__ns, &__nc);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!__failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!__failed) (*env)->SetDoubleField(env, sestpr, doubleW_val_fieldID, __nsestpr);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*dlaisnan_)(double *din1, double *din2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaisnan(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaisnan_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaisnanK(JNIEnv *env, UNUSED jobject obj, jdouble din1, jdouble din2) {
  if (!dlaisnan_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  double __ndin1 __attribute__((aligned(8)));
  double __ndin2 __attribute__((aligned(8)));
  __ndin1 = din1;
  __ndin2 = din2;
  __ret = dlaisnan_(&__ndin1, &__ndin2);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*dlaln2_)(int *ltrans, int *na, int *nw, double *smin, double *ca, double *a, int *lda, double *d1, double *d2, double *b, int *ldb, double *wr, double *wi, double *x, int *ldx, double *scale, double *xnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaln2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaln2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaln2K(JNIEnv *env, UNUSED jobject obj, jboolean ltrans, jint na, jint nw, jdouble smin, jdouble ca, jdoubleArray a, jint offseta, jint lda, jdouble d1, jdouble d2, jdoubleArray b, jint offsetb, jint ldb, jdouble wr, jdouble wi, jdoubleArray x, jint offsetx, jint ldx, jobject scale, jobject xnorm, jobject info) {
  if (!dlaln2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltrans __attribute__((aligned(8)));
  int __nna __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  double __nsmin __attribute__((aligned(8)));
  double __nca __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nd1 __attribute__((aligned(8)));
  double __nd2 __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nwr __attribute__((aligned(8)));
  double __nwi __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nscale = 0;
  double __nxnorm = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  __nltrans = ltrans;
  __nna = na;
  __nnw = nw;
  __nsmin = smin;
  __nca = ca;
  __nlda = lda;
  __nd1 = d1;
  __nd2 = d2;
  __nldb = ldb;
  __nwr = wr;
  __nwi = wi;
  __nldx = ldx;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nxnorm = (*env)->GetDoubleField(env, xnorm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlaln2_(&__nltrans, &__nna, &__nnw, &__nsmin, &__nca, __na + offseta, &__nlda, &__nd1, &__nd2, __nb + offsetb, &__nldb, &__nwr, &__nwi, __nx + offsetx, &__nldx, &__nscale, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, xnorm, doubleW_val_fieldID, __nxnorm);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlals0_)(int *icompq, int *nl, int *nr, int *sqre, int *nrhs, double *b, int *ldb, double *bx, int *ldbx, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *poles, double *difl, double *difr, double *z, int *k, double *c, double *s, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlals0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlals0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlals0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jint nrhs, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray bx, jint offsetbx, jint ldbx, jintArray perm, jint offsetperm, jint givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jdoubleArray poles, jint offsetpoles, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jint k, jdouble c, jdouble s, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlals0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldbx __attribute__((aligned(8)));
  int __ngivptr __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  double __nc __attribute__((aligned(8)));
  double __ns __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nb = NULL;
  double *__nbx = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  double *__npoles = NULL;
  double *__ndifl = NULL;
  double *__ndifr = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldbx = ldbx;
  __ngivptr = givptr;
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nk = k;
  __nc = c;
  __ns = s;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlals0_(&__nicompq, &__nnl, &__nnr, &__nsqre, &__nnrhs, __nb + offsetb, &__nldb, __nbx + offsetbx, &__nldbx, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlalsa_)(int *icompq, int *smlsiz, int *n, int *nrhs, double *b, int *ldb, double *bx, int *ldbx, double *u, int *ldu, double *vt, int *k, double *difl, double *difr, double *z, double *poles, int *givptr, int *givcol, int *ldgcol, int *perm, double *givnum, double *c, double *s, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlalsa(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlalsa_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlalsaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint nrhs, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray bx, jint offsetbx, jint ldbx, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jintArray k, jint offsetk, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jdoubleArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jdoubleArray givnum, jint offsetgivnum, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlalsa_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldbx __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nb = NULL;
  double *__nbx = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  int *__nk = NULL;
  double *__ndifl = NULL;
  double *__ndifr = NULL;
  double *__nz = NULL;
  double *__npoles = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  int *__nperm = NULL;
  double *__ngivnum = NULL;
  double *__nc = NULL;
  double *__ns = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nsmlsiz = smlsiz;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldbx = ldbx;
  __nldu = ldu;
  __nldgcol = ldgcol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlalsa_(&__nicompq, &__nsmlsiz, &__nn, &__nnrhs, __nb + offsetb, &__nldb, __nbx + offsetbx, &__nldbx, __nu + offsetu, &__nldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &__nldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlalsd_)(const char *uplo, int *smlsiz, int *n, int *nrhs, double *d, double *e, double *b, int *ldb, double *rcond, int *rank, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlalsd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlalsd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlalsdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint smlsiz, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlalsd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nb = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nsmlsiz = smlsiz;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlalsd_(__nuplo, &__nsmlsiz, &__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__nrcond, &__nrank, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlamrg_)(int *n1, int *n2, double *a, int *dtrd1, int *dtrd2, int *index);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamrg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlamrg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamrgK(JNIEnv *env, UNUSED jobject obj, jint n1, jint n2, jdoubleArray a, jint offseta, jint dtrd1, jint dtrd2, jintArray index, jint offsetindex) {
  if (!dlamrg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __ndtrd1 __attribute__((aligned(8)));
  int __ndtrd2 __attribute__((aligned(8)));
  double *__na = NULL;
  int *__nindex = NULL;
  __nn1 = n1;
  __nn2 = n2;
  __ndtrd1 = dtrd1;
  __ndtrd2 = dtrd2;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindex = (*env)->GetPrimitiveArrayCritical(env, index, NULL))) { __failed = TRUE; goto done; }
  dlamrg_(&__nn1, &__nn2, __na + offseta, &__ndtrd1, &__ndtrd2, __nindex + offsetindex);
done:
  if (__nindex) (*env)->ReleasePrimitiveArrayCritical(env, index, __nindex, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*dlaneg_)(int *n, double *d, double *lld, double *sigma, double *pivmin, int *r);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaneg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaneg_ != NULL;
}

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanegK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray lld, jint offsetlld, jdouble sigma, jdouble pivmin, jint r) {
  if (!dlaneg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jint __ret = 0;
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nsigma __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  int __nr __attribute__((aligned(8)));
  double *__nd = NULL;
  double *__nlld = NULL;
  __nn = n;
  __nsigma = sigma;
  __npivmin = pivmin;
  __nr = r;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  __ret = dlaneg_(&__nn, __nd + offsetd, __nlld + offsetlld, &__nsigma, &__npivmin, &__nr);
done:
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlangb_)(const char *norm, int *n, int *kl, int *ku, double *ab, int *ldab, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlangb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlangb_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  if (!dlangb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double *__nab = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlangb_(__nnorm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlange_)(const char *norm, int *m, int *n, double *a, int *lda, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlange(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlange_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangeK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  if (!dlange_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlange_(__nnorm, &__nm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlangt_)(const char *norm, int *n, double *dl, double *d, double *du);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlangt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlangt_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangtK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu) {
  if (!dlangt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  double *__ndl = NULL;
  double *__nd = NULL;
  double *__ndu = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  __ret = dlangt_(__nnorm, &__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu);
done:
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlanhs_)(const char *norm, int *n, double *a, int *lda, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlanhs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlanhs_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanhsK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  if (!dlanhs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlanhs_(__nnorm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlansb_)(const char *norm, const char *uplo, int *n, int *k, double *ab, int *ldab, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlansb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlansb_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlansbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jint k, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  if (!dlansb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double *__nab = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlansb_(__nnorm, __nuplo, &__nn, &__nk, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlansp_)(const char *norm, const char *uplo, int *n, double *ap, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlansp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlansp_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanspK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray work, jint offsetwork) {
  if (!dlansp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double *__nap = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlansp_(__nnorm, __nuplo, &__nn, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlanst_)(const char *norm, int *n, double *d, double *e);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlanst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlanst_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanstK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete) {
  if (!dlanst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  double *__nd = NULL;
  double *__ne = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  __ret = dlanst_(__nnorm, &__nn, __nd + offsetd, __ne + offsete);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlansy_)(const char *norm, const char *uplo, int *n, double *a, int *lda, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlansy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlansy_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlansyK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  if (!dlansy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlansy_(__nnorm, __nuplo, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlantb_)(const char *norm, const char *uplo, const char *diag, int *n, int *k, double *ab, int *ldab, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlantb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlantb_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint k, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  if (!dlantb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double *__nab = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlantb_(__nnorm, __nuplo, __ndiag, &__nn, &__nk, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlantp_)(const char *norm, const char *uplo, const char *diag, int *n, double *ap, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlantp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlantp_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantpK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jdoubleArray work, jint offsetwork) {
  if (!dlantp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  double *__nap = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlantp_(__nnorm, __nuplo, __ndiag, &__nn, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlantr_)(const char *norm, const char *uplo, const char *diag, int *m, int *n, double *a, int *lda, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlantr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlantr_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantrK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  if (!dlantr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = dlantr_(__nnorm, __nuplo, __ndiag, &__nm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*dlanv2_)(double *a, double *b, double *c, double *d, double *rt1r, double *rt1i, double *rt2r, double *rt2i, double *cs, double *sn);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlanv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlanv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanv2K(JNIEnv *env, UNUSED jobject obj, jobject a, jobject b, jobject c, jobject d, jobject rt1r, jobject rt1i, jobject rt2r, jobject rt2i, jobject cs, jobject sn) {
  if (!dlanv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __na = 0;
  double __nb = 0;
  double __nc = 0;
  double __nd = 0;
  double __nrt1r = 0;
  double __nrt1i = 0;
  double __nrt2r = 0;
  double __nrt2i = 0;
  double __ncs = 0;
  double __nsn = 0;
  __na = (*env)->GetDoubleField(env, a, doubleW_val_fieldID);
  __nb = (*env)->GetDoubleField(env, b, doubleW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __nd = (*env)->GetDoubleField(env, d, doubleW_val_fieldID);
  __nrt1r = (*env)->GetDoubleField(env, rt1r, doubleW_val_fieldID);
  __nrt1i = (*env)->GetDoubleField(env, rt1i, doubleW_val_fieldID);
  __nrt2r = (*env)->GetDoubleField(env, rt2r, doubleW_val_fieldID);
  __nrt2i = (*env)->GetDoubleField(env, rt2i, doubleW_val_fieldID);
  __ncs = (*env)->GetDoubleField(env, cs, doubleW_val_fieldID);
  __nsn = (*env)->GetDoubleField(env, sn, doubleW_val_fieldID);
  dlanv2_(&__na, &__nb, &__nc, &__nd, &__nrt1r, &__nrt1i, &__nrt2r, &__nrt2i, &__ncs, &__nsn);
done:
  if (!__failed) (*env)->SetDoubleField(env, sn, doubleW_val_fieldID, __nsn);
  if (!__failed) (*env)->SetDoubleField(env, cs, doubleW_val_fieldID, __ncs);
  if (!__failed) (*env)->SetDoubleField(env, rt2i, doubleW_val_fieldID, __nrt2i);
  if (!__failed) (*env)->SetDoubleField(env, rt2r, doubleW_val_fieldID, __nrt2r);
  if (!__failed) (*env)->SetDoubleField(env, rt1i, doubleW_val_fieldID, __nrt1i);
  if (!__failed) (*env)->SetDoubleField(env, rt1r, doubleW_val_fieldID, __nrt1r);
  if (!__failed) (*env)->SetDoubleField(env, d, doubleW_val_fieldID, __nd);
  if (!__failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!__failed) (*env)->SetDoubleField(env, b, doubleW_val_fieldID, __nb);
  if (!__failed) (*env)->SetDoubleField(env, a, doubleW_val_fieldID, __na);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlapll_)(int *n, double *x, int *incx, double *y, int *incy, double *ssmin);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlapll(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlapll_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapllK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jobject ssmin) {
  if (!dlapll_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  double __nssmin = 0;
  double *__nx = NULL;
  double *__ny = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  dlapll_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, &__nssmin);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlapmt_)(int *forwrd, int *m, int *n, double *x, int *ldx, int *k);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlapmt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlapmt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapmtK(JNIEnv *env, UNUSED jobject obj, jboolean forwrd, jint m, jint n, jdoubleArray x, jint offsetx, jint ldx, jintArray k, jint offsetk) {
  if (!dlapmt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nforwrd __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double *__nx = NULL;
  int *__nk = NULL;
  __nforwrd = forwrd;
  __nm = m;
  __nn = n;
  __nldx = ldx;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  dlapmt_(&__nforwrd, &__nm, &__nn, __nx + offsetx, &__nldx, __nk + offsetk);
done:
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static double (*dlapy2_)(double *x, double *y);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlapy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlapy2_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapy2K(JNIEnv *env, UNUSED jobject obj, jdouble x, jdouble y) {
  if (!dlapy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  double __nx __attribute__((aligned(8)));
  double __ny __attribute__((aligned(8)));
  __nx = x;
  __ny = y;
  __ret = dlapy2_(&__nx, &__ny);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static double (*dlapy3_)(double *x, double *y, double *z);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlapy3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlapy3_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapy3K(JNIEnv *env, UNUSED jobject obj, jdouble x, jdouble y, jdouble z) {
  if (!dlapy3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  double __nx __attribute__((aligned(8)));
  double __ny __attribute__((aligned(8)));
  double __nz __attribute__((aligned(8)));
  __nx = x;
  __ny = y;
  __nz = z;
  __ret = dlapy3_(&__nx, &__ny, &__nz);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*dlaqgb_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqgb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqgb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqgbK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdouble rowcnd, jdouble colcnd, jdouble amax, jobject equed) {
  if (!dlaqgb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nrowcnd __attribute__((aligned(8)));
  double __ncolcnd __attribute__((aligned(8)));
  double __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  double *__nab = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nrowcnd = rowcnd;
  __ncolcnd = colcnd;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dlaqgb_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqge_)(int *m, int *n, double *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqge(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqge_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqgeK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdouble rowcnd, jdouble colcnd, jdouble amax, jobject equed) {
  if (!dlaqge_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nrowcnd __attribute__((aligned(8)));
  double __ncolcnd __attribute__((aligned(8)));
  double __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  double *__na = NULL;
  double *__nr = NULL;
  double *__nc = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nrowcnd = rowcnd;
  __ncolcnd = colcnd;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dlaqge_(&__nm, &__nn, __na + offseta, &__nlda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqp2_)(int *m, int *n, int *offset, double *a, int *lda, int *jpvt, double *tau, double *vn1, double *vn2, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqp2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqp2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqp2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray vn1, jint offsetvn1, jdoubleArray vn2, jint offsetvn2, jdoubleArray work, jint offsetwork) {
  if (!dlaqp2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  int *__njpvt = NULL;
  double *__ntau = NULL;
  double *__nvn1 = NULL;
  double *__nvn2 = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __noffset = offset;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqp2_(&__nm, &__nn, &__noffset, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, __failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqps_)(int *m, int *n, int *offset, int *nb, int *kb, double *a, int *lda, int *jpvt, double *tau, double *vn1, double *vn2, double *auxv, double *f, int *ldf);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqps(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqps_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqpsK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jint nb, jobject kb, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray vn1, jint offsetvn1, jdoubleArray vn2, jint offsetvn2, jdoubleArray auxv, jint offsetauxv, jdoubleArray f, jint offsetf, jint ldf) {
  if (!dlaqps_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nkb = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  double *__na = NULL;
  int *__njpvt = NULL;
  double *__ntau = NULL;
  double *__nvn1 = NULL;
  double *__nvn2 = NULL;
  double *__nauxv = NULL;
  double *__nf = NULL;
  __nm = m;
  __nn = n;
  __noffset = offset;
  __nnb = nb;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __nlda = lda;
  __nldf = ldf;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nauxv = (*env)->GetPrimitiveArrayCritical(env, auxv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  dlaqps_(&__nm, &__nn, &__noffset, &__nnb, &__nkb, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nauxv + offsetauxv, __nf + offsetf, &__nldf);
done:
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__nauxv) (*env)->ReleasePrimitiveArrayCritical(env, auxv, __nauxv, __failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, __failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr0_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr0K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dlaqr0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqr0_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr1_)(int *n, double *h, int *ldh, double *sr1, double *si1, double *sr2, double *si2, double *v);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray h, jint offseth, jint ldh, jdouble sr1, jdouble si1, jdouble sr2, jdouble si2, jdoubleArray v, jint offsetv) {
  if (!dlaqr1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  double __nsr1 __attribute__((aligned(8)));
  double __nsi1 __attribute__((aligned(8)));
  double __nsr2 __attribute__((aligned(8)));
  double __nsi2 __attribute__((aligned(8)));
  double *__nh = NULL;
  double *__nv = NULL;
  __nn = n;
  __nldh = ldh;
  __nsr1 = sr1;
  __nsi1 = si1;
  __nsr2 = sr2;
  __nsi2 = si2;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  dlaqr1_(&__nn, __nh + offseth, &__nldh, &__nsr1, &__nsi1, &__nsr2, &__nsi2, __nv + offsetv);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr2_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, int *ns, int *nd, double *sr, double *si, double *v, int *ldv, int *nh, double *t, int *ldt, int *nv, double *wv, int *ldwv, double *work, int *lwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr2K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray v, jint offsetv, jint ldv, jint nh, jdoubleArray t, jint offsett, jint ldt, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jdoubleArray work, jint offsetwork, jint lwork) {
  if (!dlaqr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nns = 0;
  int __nnd = 0;
  int __nldv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  double *__nh = NULL;
  double *__nz = NULL;
  double *__nsr = NULL;
  double *__nsi = NULL;
  double *__nv = NULL;
  double *__nt = NULL;
  double *__nwv = NULL;
  double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnw = nw;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nldv = ldv;
  __nnh = nh;
  __nldt = ldt;
  __nnv = nv;
  __nldwv = ldwv;
  __nlwork = lwork;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqr2_(&__nwantt, &__nwantz, &__nn, &__nktop, &__nkbot, &__nnw, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &__nldv, &__nnh, __nt + offsett, &__nldt, &__nnv, __nwv + offsetwv, &__nldwv, __nwork + offsetwork, &__nlwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr3_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, int *ns, int *nd, double *sr, double *si, double *v, int *ldv, int *nh, double *t, int *ldt, int *nv, double *wv, int *ldwv, double *work, int *lwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr3K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray v, jint offsetv, jint ldv, jint nh, jdoubleArray t, jint offsett, jint ldt, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jdoubleArray work, jint offsetwork, jint lwork) {
  if (!dlaqr3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nns = 0;
  int __nnd = 0;
  int __nldv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  double *__nh = NULL;
  double *__nz = NULL;
  double *__nsr = NULL;
  double *__nsi = NULL;
  double *__nv = NULL;
  double *__nt = NULL;
  double *__nwv = NULL;
  double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnw = nw;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nldv = ldv;
  __nnh = nh;
  __nldt = ldt;
  __nnv = nv;
  __nldwv = ldwv;
  __nlwork = lwork;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqr3_(&__nwantt, &__nwantz, &__nn, &__nktop, &__nkbot, &__nnw, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &__nldv, &__nnh, __nt + offsett, &__nldt, &__nnv, __nwv + offsetwv, &__nldwv, __nwork + offsetwork, &__nlwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr4_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr4K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dlaqr4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nh = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqr4_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqr5_)(int *wantt, int *wantz, int *kacc22, int *n, int *ktop, int *kbot, int *nshfts, double *sr, double *si, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, double *v, int *ldv, double *u, int *ldu, int *nv, double *wv, int *ldwv, int *nh, double *wh, int *ldwh);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqr5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqr5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr5K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint kacc22, jint n, jint ktop, jint kbot, jint nshfts, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray u, jint offsetu, jint ldu, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jint nh, jdoubleArray wh, jint offsetwh, jint ldwh) {
  if (!dlaqr5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nkacc22 __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnshfts __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldwh __attribute__((aligned(8)));
  double *__nsr = NULL;
  double *__nsi = NULL;
  double *__nh = NULL;
  double *__nz = NULL;
  double *__nv = NULL;
  double *__nu = NULL;
  double *__nwv = NULL;
  double *__nwh = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nkacc22 = kacc22;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnshfts = nshfts;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nldv = ldv;
  __nldu = ldu;
  __nnv = nv;
  __nldwv = ldwv;
  __nnh = nh;
  __nldwh = ldwh;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwh = (*env)->GetPrimitiveArrayCritical(env, wh, NULL))) { __failed = TRUE; goto done; }
  dlaqr5_(&__nwantt, &__nwantz, &__nkacc22, &__nn, &__nktop, &__nkbot, &__nnshfts, __nsr + offsetsr, __nsi + offsetsi, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nv + offsetv, &__nldv, __nu + offsetu, &__nldu, &__nnv, __nwv + offsetwv, &__nldwv, &__nnh, __nwh + offsetwh, &__nldwh);
done:
  if (__nwh) (*env)->ReleasePrimitiveArrayCritical(env, wh, __nwh, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqsb_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *s, double *scond, double *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqsb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqsb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqsbK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  if (!dlaqsb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nscond __attribute__((aligned(8)));
  double __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  double *__nab = NULL;
  double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlaqsb_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqsp_)(const char *uplo, int *n, double *ap, double *s, double *scond, double *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqsp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqsp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqspK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  if (!dlaqsp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nscond __attribute__((aligned(8)));
  double __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  double *__nap = NULL;
  double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlaqsp_(__nuplo, &__nn, __nap + offsetap, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqsy_)(const char *uplo, int *n, double *a, int *lda, double *s, double *scond, double *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqsy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqsy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqsyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  if (!dlaqsy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nscond __attribute__((aligned(8)));
  double __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  double *__na = NULL;
  double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlaqsy_(__nuplo, &__nn, __na + offseta, &__nlda, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaqtr_)(int *ltran, int *lreal, int *n, double *t, int *ldt, double *b, double *w, double *scale, double *x, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaqtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaqtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqtrK(JNIEnv *env, UNUSED jobject obj, jboolean ltran, jboolean lreal, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray b, jint offsetb, jdouble w, jobject scale, jdoubleArray x, jint offsetx, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlaqtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltran __attribute__((aligned(8)));
  int __nlreal __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  double __nw __attribute__((aligned(8)));
  double __nscale = 0;
  int __ninfo = 0;
  double *__nt = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nwork = NULL;
  __nltran = ltran;
  __nlreal = lreal;
  __nn = n;
  __nldt = ldt;
  __nw = w;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlaqtr_(&__nltran, &__nlreal, &__nn, __nt + offsett, &__nldt, __nb + offsetb, &__nw, &__nscale, __nx + offsetx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlar1v_)(int *n, int *b1, int *bn, double *lambda, double *d, double *l, double *ld, double *lld, double *pivmin, double *gaptol, double *z, int *wantnc, int *negcnt, double *ztz, double *mingma, int *r, int *isuppz, double *nrminv, double *resid, double *rqcorr, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlar1v(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlar1v_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlar1vK(JNIEnv *env, UNUSED jobject obj, jint n, jint b1, jint bn, jdouble lambda, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdoubleArray ld, jint offsetld, jdoubleArray lld, jint offsetlld, jdouble pivmin, jdouble gaptol, jdoubleArray z, jint offsetz, jboolean wantnc, jobject negcnt, jobject ztz, jobject mingma, jobject r, jintArray isuppz, jint offsetisuppz, jobject nrminv, jobject resid, jobject rqcorr, jdoubleArray work, jint offsetwork) {
  if (!dlar1v_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nb1 __attribute__((aligned(8)));
  int __nbn __attribute__((aligned(8)));
  double __nlambda __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  double __ngaptol __attribute__((aligned(8)));
  int __nwantnc __attribute__((aligned(8)));
  int __nnegcnt = 0;
  double __nztz = 0;
  double __nmingma = 0;
  int __nr = 0;
  double __nnrminv = 0;
  double __nresid = 0;
  double __nrqcorr = 0;
  double *__nd = NULL;
  double *__nl = NULL;
  double *__nld = NULL;
  double *__nlld = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nb1 = b1;
  __nbn = bn;
  __nlambda = lambda;
  __npivmin = pivmin;
  __ngaptol = gaptol;
  __nwantnc = wantnc;
  __nnegcnt = (*env)->GetIntField(env, negcnt, intW_val_fieldID);
  __nztz = (*env)->GetDoubleField(env, ztz, doubleW_val_fieldID);
  __nmingma = (*env)->GetDoubleField(env, mingma, doubleW_val_fieldID);
  __nr = (*env)->GetIntField(env, r, intW_val_fieldID);
  __nnrminv = (*env)->GetDoubleField(env, nrminv, doubleW_val_fieldID);
  __nresid = (*env)->GetDoubleField(env, resid, doubleW_val_fieldID);
  __nrqcorr = (*env)->GetDoubleField(env, rqcorr, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlar1v_(&__nn, &__nb1, &__nbn, &__nlambda, __nd + offsetd, __nl + offsetl, __nld + offsetld, __nlld + offsetlld, &__npivmin, &__ngaptol, __nz + offsetz, &__nwantnc, &__nnegcnt, &__nztz, &__nmingma, &__nr, __nisuppz + offsetisuppz, &__nnrminv, &__nresid, &__nrqcorr, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, rqcorr, doubleW_val_fieldID, __nrqcorr);
  if (!__failed) (*env)->SetDoubleField(env, resid, doubleW_val_fieldID, __nresid);
  if (!__failed) (*env)->SetDoubleField(env, nrminv, doubleW_val_fieldID, __nnrminv);
  if (!__failed) (*env)->SetIntField(env, r, intW_val_fieldID, __nr);
  if (!__failed) (*env)->SetDoubleField(env, mingma, doubleW_val_fieldID, __nmingma);
  if (!__failed) (*env)->SetDoubleField(env, ztz, doubleW_val_fieldID, __nztz);
  if (!__failed) (*env)->SetIntField(env, negcnt, intW_val_fieldID, __nnegcnt);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlar2v_)(int *n, double *x, double *y, double *z, int *incx, double *c, double *s, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlar2v(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlar2v_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlar2vK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jdoubleArray y, jint offsety, jdoubleArray z, jint offsetz, jint incx, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jint incc) {
  if (!dlar2v_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  double *__nx = NULL;
  double *__ny = NULL;
  double *__nz = NULL;
  double *__nc = NULL;
  double *__ns = NULL;
  __nn = n;
  __nincx = incx;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlar2v_(&__nn, __nx + offsetx, __ny + offsety, __nz + offsetz, &__nincx, __nc + offsetc, __ns + offsets, &__nincc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarf_)(const char *side, int *m, int *n, double *v, int *incv, double *tau, double *c, int *Ldc, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  if (!dlarf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  double __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarf_(__nside, &__nm, &__nn, __nv + offsetv, &__nincv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarfb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, double *v, int *ldv, double *t, int *ldt, double *c, int *Ldc, double *work, int *ldwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarfb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarfb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray t, jint offsett, jint ldt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint ldwork) {
  if (!dlarfb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldwork __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nt = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  __nLdc = Ldc;
  __nldwork = ldwork;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarfb_(__nside, __ntrans, __ndirect, __nstorev, &__nm, &__nn, &__nk, __nv + offsetv, &__nldv, __nt + offsett, &__nldt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarfg_)(int *n, double *alpha, double *x, int *incx, double *tau);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarfg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarfg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfgK(JNIEnv *env, UNUSED jobject obj, jint n, jobject alpha, jdoubleArray x, jint offsetx, jint incx, jobject tau) {
  if (!dlarfg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nalpha = 0;
  int __nincx __attribute__((aligned(8)));
  double __ntau = 0;
  double *__nx = NULL;
  __nn = n;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __nincx = incx;
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlarfg_(&__nn, &__nalpha, __nx + offsetx, &__nincx, &__ntau);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (!__failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarft_)(const char *direct, const char *storev, int *n, int *k, double *v, int *ldv, double *tau, double *t, int *ldt);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarft(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarft_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarftK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt) {
  if (!dlarft_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__ntau = NULL;
  double *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  dlarft_(__ndirect, __nstorev, &__nn, &__nk, __nv + offsetv, &__nldv, __ntau + offsettau, __nt + offsett, &__nldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarfx_)(const char *side, int *m, int *n, double *v, double *tau, double *c, int *Ldc, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarfx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarfx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfxK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  if (!dlarfx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  double __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarfx_(__nside, &__nm, &__nn, __nv + offsetv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlargv_)(int *n, double *x, int *incx, double *y, int *incy, double *c, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlargv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlargv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlargvK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jdoubleArray c, jint offsetc, jint incc) {
  if (!dlargv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  double *__nx = NULL;
  double *__ny = NULL;
  double *__nc = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dlargv_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, __nc + offsetc, &__nincc);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarnv_)(int *idist, int *iseed, int *n, double *x);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarnv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarnv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarnvK(JNIEnv *env, UNUSED jobject obj, jint idist, jintArray iseed, jint offsetiseed, jint n, jdoubleArray x, jint offsetx) {
  if (!dlarnv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nidist __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int *__niseed = NULL;
  double *__nx = NULL;
  __nidist = idist;
  __nn = n;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlarnv_(&__nidist, __niseed + offsetiseed, &__nn, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarra_)(int *n, double *d, double *e, double *e2, double *spltol, double *tnrm, int *nsplit, int *isplit, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarra(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarra_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarraK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble spltol, jdouble tnrm, jobject nsplit, jintArray isplit, jint offsetisplit, jobject info) {
  if (!dlarra_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nspltol __attribute__((aligned(8)));
  double __ntnrm __attribute__((aligned(8)));
  int __nnsplit = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ne2 = NULL;
  int *__nisplit = NULL;
  __nn = n;
  __nspltol = spltol;
  __ntnrm = tnrm;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  dlarra_(&__nn, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__nspltol, &__ntnrm, &__nnsplit, __nisplit + offsetisplit, &__ninfo);
done:
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrb_)(int *n, double *d, double *lld, int *ifirst, int *ilast, double *rtol1, double *rtol2, int *offset, double *w, double *wgap, double *werr, double *work, int *iwork, double *pivmin, double *spdiam, int *twist, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrbK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray lld, jint offsetlld, jint ifirst, jint ilast, jdouble rtol1, jdouble rtol2, jint offset, jdoubleArray w, jint offsetw, jdoubleArray wgap, jint offsetwgap, jdoubleArray werr, jint offsetwerr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jdouble pivmin, jdouble spdiam, jint twist, jobject info) {
  if (!dlarrb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nifirst __attribute__((aligned(8)));
  int __nilast __attribute__((aligned(8)));
  double __nrtol1 __attribute__((aligned(8)));
  double __nrtol2 __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  double __nspdiam __attribute__((aligned(8)));
  int __ntwist __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nlld = NULL;
  double *__nw = NULL;
  double *__nwgap = NULL;
  double *__nwerr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nifirst = ifirst;
  __nilast = ilast;
  __nrtol1 = rtol1;
  __nrtol2 = rtol2;
  __noffset = offset;
  __npivmin = pivmin;
  __nspdiam = spdiam;
  __ntwist = twist;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlarrb_(&__nn, __nd + offsetd, __nlld + offsetlld, &__nifirst, &__nilast, &__nrtol1, &__nrtol2, &__noffset, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &__npivmin, &__nspdiam, &__ntwist, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrc_)(const char *jobt, int *n, double *vl, double *vu, double *d, double *e, double *pivmin, int *eigcnt, int *lcnt, int *rcnt, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrcK(JNIEnv *env, UNUSED jobject obj, jstring jobt, jint n, jdouble vl, jdouble vu, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble pivmin, jobject eigcnt, jobject lcnt, jobject rcnt, jobject info) {
  if (!dlarrc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobt = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  int __neigcnt = 0;
  int __nlcnt = 0;
  int __nrcnt = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  if (!(__njobt = (*env)->GetStringUTFChars(env, jobt, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __npivmin = pivmin;
  __neigcnt = (*env)->GetIntField(env, eigcnt, intW_val_fieldID);
  __nlcnt = (*env)->GetIntField(env, lcnt, intW_val_fieldID);
  __nrcnt = (*env)->GetIntField(env, rcnt, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  dlarrc_(__njobt, &__nn, &__nvl, &__nvu, __nd + offsetd, __ne + offsete, &__npivmin, &__neigcnt, &__nlcnt, &__nrcnt, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rcnt, intW_val_fieldID, __nrcnt);
  if (!__failed) (*env)->SetIntField(env, lcnt, intW_val_fieldID, __nlcnt);
  if (!__failed) (*env)->SetIntField(env, eigcnt, intW_val_fieldID, __neigcnt);
  if (__njobt) (*env)->ReleaseStringUTFChars(env, jobt, __njobt);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrd_)(const char *range, const char *order, int *n, double *vl, double *vu, int *il, int *iu, double *gers, double *reltol, double *d, double *e, double *e2, double *pivmin, int *nsplit, int *isplit, int *m, double *w, double *werr, double *wl, double *wu, int *iblock, int *indexw, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrdK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jdouble vl, jdouble vu, jint il, jint iu, jdoubleArray gers, jint offsetgers, jdouble reltol, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble pivmin, jint nsplit, jintArray isplit, jint offsetisplit, jobject m, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jobject wl, jobject wu, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlarrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  const char *__norder = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nreltol __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  int __nnsplit __attribute__((aligned(8)));
  int __nm = 0;
  double __nwl = 0;
  double __nwu = 0;
  int __ninfo = 0;
  double *__ngers = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ne2 = NULL;
  int *__nisplit = NULL;
  double *__nw = NULL;
  double *__nwerr = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nreltol = reltol;
  __npivmin = pivmin;
  __nnsplit = nsplit;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nwl = (*env)->GetDoubleField(env, wl, doubleW_val_fieldID);
  __nwu = (*env)->GetDoubleField(env, wu, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlarrd_(__nrange, __norder, &__nn, &__nvl, &__nvu, &__nil, &__niu, __ngers + offsetgers, &__nreltol, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__npivmin, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, &__nwl, &__nwu, __niblock + offsetiblock, __nindexw + offsetindexw, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, wu, doubleW_val_fieldID, __nwu);
  if (!__failed) (*env)->SetDoubleField(env, wl, doubleW_val_fieldID, __nwl);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarre_)(const char *range, int *n, double *vl, double *vu, int *il, int *iu, double *d, double *e, double *e2, double *rtol1, double *rtol2, double *spltol, int *nsplit, int *isplit, int *m, double *w, double *werr, double *wgap, int *iblock, int *indexw, double *gers, double *pivmin, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarre(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarre_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarreK(JNIEnv *env, UNUSED jobject obj, jstring range, jint n, jobject vl, jobject vu, jint il, jint iu, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble rtol1, jdouble rtol2, jdouble spltol, jobject nsplit, jintArray isplit, jint offsetisplit, jobject m, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray gers, jint offsetgers, jobject pivmin, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlarre_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl = 0;
  double __nvu = 0;
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nrtol1 __attribute__((aligned(8)));
  double __nrtol2 __attribute__((aligned(8)));
  double __nspltol __attribute__((aligned(8)));
  int __nnsplit = 0;
  int __nm = 0;
  double __npivmin = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ne2 = NULL;
  int *__nisplit = NULL;
  double *__nw = NULL;
  double *__nwerr = NULL;
  double *__nwgap = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  double *__ngers = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = (*env)->GetDoubleField(env, vl, doubleW_val_fieldID);
  __nvu = (*env)->GetDoubleField(env, vu, doubleW_val_fieldID);
  __nil = il;
  __niu = iu;
  __nrtol1 = rtol1;
  __nrtol2 = rtol2;
  __nspltol = spltol;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npivmin = (*env)->GetDoubleField(env, pivmin, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlarre_(__nrange, &__nn, &__nvl, &__nvu, &__nil, &__niu, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__nrtol1, &__nrtol2, &__nspltol, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, &__npivmin, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, pivmin, doubleW_val_fieldID, __npivmin);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!__failed) (*env)->SetDoubleField(env, vu, doubleW_val_fieldID, __nvu);
  if (!__failed) (*env)->SetDoubleField(env, vl, doubleW_val_fieldID, __nvl);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrf_)(int *n, double *d, double *l, double *ld, int *clstrt, int *clend, double *w, double *wgap, double *werr, double *spdiam, double *clgapl, double *clgapr, double *pivmin, double *sigma, double *dplus, double *lplus, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdoubleArray ld, jint offsetld, jint clstrt, jint clend, jdoubleArray w, jint offsetw, jdoubleArray wgap, jint offsetwgap, jdoubleArray werr, jint offsetwerr, jdouble spdiam, jdouble clgapl, jdouble clgapr, jdouble pivmin, jobject sigma, jdoubleArray dplus, jint offsetdplus, jdoubleArray lplus, jint offsetlplus, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlarrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nclstrt __attribute__((aligned(8)));
  int __nclend __attribute__((aligned(8)));
  double __nspdiam __attribute__((aligned(8)));
  double __nclgapl __attribute__((aligned(8)));
  double __nclgapr __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  double __nsigma = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nl = NULL;
  double *__nld = NULL;
  double *__nw = NULL;
  double *__nwgap = NULL;
  double *__nwerr = NULL;
  double *__ndplus = NULL;
  double *__nlplus = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nclstrt = clstrt;
  __nclend = clend;
  __nspdiam = spdiam;
  __nclgapl = clgapl;
  __nclgapr = clgapr;
  __npivmin = pivmin;
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndplus = (*env)->GetPrimitiveArrayCritical(env, dplus, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlplus = (*env)->GetPrimitiveArrayCritical(env, lplus, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarrf_(&__nn, __nd + offsetd, __nl + offsetl, __nld + offsetld, &__nclstrt, &__nclend, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, &__nspdiam, &__nclgapl, &__nclgapr, &__npivmin, &__nsigma, __ndplus + offsetdplus, __nlplus + offsetlplus, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nlplus) (*env)->ReleasePrimitiveArrayCritical(env, lplus, __nlplus, __failed ? JNI_ABORT : 0);
  if (__ndplus) (*env)->ReleasePrimitiveArrayCritical(env, dplus, __ndplus, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrj_)(int *n, double *d, double *e2, int *ifirst, int *ilast, double *rtol, int *offset, double *w, double *werr, double *work, int *iwork, double *pivmin, double *spdiam, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrj(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrj_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrjK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e2, jint offsete2, jint ifirst, jint ilast, jdouble rtol, jint offset, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jdouble pivmin, jdouble spdiam, jobject info) {
  if (!dlarrj_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nifirst __attribute__((aligned(8)));
  int __nilast __attribute__((aligned(8)));
  double __nrtol __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  double __nspdiam __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne2 = NULL;
  double *__nw = NULL;
  double *__nwerr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nifirst = ifirst;
  __nilast = ilast;
  __nrtol = rtol;
  __noffset = offset;
  __npivmin = pivmin;
  __nspdiam = spdiam;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlarrj_(&__nn, __nd + offsetd, __ne2 + offsete2, &__nifirst, &__nilast, &__nrtol, &__noffset, __nw + offsetw, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &__npivmin, &__nspdiam, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrk_)(int *n, int *iw, double *gl, double *gu, double *d, double *e2, double *pivmin, double *reltol, double *w, double *werr, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrk(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrk_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrkK(JNIEnv *env, UNUSED jobject obj, jint n, jint iw, jdouble gl, jdouble gu, jdoubleArray d, jint offsetd, jdoubleArray e2, jint offsete2, jdouble pivmin, jdouble reltol, jobject w, jobject werr, jobject info) {
  if (!dlarrk_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __niw __attribute__((aligned(8)));
  double __ngl __attribute__((aligned(8)));
  double __ngu __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  double __nreltol __attribute__((aligned(8)));
  double __nw = 0;
  double __nwerr = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne2 = NULL;
  __nn = n;
  __niw = iw;
  __ngl = gl;
  __ngu = gu;
  __npivmin = pivmin;
  __nreltol = reltol;
  __nw = (*env)->GetDoubleField(env, w, doubleW_val_fieldID);
  __nwerr = (*env)->GetDoubleField(env, werr, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  dlarrk_(&__nn, &__niw, &__ngl, &__ngu, __nd + offsetd, __ne2 + offsete2, &__npivmin, &__nreltol, &__nw, &__nwerr, &__ninfo);
done:
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, werr, doubleW_val_fieldID, __nwerr);
  if (!__failed) (*env)->SetDoubleField(env, w, doubleW_val_fieldID, __nw);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrr_)(int *n, double *d, double *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrrK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  if (!dlarrr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  dlarrr_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarrv_)(int *n, double *vl, double *vu, double *d, double *l, double *pivmin, int *isplit, int *m, int *dol, int *dou, double *minrgp, double *rtol1, double *rtol2, double *w, double *werr, double *wgap, int *iblock, int *indexw, double *gers, double *z, int *ldz, int *isuppz, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarrv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarrv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrvK(JNIEnv *env, UNUSED jobject obj, jint n, jdouble vl, jdouble vu, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdouble pivmin, jintArray isplit, jint offsetisplit, jint m, jint dol, jint dou, jdouble minrgp, jobject rtol1, jobject rtol2, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray gers, jint offsetgers, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlarrv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  double __npivmin __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __ndol __attribute__((aligned(8)));
  int __ndou __attribute__((aligned(8)));
  double __nminrgp __attribute__((aligned(8)));
  double __nrtol1 = 0;
  double __nrtol2 = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nl = NULL;
  int *__nisplit = NULL;
  double *__nw = NULL;
  double *__nwerr = NULL;
  double *__nwgap = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  double *__ngers = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __npivmin = pivmin;
  __nm = m;
  __ndol = dol;
  __ndou = dou;
  __nminrgp = minrgp;
  __nrtol1 = (*env)->GetDoubleField(env, rtol1, doubleW_val_fieldID);
  __nrtol2 = (*env)->GetDoubleField(env, rtol2, doubleW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlarrv_(&__nn, &__nvl, &__nvu, __nd + offsetd, __nl + offsetl, &__npivmin, __nisplit + offsetisplit, &__nm, &__ndol, &__ndou, &__nminrgp, &__nrtol1, &__nrtol2, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rtol2, doubleW_val_fieldID, __nrtol2);
  if (!__failed) (*env)->SetDoubleField(env, rtol1, doubleW_val_fieldID, __nrtol1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlartg_)(double *f, double *g, double *cs, double *sn, double *r);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlartg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlartg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlartgK(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jobject cs, jobject sn, jobject r) {
  if (!dlartg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __nf __attribute__((aligned(8)));
  double __ng __attribute__((aligned(8)));
  double __ncs = 0;
  double __nsn = 0;
  double __nr = 0;
  __nf = f;
  __ng = g;
  __ncs = (*env)->GetDoubleField(env, cs, doubleW_val_fieldID);
  __nsn = (*env)->GetDoubleField(env, sn, doubleW_val_fieldID);
  __nr = (*env)->GetDoubleField(env, r, doubleW_val_fieldID);
  dlartg_(&__nf, &__ng, &__ncs, &__nsn, &__nr);
done:
  if (!__failed) (*env)->SetDoubleField(env, r, doubleW_val_fieldID, __nr);
  if (!__failed) (*env)->SetDoubleField(env, sn, doubleW_val_fieldID, __nsn);
  if (!__failed) (*env)->SetDoubleField(env, cs, doubleW_val_fieldID, __ncs);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlartv_)(int *n, double *x, int *incx, double *y, int *incy, double *c, double *s, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlartv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlartv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlartvK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jint incc) {
  if (!dlartv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  double *__nx = NULL;
  double *__ny = NULL;
  double *__nc = NULL;
  double *__ns = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dlartv_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, __nc + offsetc, __ns + offsets, &__nincc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaruv_)(int *iseed, int *n, double *x);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaruv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaruv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaruvK(JNIEnv *env, UNUSED jobject obj, jintArray iseed, jint offsetiseed, jint n, jdoubleArray x, jint offsetx) {
  if (!dlaruv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int *__niseed = NULL;
  double *__nx = NULL;
  __nn = n;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlaruv_(__niseed + offsetiseed, &__nn, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarz_)(const char *side, int *m, int *n, int *l, double *v, int *incv, double *tau, double *c, int *Ldc, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarzK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jint l, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  if (!dlarz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  double __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nl = l;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarz_(__nside, &__nm, &__nn, &__nl, __nv + offsetv, &__nincv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarzb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, int *l, double *v, int *ldv, double *t, int *ldt, double *c, int *Ldc, double *work, int *ldwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarzb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarzb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarzbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jint l, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray t, jint offsett, jint ldt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint ldwork) {
  if (!dlarzb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldwork __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nt = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nldv = ldv;
  __nldt = ldt;
  __nLdc = Ldc;
  __nldwork = ldwork;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlarzb_(__nside, __ntrans, __ndirect, __nstorev, &__nm, &__nn, &__nk, &__nl, __nv + offsetv, &__nldv, __nt + offsett, &__nldt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlarzt_)(const char *direct, const char *storev, int *n, int *k, double *v, int *ldv, double *tau, double *t, int *ldt);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlarzt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlarzt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarztK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt) {
  if (!dlarzt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__ntau = NULL;
  double *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  dlarzt_(__ndirect, __nstorev, &__nn, &__nk, __nv + offsetv, &__nldv, __ntau + offsettau, __nt + offsett, &__nldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlas2_)(double *f, double *g, double *h, double *ssmin, double *ssmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlas2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlas2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlas2K(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jdouble h, jobject ssmin, jobject ssmax) {
  if (!dlas2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __nf __attribute__((aligned(8)));
  double __ng __attribute__((aligned(8)));
  double __nh __attribute__((aligned(8)));
  double __nssmin = 0;
  double __nssmax = 0;
  __nf = f;
  __ng = g;
  __nh = h;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  __nssmax = (*env)->GetDoubleField(env, ssmax, doubleW_val_fieldID);
  dlas2_(&__nf, &__ng, &__nh, &__nssmin, &__nssmax);
done:
  if (!__failed) (*env)->SetDoubleField(env, ssmax, doubleW_val_fieldID, __nssmax);
  if (!__failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlascl_)(const char *type, int *kl, int *ku, double *cfrom, double *cto, int *m, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlascl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlascl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasclK(JNIEnv *env, UNUSED jobject obj, jstring type, jint kl, jint ku, jdouble cfrom, jdouble cto, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dlascl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntype = NULL;
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  double __ncfrom __attribute__((aligned(8)));
  double __ncto __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__ntype = (*env)->GetStringUTFChars(env, type, NULL))) { __failed = TRUE; goto done; }
  __nkl = kl;
  __nku = ku;
  __ncfrom = cfrom;
  __ncto = cto;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dlascl_(__ntype, &__nkl, &__nku, &__ncfrom, &__ncto, &__nm, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntype) (*env)->ReleaseStringUTFChars(env, type, __ntype);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd0_)(int *n, int *sqre, double *d, double *e, double *u, int *ldu, double *vt, int *ldvt, int *smlsiz, int *iwork, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd0K(JNIEnv *env, UNUSED jobject obj, jint n, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jint smlsiz, jintArray iwork, jint offsetiwork, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasd0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  int *__niwork = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nsqre = sqre;
  __nldu = ldu;
  __nldvt = ldvt;
  __nsmlsiz = smlsiz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasd0_(&__nn, &__nsqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, &__nsmlsiz, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd1_)(int *nl, int *nr, int *sqre, double *d, double *alpha, double *beta, double *u, int *ldu, double *vt, int *ldvt, int *idxq, int *iwork, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd1K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jdoubleArray d, jint offsetd, jobject alpha, jobject beta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jintArray idxq, jint offsetidxq, jintArray iwork, jint offsetiwork, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasd1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  double __nalpha = 0;
  double __nbeta = 0;
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  int *__nidxq = NULL;
  int *__niwork = NULL;
  double *__nwork = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __nbeta = (*env)->GetDoubleField(env, beta, doubleW_val_fieldID);
  __nldu = ldu;
  __nldvt = ldvt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasd1_(&__nnl, &__nnr, &__nsqre, __nd + offsetd, &__nalpha, &__nbeta, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nidxq + offsetidxq, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, beta, doubleW_val_fieldID, __nbeta);
  if (!__failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd2_)(int *nl, int *nr, int *sqre, int *k, double *d, double *z, double *alpha, double *beta, double *u, int *ldu, double *vt, int *ldvt, double *dsigma, double *u2, int *ldu2, double *vt2, int *ldvt2, int *idxp, int *idx, int *idxc, int *idxq, int *coltyp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd2K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jobject k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdouble alpha, jdouble beta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray u2, jint offsetu2, jint ldu2, jdoubleArray vt2, jint offsetvt2, jint ldvt2, jintArray idxp, jint offsetidxp, jintArray idx, jint offsetidx, jintArray idxc, jint offsetidxc, jintArray idxq, jint offsetidxq, jintArray coltyp, jint offsetcoltyp, jobject info) {
  if (!dlasd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk = 0;
  double __nalpha __attribute__((aligned(8)));
  double __nbeta __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu2 __attribute__((aligned(8)));
  int __nldvt2 __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  double *__ndsigma = NULL;
  double *__nu2 = NULL;
  double *__nvt2 = NULL;
  int *__nidxp = NULL;
  int *__nidx = NULL;
  int *__nidxc = NULL;
  int *__nidxq = NULL;
  int *__ncoltyp = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nalpha = alpha;
  __nbeta = beta;
  __nldu = ldu;
  __nldvt = ldvt;
  __nldu2 = ldu2;
  __nldvt2 = ldvt2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) { __failed = TRUE; goto done; }
  dlasd2_(&__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nz + offsetz, &__nalpha, &__nbeta, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __ndsigma + offsetdsigma, __nu2 + offsetu2, &__nldu2, __nvt2 + offsetvt2, &__nldvt2, __nidxp + offsetidxp, __nidx + offsetidx, __nidxc + offsetidxc, __nidxq + offsetidxq, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, __failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, __failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, __failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, __failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd3_)(int *nl, int *nr, int *sqre, int *k, double *d, double *q, int *ldq, double *dsigma, double *u, int *ldu, double *u2, int *ldu2, double *vt, int *ldvt, double *vt2, int *ldvt2, int *idxc, int *ctot, double *z, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd3K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jint k, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray u2, jint offsetu2, jint ldu2, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray vt2, jint offsetvt2, jint ldvt2, jintArray idxc, jint offsetidxc, jintArray ctot, jint offsetctot, jdoubleArray z, jint offsetz, jobject info) {
  if (!dlasd3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldu2 __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldvt2 __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nq = NULL;
  double *__ndsigma = NULL;
  double *__nu = NULL;
  double *__nu2 = NULL;
  double *__nvt = NULL;
  double *__nvt2 = NULL;
  int *__nidxc = NULL;
  int *__nctot = NULL;
  double *__nz = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = k;
  __nldq = ldq;
  __nldu = ldu;
  __nldu2 = ldu2;
  __nldvt = ldvt;
  __nldvt2 = ldvt2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasd3_(&__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nq + offsetq, &__nldq, __ndsigma + offsetdsigma, __nu + offsetu, &__nldu, __nu2 + offsetu2, &__nldu2, __nvt + offsetvt, &__nldvt, __nvt2 + offsetvt2, &__nldvt2, __nidxc + offsetidxc, __nctot + offsetctot, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, __failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, __failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd4_)(int *n, int *i, double *d, double *z, double *delta, double *rho, double *sigma, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject sigma, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasd4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ni __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  double __nsigma = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__ndelta = NULL;
  double *__nwork = NULL;
  __nn = n;
  __ni = i;
  __nrho = rho;
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasd4_(&__nn, &__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__nsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd5_)(int *i, double *d, double *z, double *delta, double *rho, double *dsigma, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd5K(JNIEnv *env, UNUSED jobject obj, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dsigma, jdoubleArray work, jint offsetwork) {
  if (!dlasd5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni __attribute__((aligned(8)));
  double __nrho __attribute__((aligned(8)));
  double __ndsigma = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__ndelta = NULL;
  double *__nwork = NULL;
  __ni = i;
  __nrho = rho;
  __ndsigma = (*env)->GetDoubleField(env, dsigma, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasd5_(&__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndsigma, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, dsigma, doubleW_val_fieldID, __ndsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd6_)(int *icompq, int *nl, int *nr, int *sqre, double *d, double *vf, double *vl, double *alpha, double *beta, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *poles, double *difl, double *difr, double *z, int *k, double *c, double *s, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd6K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray vf, jint offsetvf, jdoubleArray vl, jint offsetvl, jobject alpha, jobject beta, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jdoubleArray poles, jint offsetpoles, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jobject k, jobject c, jobject s, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlasd6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  double __nalpha = 0;
  double __nbeta = 0;
  int __ngivptr = 0;
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  int __nk = 0;
  double __nc = 0;
  double __ns = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nvf = NULL;
  double *__nvl = NULL;
  int *__nidxq = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  double *__npoles = NULL;
  double *__ndifl = NULL;
  double *__ndifr = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __nbeta = (*env)->GetDoubleField(env, beta, doubleW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlasd6_(&__nicompq, &__nnl, &__nnr, &__nsqre, __nd + offsetd, __nvf + offsetvf, __nvl + offsetvl, &__nalpha, &__nbeta, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!__failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetDoubleField(env, beta, doubleW_val_fieldID, __nbeta);
  if (!__failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd7_)(int *icompq, int *nl, int *nr, int *sqre, int *k, double *d, double *z, double *zw, double *vf, double *vfw, double *vl, double *vlw, double *alpha, double *beta, double *dsigma, int *idx, int *idxp, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *c, double *s, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd7(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd7_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jobject k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray zw, jint offsetzw, jdoubleArray vf, jint offsetvf, jdoubleArray vfw, jint offsetvfw, jdoubleArray vl, jint offsetvl, jdoubleArray vlw, jint offsetvlw, jdouble alpha, jdouble beta, jdoubleArray dsigma, jint offsetdsigma, jintArray idx, jint offsetidx, jintArray idxp, jint offsetidxp, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jobject c, jobject s, jobject info) {
  if (!dlasd7_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk = 0;
  double __nalpha __attribute__((aligned(8)));
  double __nbeta __attribute__((aligned(8)));
  int __ngivptr = 0;
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  double __nc = 0;
  double __ns = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__nzw = NULL;
  double *__nvf = NULL;
  double *__nvfw = NULL;
  double *__nvl = NULL;
  double *__nvlw = NULL;
  double *__ndsigma = NULL;
  int *__nidx = NULL;
  int *__nidxp = NULL;
  int *__nidxq = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  double *__ngivnum = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nalpha = alpha;
  __nbeta = beta;
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nzw = (*env)->GetPrimitiveArrayCritical(env, zw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvfw = (*env)->GetPrimitiveArrayCritical(env, vfw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvlw = (*env)->GetPrimitiveArrayCritical(env, vlw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  dlasd7_(&__nicompq, &__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nz + offsetz, __nzw + offsetzw, __nvf + offsetvf, __nvfw + offsetvfw, __nvl + offsetvl, __nvlw + offsetvlw, &__nalpha, &__nbeta, __ndsigma + offsetdsigma, __nidx + offsetidx, __nidxp + offsetidxp, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, &__nc, &__ns, &__ninfo);
done:
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, __failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nvlw) (*env)->ReleasePrimitiveArrayCritical(env, vlw, __nvlw, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvfw) (*env)->ReleasePrimitiveArrayCritical(env, vfw, __nvfw, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nzw) (*env)->ReleasePrimitiveArrayCritical(env, zw, __nzw, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!__failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasd8_)(int *icompq, int *k, double *d, double *z, double *vf, double *vl, double *difl, double *difr, int *lddifr, double *dsigma, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasd8(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasd8_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray vf, jint offsetvf, jdoubleArray vl, jint offsetvl, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jint lddifr, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasd8_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlddifr __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__nz = NULL;
  double *__nvf = NULL;
  double *__nvl = NULL;
  double *__ndifl = NULL;
  double *__ndifr = NULL;
  double *__ndsigma = NULL;
  double *__nwork = NULL;
  __nicompq = icompq;
  __nk = k;
  __nlddifr = lddifr;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasd8_(&__nicompq, &__nk, __nd + offsetd, __nz + offsetz, __nvf + offsetvf, __nvl + offsetvl, __ndifl + offsetdifl, __ndifr + offsetdifr, &__nlddifr, __ndsigma + offsetdsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasda_)(int *icompq, int *smlsiz, int *n, int *sqre, double *d, double *e, double *u, int *ldu, double *vt, int *k, double *difl, double *difr, double *z, double *poles, int *givptr, int *givcol, int *ldgcol, int *perm, double *givnum, double *c, double *s, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasda(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasda_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jintArray k, jint offsetk, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jdoubleArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jdoubleArray givnum, jint offsetgivnum, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dlasda_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nu = NULL;
  double *__nvt = NULL;
  int *__nk = NULL;
  double *__ndifl = NULL;
  double *__ndifr = NULL;
  double *__nz = NULL;
  double *__npoles = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  int *__nperm = NULL;
  double *__ngivnum = NULL;
  double *__nc = NULL;
  double *__ns = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nsmlsiz = smlsiz;
  __nn = n;
  __nsqre = sqre;
  __nldu = ldu;
  __nldgcol = ldgcol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dlasda_(&__nicompq, &__nsmlsiz, &__nn, &__nsqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &__nldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasdq_)(const char *uplo, int *sqre, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, double *vt, int *ldvt, double *u, int *ldu, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasdq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasdq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdqK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint sqre, jint n, jint ncvt, jint nru, jint ncc, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasdq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nsqre __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nncvt __attribute__((aligned(8)));
  int __nnru __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nvt = NULL;
  double *__nu = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nsqre = sqre;
  __nn = n;
  __nncvt = ncvt;
  __nnru = nru;
  __nncc = ncc;
  __nldvt = ldvt;
  __nldu = ldu;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasdq_(__nuplo, &__nsqre, &__nn, &__nncvt, &__nnru, &__nncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &__nldvt, __nu + offsetu, &__nldu, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasdt_)(int *n, int *lvl, int *nd, int *inode, int *ndiml, int *ndimr, int *msub);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasdt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasdt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdtK(JNIEnv *env, UNUSED jobject obj, jint n, jobject lvl, jobject nd, jintArray inode, jint offsetinode, jintArray ndiml, jint offsetndiml, jintArray ndimr, jint offsetndimr, jint msub) {
  if (!dlasdt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlvl = 0;
  int __nnd = 0;
  int __nmsub __attribute__((aligned(8)));
  int *__ninode = NULL;
  int *__nndiml = NULL;
  int *__nndimr = NULL;
  __nn = n;
  __nlvl = (*env)->GetIntField(env, lvl, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nmsub = msub;
  if (!(__ninode = (*env)->GetPrimitiveArrayCritical(env, inode, NULL))) { __failed = TRUE; goto done; }
  if (!(__nndiml = (*env)->GetPrimitiveArrayCritical(env, ndiml, NULL))) { __failed = TRUE; goto done; }
  if (!(__nndimr = (*env)->GetPrimitiveArrayCritical(env, ndimr, NULL))) { __failed = TRUE; goto done; }
  dlasdt_(&__nn, &__nlvl, &__nnd, __ninode + offsetinode, __nndiml + offsetndiml, __nndimr + offsetndimr, &__nmsub);
done:
  if (__nndimr) (*env)->ReleasePrimitiveArrayCritical(env, ndimr, __nndimr, __failed ? JNI_ABORT : 0);
  if (__nndiml) (*env)->ReleasePrimitiveArrayCritical(env, ndiml, __nndiml, __failed ? JNI_ABORT : 0);
  if (__ninode) (*env)->ReleasePrimitiveArrayCritical(env, inode, __ninode, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, lvl, intW_val_fieldID, __nlvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaset_)(const char *uplo, int *m, int *n, double *alpha, double *beta, double *a, int *lda);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaset(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaset_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasetK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jdouble alpha, jdouble beta, jdoubleArray a, jint offseta, jint lda) {
  if (!dlaset_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  double __nalpha __attribute__((aligned(8)));
  double __nbeta __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nalpha = alpha;
  __nbeta = beta;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dlaset_(__nuplo, &__nm, &__nn, &__nalpha, &__nbeta, __na + offseta, &__nlda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq1_)(int *n, double *d, double *e, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dlasq1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nwork = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlasq1_(&__nn, __nd + offsetd, __ne + offsete, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq2_)(int *n, double *z, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray z, jint offsetz, jobject info) {
  if (!dlasq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nz = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasq2_(&__nn, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq3_)(int *i0, int *n0, double *z, int *pp, double *dmin, double *sigma, double *desig, double *qmax, int *nfail, int *iter, int *ndiv, int *ieee);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq3K(JNIEnv *env, UNUSED jobject obj, jint i0, jobject n0, jdoubleArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee) {
  if (!dlasq3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 = 0;
  int __npp __attribute__((aligned(8)));
  double __ndmin = 0;
  double __nsigma = 0;
  double __ndesig = 0;
  double __nqmax = 0;
  int __nnfail = 0;
  int __niter = 0;
  int __nndiv = 0;
  int __nieee __attribute__((aligned(8)));
  double *__nz = NULL;
  __ni0 = i0;
  __nn0 = (*env)->GetIntField(env, n0, intW_val_fieldID);
  __npp = pp;
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ndesig = (*env)->GetDoubleField(env, desig, doubleW_val_fieldID);
  __nqmax = (*env)->GetDoubleField(env, qmax, doubleW_val_fieldID);
  __nnfail = (*env)->GetIntField(env, nfail, intW_val_fieldID);
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __nndiv = (*env)->GetIntField(env, ndiv, intW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasq3_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ndmin, &__nsigma, &__ndesig, &__nqmax, &__nnfail, &__niter, &__nndiv, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, ndiv, intW_val_fieldID, __nndiv);
  if (!__failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (!__failed) (*env)->SetIntField(env, nfail, intW_val_fieldID, __nnfail);
  if (!__failed) (*env)->SetDoubleField(env, qmax, doubleW_val_fieldID, __nqmax);
  if (!__failed) (*env)->SetDoubleField(env, desig, doubleW_val_fieldID, __ndesig);
  if (!__failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (!__failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (!__failed) (*env)->SetIntField(env, n0, intW_val_fieldID, __nn0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq4_)(int *i0, int *n0, double *z, int *pp, int *n0in, double *dmin, double *dmin1, double *dmin2, double *dn, double *dn1, double *dn2, double *tau, int *ttype);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq4K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jint n0in, jdouble dmin, jdouble dmin1, jdouble dmin2, jdouble dn, jdouble dn1, jdouble dn2, jobject tau, jobject ttype) {
  if (!dlasq4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  int __nn0in __attribute__((aligned(8)));
  double __ndmin __attribute__((aligned(8)));
  double __ndmin1 __attribute__((aligned(8)));
  double __ndmin2 __attribute__((aligned(8)));
  double __ndn __attribute__((aligned(8)));
  double __ndn1 __attribute__((aligned(8)));
  double __ndn2 __attribute__((aligned(8)));
  double __ntau = 0;
  int __nttype = 0;
  double *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __nn0in = n0in;
  __ndmin = dmin;
  __ndmin1 = dmin1;
  __ndmin2 = dmin2;
  __ndn = dn;
  __ndn1 = dn1;
  __ndn2 = dn2;
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  __nttype = (*env)->GetIntField(env, ttype, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasq4_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__nn0in, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndn1, &__ndn2, &__ntau, &__nttype);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, ttype, intW_val_fieldID, __nttype);
  if (!__failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq5_)(int *i0, int *n0, double *z, int *pp, double *tau, double *dmin, double *dmin1, double *dmin2, double *dn, double *dnm1, double *dnm2, int *ieee);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq5K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jdouble tau, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2, jboolean ieee) {
  if (!dlasq5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  double __ntau __attribute__((aligned(8)));
  double __ndmin = 0;
  double __ndmin1 = 0;
  double __ndmin2 = 0;
  double __ndn = 0;
  double __ndnm1 = 0;
  double __ndnm2 = 0;
  int __nieee __attribute__((aligned(8)));
  double *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __ntau = tau;
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __ndmin1 = (*env)->GetDoubleField(env, dmin1, doubleW_val_fieldID);
  __ndmin2 = (*env)->GetDoubleField(env, dmin2, doubleW_val_fieldID);
  __ndn = (*env)->GetDoubleField(env, dn, doubleW_val_fieldID);
  __ndnm1 = (*env)->GetDoubleField(env, dnm1, doubleW_val_fieldID);
  __ndnm2 = (*env)->GetDoubleField(env, dnm2, doubleW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasq5_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ntau, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, dnm2, doubleW_val_fieldID, __ndnm2);
  if (!__failed) (*env)->SetDoubleField(env, dnm1, doubleW_val_fieldID, __ndnm1);
  if (!__failed) (*env)->SetDoubleField(env, dn, doubleW_val_fieldID, __ndn);
  if (!__failed) (*env)->SetDoubleField(env, dmin2, doubleW_val_fieldID, __ndmin2);
  if (!__failed) (*env)->SetDoubleField(env, dmin1, doubleW_val_fieldID, __ndmin1);
  if (!__failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasq6_)(int *i0, int *n0, double *z, int *pp, double *dmin, double *dmin1, double *dmin2, double *dn, double *dnm1, double *dnm2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasq6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasq6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq6K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2) {
  if (!dlasq6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  double __ndmin = 0;
  double __ndmin1 = 0;
  double __ndmin2 = 0;
  double __ndn = 0;
  double __ndnm1 = 0;
  double __ndnm2 = 0;
  double *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __ndmin1 = (*env)->GetDoubleField(env, dmin1, doubleW_val_fieldID);
  __ndmin2 = (*env)->GetDoubleField(env, dmin2, doubleW_val_fieldID);
  __ndn = (*env)->GetDoubleField(env, dn, doubleW_val_fieldID);
  __ndnm1 = (*env)->GetDoubleField(env, dnm1, doubleW_val_fieldID);
  __ndnm2 = (*env)->GetDoubleField(env, dnm2, doubleW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  dlasq6_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, dnm2, doubleW_val_fieldID, __ndnm2);
  if (!__failed) (*env)->SetDoubleField(env, dnm1, doubleW_val_fieldID, __ndnm1);
  if (!__failed) (*env)->SetDoubleField(env, dn, doubleW_val_fieldID, __ndn);
  if (!__failed) (*env)->SetDoubleField(env, dmin2, doubleW_val_fieldID, __ndmin2);
  if (!__failed) (*env)->SetDoubleField(env, dmin1, doubleW_val_fieldID, __ndmin1);
  if (!__failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasr_)(const char *side, const char *pivot, const char *direct, int *m, int *n, double *c, double *s, double *a, int *lda);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring pivot, jstring direct, jint m, jint n, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray a, jint offseta, jint lda) {
  if (!dlasr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__npivot = NULL;
  const char *__ndirect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__nc = NULL;
  double *__ns = NULL;
  double *__na = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__npivot = (*env)->GetStringUTFChars(env, pivot, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dlasr_(__nside, __npivot, __ndirect, &__nm, &__nn, __nc + offsetc, __ns + offsets, __na + offseta, &__nlda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__npivot) (*env)->ReleaseStringUTFChars(env, pivot, __npivot);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasrt_)(const char *id, int *n, double *d, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasrt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasrt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasrtK(JNIEnv *env, UNUSED jobject obj, jstring id, jint n, jdoubleArray d, jint offsetd, jobject info) {
  if (!dlasrt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nid = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  if (!(__nid = (*env)->GetStringUTFChars(env, id, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  dlasrt_(__nid, &__nn, __nd + offsetd, &__ninfo);
done:
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nid) (*env)->ReleaseStringUTFChars(env, id, __nid);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlassq_)(int *n, double *x, int *incx, double *scale, double *sumsq);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlassq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlassq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlassqK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jobject scale, jobject sumsq) {
  if (!dlassq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  double __nscale = 0;
  double __nsumsq = 0;
  double *__nx = NULL;
  __nn = n;
  __nincx = incx;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nsumsq = (*env)->GetDoubleField(env, sumsq, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlassq_(&__nn, __nx + offsetx, &__nincx, &__nscale, &__nsumsq);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, sumsq, doubleW_val_fieldID, __nsumsq);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasv2_)(double *f, double *g, double *h, double *ssmin, double *ssmax, double *snr, double *csr, double *snl, double *csl);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasv2K(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jdouble h, jobject ssmin, jobject ssmax, jobject snr, jobject csr, jobject snl, jobject csl) {
  if (!dlasv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  double __nf __attribute__((aligned(8)));
  double __ng __attribute__((aligned(8)));
  double __nh __attribute__((aligned(8)));
  double __nssmin = 0;
  double __nssmax = 0;
  double __nsnr = 0;
  double __ncsr = 0;
  double __nsnl = 0;
  double __ncsl = 0;
  __nf = f;
  __ng = g;
  __nh = h;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  __nssmax = (*env)->GetDoubleField(env, ssmax, doubleW_val_fieldID);
  __nsnr = (*env)->GetDoubleField(env, snr, doubleW_val_fieldID);
  __ncsr = (*env)->GetDoubleField(env, csr, doubleW_val_fieldID);
  __nsnl = (*env)->GetDoubleField(env, snl, doubleW_val_fieldID);
  __ncsl = (*env)->GetDoubleField(env, csl, doubleW_val_fieldID);
  dlasv2_(&__nf, &__ng, &__nh, &__nssmin, &__nssmax, &__nsnr, &__ncsr, &__nsnl, &__ncsl);
done:
  if (!__failed) (*env)->SetDoubleField(env, csl, doubleW_val_fieldID, __ncsl);
  if (!__failed) (*env)->SetDoubleField(env, snl, doubleW_val_fieldID, __nsnl);
  if (!__failed) (*env)->SetDoubleField(env, csr, doubleW_val_fieldID, __ncsr);
  if (!__failed) (*env)->SetDoubleField(env, snr, doubleW_val_fieldID, __nsnr);
  if (!__failed) (*env)->SetDoubleField(env, ssmax, doubleW_val_fieldID, __nssmax);
  if (!__failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlaswp_)(int *n, double *a, int *lda, int *k1, int *k2, int *ipiv, int *incx);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlaswp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlaswp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaswpK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jint k1, jint k2, jintArray ipiv, jint offsetipiv, jint incx) {
  if (!dlaswp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nk1 __attribute__((aligned(8)));
  int __nk2 __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  double *__na = NULL;
  int *__nipiv = NULL;
  __nn = n;
  __nlda = lda;
  __nk1 = k1;
  __nk2 = k2;
  __nincx = incx;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dlaswp_(&__nn, __na + offseta, &__nlda, &__nk1, &__nk2, __nipiv + offsetipiv, &__nincx);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasy2_)(int *ltranl, int *ltranr, int *isgn, int *n1, int *n2, double *tl, int *ldtl, double *tr, int *ldtr, double *b, int *ldb, double *scale, double *x, int *ldx, double *xnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasy2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasy2K(JNIEnv *env, UNUSED jobject obj, jboolean ltranl, jboolean ltranr, jint isgn, jint n1, jint n2, jdoubleArray tl, jint offsettl, jint ldtl, jdoubleArray tr, jint offsettr, jint ldtr, jdoubleArray b, jint offsetb, jint ldb, jobject scale, jdoubleArray x, jint offsetx, jint ldx, jobject xnorm, jobject info) {
  if (!dlasy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltranl __attribute__((aligned(8)));
  int __nltranr __attribute__((aligned(8)));
  int __nisgn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nldtl __attribute__((aligned(8)));
  int __nldtr __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nscale = 0;
  int __nldx __attribute__((aligned(8)));
  double __nxnorm = 0;
  int __ninfo = 0;
  double *__ntl = NULL;
  double *__ntr = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  __nltranl = ltranl;
  __nltranr = ltranr;
  __nisgn = isgn;
  __nn1 = n1;
  __nn2 = n2;
  __nldtl = ldtl;
  __nldtr = ldtr;
  __nldb = ldb;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nldx = ldx;
  __nxnorm = (*env)->GetDoubleField(env, xnorm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ntl = (*env)->GetPrimitiveArrayCritical(env, tl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntr = (*env)->GetPrimitiveArrayCritical(env, tr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  dlasy2_(&__nltranl, &__nltranr, &__nisgn, &__nn1, &__nn2, __ntl + offsettl, &__nldtl, __ntr + offsettr, &__nldtr, __nb + offsetb, &__nldb, &__nscale, __nx + offsetx, &__nldx, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntr) (*env)->ReleasePrimitiveArrayCritical(env, tr, __ntr, __failed ? JNI_ABORT : 0);
  if (__ntl) (*env)->ReleasePrimitiveArrayCritical(env, tl, __ntl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, xnorm, doubleW_val_fieldID, __nxnorm);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlasyf_)(const char *uplo, int *n, int *nb, int *kb, double *a, int *lda, int *ipiv, double *w, int *ldw, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlasyf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlasyf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasyfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jobject kb, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray w, jint offsetw, jint ldw, jobject info) {
  if (!dlasyf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nkb = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldw __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnb = nb;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __nlda = lda;
  __nldw = ldw;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  dlasyf_(__nuplo, &__nn, &__nnb, &__nkb, __na + offseta, &__nlda, __nipiv + offsetipiv, __nw + offsetw, &__nldw, &__ninfo);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatbs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, int *kd, double *ab, int *ldab, double *x, double *scale, double *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatbs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatbs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatbsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  if (!dlatbs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nscale = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nx = NULL;
  double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  dlatbs_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, &__nkd, __nab + offsetab, &__nldab, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatdf_)(int *ijob, int *n, double *z, int *ldz, double *rhs, double *rdsum, double *rdscal, int *ipiv, int *jpiv);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatdf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatdf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatdfK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint n, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray rhs, jint offsetrhs, jobject rdsum, jobject rdscal, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv) {
  if (!dlatdf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  double __nrdsum = 0;
  double __nrdscal = 0;
  double *__nz = NULL;
  double *__nrhs = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nijob = ijob;
  __nn = n;
  __nldz = ldz;
  __nrdsum = (*env)->GetDoubleField(env, rdsum, doubleW_val_fieldID);
  __nrdscal = (*env)->GetDoubleField(env, rdscal, doubleW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  dlatdf_(&__nijob, &__nn, __nz + offsetz, &__nldz, __nrhs + offsetrhs, &__nrdsum, &__nrdscal, __nipiv + offsetipiv, __njpiv + offsetjpiv);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetDoubleField(env, rdscal, doubleW_val_fieldID, __nrdscal);
  if (!__failed) (*env)->SetDoubleField(env, rdsum, doubleW_val_fieldID, __nrdsum);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatps_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, double *ap, double *x, double *scale, double *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatps(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatps_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatpsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jdoubleArray ap, jint offsetap, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  if (!dlatps_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  double __nscale = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nx = NULL;
  double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  dlatps_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, __nap + offsetap, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatrd_)(const char *uplo, int *n, int *nb, double *a, int *lda, double *e, double *tau, double *w, int *ldw);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jdoubleArray w, jint offsetw, jint ldw) {
  if (!dlatrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldw __attribute__((aligned(8)));
  double *__na = NULL;
  double *__ne = NULL;
  double *__ntau = NULL;
  double *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnb = nb;
  __nlda = lda;
  __nldw = ldw;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  dlatrd_(__nuplo, &__nn, &__nnb, __na + offseta, &__nlda, __ne + offsete, __ntau + offsettau, __nw + offsetw, &__nldw);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatrs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, double *a, int *lda, double *x, double *scale, double *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  if (!dlatrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nscale = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nx = NULL;
  double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  dlatrs_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, __na + offseta, &__nlda, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatrz_)(int *m, int *n, int *l, double *a, int *lda, double *tau, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatrz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatrz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrzK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork) {
  if (!dlatrz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nl = l;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlatrz_(&__nm, &__nn, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlatzm_)(const char *side, int *m, int *n, double *v, int *incv, double *tau, double *c1, double *c2, int *Ldc, double *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlatzm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlatzm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatzmK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c1, jint offsetc1, jdoubleArray c2, jint offsetc2, jint Ldc, jdoubleArray work, jint offsetwork) {
  if (!dlatzm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  double __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  double *__nv = NULL;
  double *__nc1 = NULL;
  double *__nc2 = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc1 = (*env)->GetPrimitiveArrayCritical(env, c1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc2 = (*env)->GetPrimitiveArrayCritical(env, c2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dlatzm_(__nside, &__nm, &__nn, __nv + offsetv, &__nincv, &__ntau, __nc1 + offsetc1, __nc2 + offsetc2, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc2) (*env)->ReleasePrimitiveArrayCritical(env, c2, __nc2, __failed ? JNI_ABORT : 0);
  if (__nc1) (*env)->ReleasePrimitiveArrayCritical(env, c1, __nc1, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlauu2_)(const char *uplo, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlauu2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlauu2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlauu2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dlauu2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dlauu2_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dlauum_)(const char *uplo, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlauum(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlauum_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlauumK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dlauum_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dlauum_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*dlazq3_)(int *i0, int *n0, double *z, int *pp, double *dmin, double *sigma, double *desig, double *qmax, int *nfail, int *iter, int *ndiv, int *ieee, int *ttype, double *dmin1, double *dmin2, double *dn, double *dn1, double *dn2, double *tau);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlazq3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlazq3K(JNIEnv *env, UNUSED jobject obj, UNUSED jint i0, UNUSED jobject n0, UNUSED jdoubleArray z, UNUSED jint offsetz, UNUSED jint pp, UNUSED jobject dmin, UNUSED jobject sigma, UNUSED jobject desig, UNUSED jobject qmax, UNUSED jobject nfail, UNUSED jobject iter, UNUSED jobject ndiv, UNUSED jboolean ieee, UNUSED jobject ttype, UNUSED jobject dmin1, UNUSED jobject dmin2, UNUSED jobject dn, UNUSED jobject dn1, UNUSED jobject dn2, UNUSED jobject tau) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dlazq4_)(int *i0, int *n0, double *z, int *pp, int *n0in, double *dmin, double *dmin1, double *dmin2, double *dn, double *dn1, double *dn2, double *tau, int *ttype, double *g);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlazq4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlazq4K(JNIEnv *env, UNUSED jobject obj, UNUSED jint i0, UNUSED jint n0, UNUSED jdoubleArray z, UNUSED jint offsetz, UNUSED jint pp, UNUSED jint n0in, UNUSED jdouble dmin, UNUSED jdouble dmin1, UNUSED jdouble dmin2, UNUSED jdouble dn, UNUSED jdouble dn1, UNUSED jdouble dn2, UNUSED jobject tau, UNUSED jobject ttype, UNUSED jobject g) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*dopgtr_)(const char *uplo, int *n, double *ap, double *tau, double *q, int *ldq, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dopgtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dopgtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dopgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray tau, jint offsettau, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dopgtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__ntau = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dopgtr_(__nuplo, &__nn, __nap + offsetap, __ntau + offsettau, __nq + offsetq, &__nldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dopmtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, double *ap, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dopmtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dopmtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dopmtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jdoubleArray ap, jint offsetap, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dopmtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dopmtr_(__nside, __nuplo, __ntrans, &__nm, &__nn, __nap + offsetap, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorg2l_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorg2l(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorg2l_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorg2lK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorg2l_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorg2l_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorg2r_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorg2r(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorg2r_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorg2rK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorg2r_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorg2r_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgbr_)(const char *vect, int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgbr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgbr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorgbr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgbr_(__nvect, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorghr_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorghr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorghr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorghrK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorghr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorghr_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgl2_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgl2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgl2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgl2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorgl2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgl2_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorglq_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorglq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorglq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorglqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorglq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorglq_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgql_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgql(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgql_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgqlK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorgql_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgql_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgqr_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgqrK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorgqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgqr_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgr2_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorgr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgr2_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgrq_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgrq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgrq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgrqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorgrq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgrq_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorgtr_)(const char *uplo, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorgtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorgtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dorgtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorgtr_(__nuplo, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorm2l_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorm2l(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorm2l_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorm2lK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorm2l_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorm2l_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorm2r_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorm2r(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorm2r_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorm2rK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorm2r_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorm2r_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormbr_)(const char *vect, const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormbr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormbr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormbr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormbr_(__nvect, __nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormhr_)(const char *side, const char *trans, int *m, int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormhr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormhr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormhrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormhr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormhr_(__nside, __ntrans, &__nm, &__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dorml2_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dorml2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dorml2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorml2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dorml2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dorml2_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormlq_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormlq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormlq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormlqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormlq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormlq_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormql_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormql(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormql_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormqlK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormql_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormql_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormqr_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormqrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormqr_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormr2_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormr2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dormr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormr2_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormr3_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormr3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormr3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormr3K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dormr3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormr3_(__nside, __ntrans, &__nm, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormrq_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormrq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormrq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormrqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormrq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormrq_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormrz_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormrz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormrz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormrzK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormrz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormrz_(__nside, __ntrans, &__nm, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dormtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dormtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dormtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dormtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nc = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dormtr_(__nside, __nuplo, __ntrans, &__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbcon_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dpbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dpbcon_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbequ_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *s, double *scond, double *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!dpbequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nscond = 0;
  double __namax = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dpbequ_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!__failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbrfs_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dpbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nafb = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dpbrfs_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbstf_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbstf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbstf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbstfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  if (!dpbstf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  dpbstf_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbsv_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dpbsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dpbsv_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbsvx_)(const char *fact, const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dpbsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nafb = NULL;
  double *__ns = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dpbsvx_(__nfact, __nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbtf2_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbtf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbtf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  if (!dpbtf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  dpbtf2_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbtrf_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbtrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbtrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  if (!dpbtrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  dpbtrf_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpbtrs_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dpbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dpbtrs_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpocon_)(const char *uplo, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpocon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpocon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpoconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dpocon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dpocon_(__nuplo, &__nn, __na + offseta, &__nlda, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpoequ_)(int *n, double *a, int *lda, double *s, double *scond, double *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpoequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpoequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpoequK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!dpoequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nscond = 0;
  double __namax = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__ns = NULL;
  __nn = n;
  __nlda = lda;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dpoequ_(&__nn, __na + offseta, &__nlda, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!__failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dporfs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dporfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dporfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dporfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dporfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dporfs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dposv_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dposv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dposv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dposvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dposv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dposv_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dposvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dposvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dposvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dposvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dposvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  double *__ns = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dposvx_(__nfact, __nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpotf2_)(const char *uplo, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpotf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpotf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dpotf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dpotf2_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpotrf_)(const char *uplo, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpotrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpotrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dpotrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dpotrf_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpotri_)(const char *uplo, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpotri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpotri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dpotri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dpotri_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpotrs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpotrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpotrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dpotrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dpotrs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dppcon_)(const char *uplo, int *n, double *ap, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dppcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dppcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dppcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dppcon_(__nuplo, &__nn, __nap + offsetap, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dppequ_)(const char *uplo, int *n, double *ap, double *s, double *scond, double *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dppequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dppequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!dppequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nscond = 0;
  double __namax = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  dppequ_(__nuplo, &__nn, __nap + offsetap, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!__failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpprfs_)(const char *uplo, int *n, int *nrhs, double *ap, double *afp, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dpprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nafp = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dpprfs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dppsv_)(const char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dppsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dppsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dppsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dppsv_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dppsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *ap, double *afp, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dppsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dppsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dppsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nafp = NULL;
  double *__ns = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dppsvx_(__nfact, __nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpptrf_)(const char *uplo, int *n, double *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpptrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpptrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  if (!dpptrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  dpptrf_(__nuplo, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpptri_)(const char *uplo, int *n, double *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  if (!dpptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  dpptri_(__nuplo, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpptrs_)(const char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dpptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dpptrs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dptcon_)(int *n, double *d, double *e, double *anorm, double *rcond, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dptcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dptcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptconK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dptcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dptcon_(&__nn, __nd + offsetd, __ne + offsete, &__nanorm, &__nrcond, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpteqr_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpteqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpteqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dpteqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dpteqr_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dptrfs_)(int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dptrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dptrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptrfsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray df, jint offsetdf, jdoubleArray ef, jint offsetef, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dptrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ndf = NULL;
  double *__nef = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dptrfs_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dptsv_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dptsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dptsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dptsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dptsv_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dptsvx_)(const char *fact, int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dptsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dptsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray df, jint offsetdf, jdoubleArray ef, jint offsetef, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dptsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ndf = NULL;
  double *__nef = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dptsvx_(__nfact, &__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpttrf_)(int *n, double *d, double *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpttrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpttrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  if (!dpttrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  dpttrf_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dpttrs_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dpttrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dpttrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpttrsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dpttrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dpttrs_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dptts2_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dptts2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dptts2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptts2K(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb) {
  if (!dptts2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dptts2_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*drscl_)(int *n, double *sa, double *sx, int *incx);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_drscl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return drscl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_drsclK(JNIEnv *env, UNUSED jobject obj, jint n, jdouble sa, jdoubleArray sx, jint offsetsx, jint incx) {
  if (!drscl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  double __nsa __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  double *__nsx = NULL;
  __nn = n;
  __nsa = sa;
  __nincx = incx;
  if (!(__nsx = (*env)->GetPrimitiveArrayCritical(env, sx, NULL))) { __failed = TRUE; goto done; }
  drscl_(&__nn, &__nsa, __nsx + offsetsx, &__nincx);
done:
  if (__nsx) (*env)->ReleasePrimitiveArrayCritical(env, sx, __nsx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbev_)(const char *jobz, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsbev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsbev_(__njobz, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbevd_)(const char *jobz, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dsbevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsbevd_(__njobz, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbevx_)(const char *jobz, const char *range, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray q, jint offsetq, jint ldq, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dsbevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nq = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldq = ldq;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dsbevx_(__njobz, __nrange, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nq + offsetq, &__nldq, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbgst_)(const char *vect, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *x, int *ldx, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbgst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbgst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgstK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsbgst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nbb = NULL;
  double *__nx = NULL;
  double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsbgst_(__nvect, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nx + offsetx, &__nldx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbgv_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *w, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbgv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbgv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsbgv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nbb = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsbgv_(__njobz, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbgvd_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbgvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbgvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dsbgvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nbb = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsbgvd_(__njobz, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbgvx_)(const char *jobz, const char *range, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbgvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbgvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray q, jint offsetq, jint ldq, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dsbgvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nbb = NULL;
  double *__nq = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldq = ldq;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dsbgvx_(__njobz, __nrange, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nq + offsetq, &__nldq, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsbtrd_)(const char *vect, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsbtrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsbtrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbtrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsbtrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsbtrd_(__nvect, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsgesv_)(int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *work, float *swork, int *iter, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsgesv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsgesv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray work, jint offsetwork, jfloatArray swork, jint offsetswork, jobject iter, jobject info) {
  if (!dsgesv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __niter = 0;
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nwork = NULL;
  float *__nswork = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nldx = ldx;
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__nswork = (*env)->GetPrimitiveArrayCritical(env, swork, NULL))) { __failed = TRUE; goto done; }
  dsgesv_(&__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nwork + offsetwork, __nswork + offsetswork, &__niter, &__ninfo);
done:
  if (__nswork) (*env)->ReleasePrimitiveArrayCritical(env, swork, __nswork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspcon_)(const char *uplo, int *n, double *ap, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dspcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dspcon_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspev_)(const char *jobz, const char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dspev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dspev_(__njobz, __nuplo, &__nn, __nap + offsetap, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspevd_)(const char *jobz, const char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dspevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dspevd_(__njobz, __nuplo, &__nn, __nap + offsetap, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspevx_)(const char *jobz, const char *range, const char *uplo, int *n, double *ap, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dspevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dspevx_(__njobz, __nrange, __nuplo, &__nn, __nap + offsetap, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspgst_)(int *itype, const char *uplo, int *n, double *ap, double *bp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspgst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspgst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jobject info) {
  if (!dspgst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nbp = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  dspgst_(&__nitype, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, &__ninfo);
done:
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspgv_)(int *itype, const char *jobz, const char *uplo, int *n, double *ap, double *bp, double *w, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspgv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspgv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dspgv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nbp = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dspgv_(&__nitype, __njobz, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspgvd_)(int *itype, const char *jobz, const char *uplo, int *n, double *ap, double *bp, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspgvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspgvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dspgvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nbp = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dspgvd_(&__nitype, __njobz, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspgvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, double *ap, double *bp, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspgvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspgvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dspgvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nbp = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dspgvx_(&__nitype, __njobz, __nrange, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsprfs_)(const char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dsprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nafp = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsprfs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspsv_)(const char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dspsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dspsv_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dspsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dspsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dspsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dspsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nafp = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dspsvx_(__nfact, __nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsptrd_)(const char *uplo, int *n, double *ap, double *d, double *e, double *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsptrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsptrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jobject info) {
  if (!dsptrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  dsptrd_(__nuplo, &__nn, __nap + offsetap, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsptrf_)(const char *uplo, int *n, double *ap, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsptrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsptrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dsptrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dsptrf_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsptri_)(const char *uplo, int *n, double *ap, int *ipiv, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsptri_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsptrs_)(const char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dsptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dsptrs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstebz_)(const char *range, const char *order, int *n, double *vl, double *vu, int *il, int *iu, double *abstol, double *d, double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstebz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstebz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstebzK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject m, jobject nsplit, jdoubleArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dstebz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  const char *__norder = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nnsplit = 0;
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  int *__niblock = NULL;
  int *__nisplit = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstebz_(__nrange, __norder, &__nn, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, __nd + offsetd, __ne + offsete, &__nm, &__nnsplit, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstedc_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstedc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstedc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstedcK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dstedc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstedc_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstegr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstegr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstegr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstegrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dstegr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstegr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstein_)(int *n, double *d, double *e, int *m, double *w, int *iblock, int *isplit, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsteinK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jint m, jdoubleArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dstein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  int *__niblock = NULL;
  int *__nisplit = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nn = n;
  __nm = m;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dstein_(&__nn, __nd + offsetd, __ne + offsete, &__nm, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstemr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, int *m, double *w, double *z, int *ldz, int *nzc, int *isuppz, int *tryrac, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstemr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstemr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstemrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jint nzc, jintArray isuppz, jint offsetisuppz, jobject tryrac, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dstemr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nnzc __attribute__((aligned(8)));
  int __ntryrac = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nnzc = nzc;
  __ntryrac = (*env)->GetBooleanField(env, tryrac, booleanW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstemr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, &__nnzc, __nisuppz + offsetisuppz, &__ntryrac, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetBooleanField(env, tryrac, booleanW_val_fieldID, __ntryrac);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsteqr_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsteqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsteqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsteqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsteqr_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsterf_)(int *n, double *d, double *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsterf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsterf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsterfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  if (!dsterf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  dsterf_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstev_)(const char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dstev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dstev_(__njobz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstevd_)(const char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dstevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstevd_(__njobz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstevr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstevr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstevr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dstevr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dstevr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dstevx_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dstevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dstevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dstevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dstevx_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsycon_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsycon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsycon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dsycon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nanorm __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsycon_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsyev_)(const char *jobz, const char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsyev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsyev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dsyev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nw = NULL;
  double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsyev_(__njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nw + offsetw, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsyevd_)(const char *jobz, const char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsyevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsyevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dsyevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nw = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsyevd_(__njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nw + offsetw, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsyevr_)(const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsyevr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsyevr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dsyevr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  int *__nisuppz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsyevr_(__njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsyevx_)(const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsyevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsyevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dsyevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dsyevx_(__njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsygs2_)(int *itype, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsygs2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsygs2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygs2K(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dsygs2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dsygs2_(&__nitype, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsygst_)(int *itype, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsygst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsygst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dsygst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dsygst_(&__nitype, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsygv_)(int *itype, const char *jobz, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *w, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsygv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsygv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dsygv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nw = NULL;
  double *__nwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsygv_(&__nitype, __njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nw + offsetw, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsygvd_)(int *itype, const char *jobz, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *w, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsygvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsygvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dsygvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nw = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsygvd_(&__nitype, __njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nw + offsetw, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsygvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsygvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsygvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!dsygvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __nvl __attribute__((aligned(8)));
  double __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  double __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nw = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  dsygvx_(&__nitype, __njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsyrfs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsyrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsyrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dsyrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsyrfs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsysv_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsysv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsysv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsysvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dsysv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsysv_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsysvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsysvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsysvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsysvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dsysvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  double __nrcond = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__naf = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dsysvx_(__nfact, __nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytd2_)(const char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytd2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jobject info) {
  if (!dsytd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  dsytd2_(__nuplo, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytf2_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!dsytf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  dsytf2_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytrd_)(const char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dsytrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsytrd_(__nuplo, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytrf_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dsytrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsytrf_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytri_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dsytri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dsytri_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dsytrs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsytrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsytrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dsytrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  int *__nipiv = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dsytrs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtbcon_)(const char *norm, const char *uplo, const char *diag, int *n, int *kd, double *ab, int *ldab, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtbcon_(__nnorm, __nuplo, __ndiag, &__nn, &__nkd, __nab + offsetab, &__nldab, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtbrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtbrfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtbtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dtbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nab = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dtbtrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgevc_)(const char *side, const char *howmny, int *select, int *n, double *s, int *lds, double *p, int *ldp, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgevc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgevc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray s, jint offsets, jint lds, jdoubleArray p, jint offsetp, jint ldp, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dtgevc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlds __attribute__((aligned(8)));
  int __nldp __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__ns = NULL;
  double *__np = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlds = lds;
  __nldp = ldp;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__np = (*env)->GetPrimitiveArrayCritical(env, p, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtgevc_(__nside, __nhowmny, __nselect + offsetselect, &__nn, __ns + offsets, &__nlds, __np + offsetp, &__nldp, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__np) (*env)->ReleasePrimitiveArrayCritical(env, p, __np, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgex2_)(int *wantq, int *wantz, int *n, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *j1, int *n1, int *n2, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgex2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgex2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgex2K(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jint j1, jint n1, jint n2, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dtgex2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nj1 __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nq = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nj1 = j1;
  __nn1 = n1;
  __nn2 = n2;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtgex2_(&__nwantq, &__nwantz, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nj1, &__nn1, &__nn2, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgexc_)(int *wantq, int *wantz, int *n, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *ifst, int *ilst, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject ifst, jobject ilst, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dtgexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nifst = 0;
  int __nilst = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nq = NULL;
  double *__nz = NULL;
  double *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtgexc_(&__nwantq, &__nwantz, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nifst, &__nilst, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!__failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgsen_)(int *ijob, int *wantq, int *wantz, int *select, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *q, int *ldq, double *z, int *ldz, int *m, double *pl, double *pr, double *dif, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgsen(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgsen_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsenK(JNIEnv *env, UNUSED jobject obj, jint ijob, jboolean wantq, jboolean wantz, jbooleanArray select, jint offsetselect, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject m, jobject pl, jobject pr, jdoubleArray dif, jint offsetdif, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dtgsen_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nm = 0;
  double __npl = 0;
  double __npr = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalphar = NULL;
  double *__nalphai = NULL;
  double *__nbeta = NULL;
  double *__nq = NULL;
  double *__nz = NULL;
  double *__ndif = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  __nijob = ijob;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npl = (*env)->GetDoubleField(env, pl, doubleW_val_fieldID);
  __npr = (*env)->GetDoubleField(env, pr, doubleW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtgsen_(&__nijob, &__nwantq, &__nwantz, __nselect + offsetselect, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nm, &__npl, &__npr, __ndif + offsetdif, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, pr, doubleW_val_fieldID, __npr);
  if (!__failed) (*env)->SetDoubleField(env, pl, doubleW_val_fieldID, __npl);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgsja_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *ncycle, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgsja(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgsja_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsjaK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble tola, jdouble tolb, jdoubleArray alpha, jint offsetalpha, jdoubleArray beta, jint offsetbeta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject ncycle, jobject info) {
  if (!dtgsja_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  double __ntola __attribute__((aligned(8)));
  double __ntolb __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nncycle = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nalpha = NULL;
  double *__nbeta = NULL;
  double *__nu = NULL;
  double *__nv = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __np = p;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nldb = ldb;
  __ntola = tola;
  __ntolb = tolb;
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __nncycle = (*env)->GetIntField(env, ncycle, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtgsja_(__njobu, __njobv, __njobq, &__nm, &__np, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ntola, &__ntolb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __nwork + offsetwork, &__nncycle, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ncycle, intW_val_fieldID, __nncycle);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgsna_)(const char *job, const char *howmny, int *select, int *n, double *a, int *lda, double *b, int *ldb, double *vl, int *ldvl, double *vr, int *ldvr, double *s, double *dif, int *mm, int *m, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgsna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgsna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray s, jint offsets, jdoubleArray dif, jint offsetdif, jint mm, jobject m, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtgsna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__ns = NULL;
  double *__ndif = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtgsna_(__njob, __nhowmny, __nselect + offsetselect, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __ns + offsets, __ndif + offsetdif, &__nmm, &__nm, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgsy2_)(const char *trans, int *ijob, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *d, int *ldd, double *e, int *lde, double *f, int *ldf, double *scale, double *rdsum, double *rdscal, int *iwork, int *pq, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgsy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgsy2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsy2K(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray d, jint offsetd, jint ldd, jdoubleArray e, jint offsete, jint lde, jdoubleArray f, jint offsetf, jint ldf, jobject scale, jobject rdsum, jobject rdscal, jintArray iwork, jint offsetiwork, jobject pq, jobject info) {
  if (!dtgsy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nijob __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldd __attribute__((aligned(8)));
  int __nlde __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  double __nscale = 0;
  double __nrdsum = 0;
  double __nrdscal = 0;
  int __npq = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nf = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nijob = ijob;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nldd = ldd;
  __nlde = lde;
  __nldf = ldf;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nrdsum = (*env)->GetDoubleField(env, rdsum, doubleW_val_fieldID);
  __nrdscal = (*env)->GetDoubleField(env, rdscal, doubleW_val_fieldID);
  __npq = (*env)->GetIntField(env, pq, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtgsy2_(__ntrans, &__nijob, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, __nd + offsetd, &__nldd, __ne + offsete, &__nlde, __nf + offsetf, &__nldf, &__nscale, &__nrdsum, &__nrdscal, __niwork + offsetiwork, &__npq, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, pq, intW_val_fieldID, __npq);
  if (!__failed) (*env)->SetDoubleField(env, rdscal, doubleW_val_fieldID, __nrdscal);
  if (!__failed) (*env)->SetDoubleField(env, rdsum, doubleW_val_fieldID, __nrdsum);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtgsyl_)(const char *trans, int *ijob, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *d, int *ldd, double *e, int *lde, double *f, int *ldf, double *scale, double *dif, double *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtgsyl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtgsyl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsylK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray d, jint offsetd, jint ldd, jdoubleArray e, jint offsete, jint lde, jdoubleArray f, jint offsetf, jint ldf, jobject scale, jobject dif, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtgsyl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nijob __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldd __attribute__((aligned(8)));
  int __nlde __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  double __nscale = 0;
  double __ndif = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  double *__nd = NULL;
  double *__ne = NULL;
  double *__nf = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nijob = ijob;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nldd = ldd;
  __nlde = lde;
  __nldf = ldf;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ndif = (*env)->GetDoubleField(env, dif, doubleW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtgsyl_(__ntrans, &__nijob, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, __nd + offsetd, &__nldd, __ne + offsete, &__nlde, __nf + offsetf, &__nldf, &__nscale, &__ndif, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, dif, doubleW_val_fieldID, __ndif);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtpcon_)(const char *norm, const char *uplo, const char *diag, int *n, double *ap, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtpcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtpcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtpconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtpcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtpcon_(__nnorm, __nuplo, __ndiag, &__nn, __nap + offsetap, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtprfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtprfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtptri_)(const char *uplo, const char *diag, int *n, double *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  if (!dtptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  dtptri_(__nuplo, __ndiag, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtptrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dtptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__nap = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dtptrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrcon_)(const char *norm, const char *uplo, const char *diag, int *n, double *a, int *lda, double *rcond, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtrcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  double __nrcond = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtrcon_(__nnorm, __nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrevc_)(const char *side, const char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrevc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrevc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dtrevc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__nt = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtrevc_(__nside, __nhowmny, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrexc_)(const char *compq, int *n, double *t, int *ldt, double *q, int *ldq, int *ifst, int *ilst, double *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrexcK(JNIEnv *env, UNUSED jobject obj, jstring compq, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jobject ifst, jobject ilst, jdoubleArray work, jint offsetwork, jobject info) {
  if (!dtrexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nifst = 0;
  int __nilst = 0;
  int __ninfo = 0;
  double *__nt = NULL;
  double *__nq = NULL;
  double *__nwork = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtrexc_(__ncompq, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, &__nifst, &__nilst, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!__failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtrrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nx = NULL;
  double *__nferr = NULL;
  double *__nberr = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtrrfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrsen_)(const char *job, const char *compq, int *select, int *n, double *t, int *ldt, double *q, int *ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrsen(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrsen_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsenK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jobject m, jobject s, jobject sep, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!dtrsen_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nm = 0;
  double __ns = 0;
  double __nsep = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__nt = NULL;
  double *__nq = NULL;
  double *__nwr = NULL;
  double *__nwi = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __nsep = (*env)->GetDoubleField(env, sep, doubleW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtrsen_(__njob, __ncompq, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, __nwr + offsetwr, __nwi + offsetwi, &__nm, &__ns, &__nsep, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, sep, doubleW_val_fieldID, __nsep);
  if (!__failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrsna_)(const char *job, const char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, double *s, double *sep, int *mm, int *m, double *work, int *ldwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrsna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrsna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray s, jint offsets, jdoubleArray sep, jint offsetsep, jint mm, jobject m, jdoubleArray work, jint offsetwork, jint ldwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!dtrsna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __nldwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  double *__nt = NULL;
  double *__nvl = NULL;
  double *__nvr = NULL;
  double *__ns = NULL;
  double *__nsep = NULL;
  double *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldwork = ldwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  dtrsna_(__njob, __nhowmny, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __ns + offsets, __nsep + offsetsep, &__nmm, &__nm, __nwork + offsetwork, &__nldwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrsyl_)(const char *trana, const char *tranb, int *isgn, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *scale, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrsyl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrsyl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsylK(JNIEnv *env, UNUSED jobject obj, jstring trana, jstring tranb, jint isgn, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jobject scale, jobject info) {
  if (!dtrsyl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrana = NULL;
  const char *__ntranb = NULL;
  int __nisgn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  double __nscale = 0;
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  double *__nc = NULL;
  if (!(__ntrana = (*env)->GetStringUTFChars(env, trana, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntranb = (*env)->GetStringUTFChars(env, tranb, NULL))) { __failed = TRUE; goto done; }
  __nisgn = isgn;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  dtrsyl_(__ntrana, __ntranb, &__nisgn, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, &__nscale, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntranb) (*env)->ReleaseStringUTFChars(env, tranb, __ntranb);
  if (__ntrana) (*env)->ReleaseStringUTFChars(env, trana, __ntrana);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrti2_)(const char *uplo, const char *diag, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrti2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrti2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrti2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dtrti2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dtrti2_(__nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrtri_)(const char *uplo, const char *diag, int *n, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrtri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrtri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrtriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!dtrtri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  dtrtri_(__nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtrtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtrtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtrtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  if (!dtrtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  dtrtrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtzrqf_)(int *m, int *n, double *a, int *lda, double *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtzrqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtzrqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtzrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jobject info) {
  if (!dtzrqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  dtzrqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dtzrzf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dtzrzf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dtzrzf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtzrzfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  if (!dtzrzf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  double *__na = NULL;
  double *__ntau = NULL;
  double *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  dtzrzf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*ieeeck_)(int *ispec, float *zero, float *one);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ieeeck(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ieeeck_ != NULL;
}

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_ieeeckK(JNIEnv *env, UNUSED jobject obj, jint ispec, jfloat zero, jfloat one) {
  if (!ieeeck_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jint __ret = 0;
  jboolean __failed = FALSE;
  int __nispec __attribute__((aligned(8)));
  float __nzero __attribute__((aligned(8)));
  float __none __attribute__((aligned(8)));
  __nispec = ispec;
  __nzero = zero;
  __none = one;
  __ret = ieeeck_(&__nispec, &__nzero, &__none);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static int (*ilaenv_)(int *ispec, const char *name, const char *opts, int *n1, int *n2, int *n3, int *n4);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ilaenv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ilaenv_ != NULL;
}

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_ilaenvK(JNIEnv *env, UNUSED jobject obj, jint ispec, jstring name, jstring opts, jint n1, jint n2, jint n3, jint n4) {
  if (!ilaenv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jint __ret = 0;
  jboolean __failed = FALSE;
  int __nispec __attribute__((aligned(8)));
  const char *__nname = NULL;
  const char *__nopts = NULL;
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nn3 __attribute__((aligned(8)));
  int __nn4 __attribute__((aligned(8)));
  __nispec = ispec;
  if (!(__nname = (*env)->GetStringUTFChars(env, name, NULL))) { __failed = TRUE; goto done; }
  if (!(__nopts = (*env)->GetStringUTFChars(env, opts, NULL))) { __failed = TRUE; goto done; }
  __nn1 = n1;
  __nn2 = n2;
  __nn3 = n3;
  __nn4 = n4;
  __ret = ilaenv_(&__nispec, __nname, __nopts, &__nn1, &__nn2, &__nn3, &__nn4);
done:
  if (__nopts) (*env)->ReleaseStringUTFChars(env, opts, __nopts);
  if (__nname) (*env)->ReleaseStringUTFChars(env, name, __nname);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*ilaver_)(int *vers_major, int *vers_minor, int *vers_patch);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ilaver(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ilaver_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ilaverK(JNIEnv *env, UNUSED jobject obj, jobject vers_major, jobject vers_minor, jobject vers_patch) {
  if (!ilaver_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nvers_major = 0;
  int __nvers_minor = 0;
  int __nvers_patch = 0;
  __nvers_major = (*env)->GetIntField(env, vers_major, intW_val_fieldID);
  __nvers_minor = (*env)->GetIntField(env, vers_minor, intW_val_fieldID);
  __nvers_patch = (*env)->GetIntField(env, vers_patch, intW_val_fieldID);
  ilaver_(&__nvers_major, &__nvers_minor, &__nvers_patch);
done:
  if (!__failed) (*env)->SetIntField(env, vers_patch, intW_val_fieldID, __nvers_patch);
  if (!__failed) (*env)->SetIntField(env, vers_minor, intW_val_fieldID, __nvers_minor);
  if (!__failed) (*env)->SetIntField(env, vers_major, intW_val_fieldID, __nvers_major);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*iparmq_)(int *ispec, const char *name, const char *opts, int *n, int *ilo, int *ihi, int *lwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_iparmq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return iparmq_ != NULL;
}

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_iparmqK(JNIEnv *env, UNUSED jobject obj, jint ispec, jstring name, jstring opts, jint n, jint ilo, jint ihi, jint lwork) {
  if (!iparmq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jint __ret = 0;
  jboolean __failed = FALSE;
  int __nispec __attribute__((aligned(8)));
  const char *__nname = NULL;
  const char *__nopts = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  __nispec = ispec;
  if (!(__nname = (*env)->GetStringUTFChars(env, name, NULL))) { __failed = TRUE; goto done; }
  if (!(__nopts = (*env)->GetStringUTFChars(env, opts, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlwork = lwork;
  __ret = iparmq_(&__nispec, __nname, __nopts, &__nn, &__nilo, &__nihi, &__nlwork);
done:
  if (__nopts) (*env)->ReleaseStringUTFChars(env, opts, __nopts);
  if (__nname) (*env)->ReleaseStringUTFChars(env, name, __nname);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static int (*lsamen_)(int *n, const char *ca, const char *cb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_lsamen(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return lsamen_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_lsamenK(JNIEnv *env, UNUSED jobject obj, jint n, jstring ca, jstring cb) {
  if (!lsamen_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  const char *__nca = NULL;
  const char *__ncb = NULL;
  __nn = n;
  if (!(__nca = (*env)->GetStringUTFChars(env, ca, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncb = (*env)->GetStringUTFChars(env, cb, NULL))) { __failed = TRUE; goto done; }
  __ret = lsamen_(&__nn, __nca, __ncb);
done:
  if (__ncb) (*env)->ReleaseStringUTFChars(env, cb, __ncb);
  if (__nca) (*env)->ReleaseStringUTFChars(env, ca, __nca);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*sbdsdc_)(const char *uplo, const char *compq, int *n, float *d, float *e, float *u, int *ldu, float *vt, int *ldvt, float *q, int *iq, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sbdsdc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sbdsdc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sbdsdcK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring compq, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray q, jint offsetq, jintArray iq, jint offsetiq, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sbdsdc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  float *__nq = NULL;
  int *__niq = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldu = ldu;
  __nldvt = ldvt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__niq = (*env)->GetPrimitiveArrayCritical(env, iq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sbdsdc_(__nuplo, __ncompq, &__nn, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nq + offsetq, __niq + offsetiq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niq) (*env)->ReleasePrimitiveArrayCritical(env, iq, __niq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sbdsqr_)(const char *uplo, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, float *vt, int *ldvt, float *u, int *ldu, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sbdsqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sbdsqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sbdsqrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint ncvt, jint nru, jint ncc, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray u, jint offsetu, jint ldu, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sbdsqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nncvt __attribute__((aligned(8)));
  int __nnru __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nvt = NULL;
  float *__nu = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nncvt = ncvt;
  __nnru = nru;
  __nncc = ncc;
  __nldvt = ldvt;
  __nldu = ldu;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sbdsqr_(__nuplo, &__nn, &__nncvt, &__nnru, &__nncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &__nldvt, __nu + offsetu, &__nldu, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sdisna_)(const char *job, int *m, int *n, float *d, float *sep, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sdisna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sdisna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sdisnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jint m, jint n, jfloatArray d, jint offsetd, jfloatArray sep, jint offsetsep, jobject info) {
  if (!sdisna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nsep = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) { __failed = TRUE; goto done; }
  sdisna_(__njob, &__nm, &__nn, __nd + offsetd, __nsep + offsetsep, &__ninfo);
done:
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbbrd_)(const char *vect, int *m, int *n, int *ncc, int *kl, int *ku, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *pt, int *ldpt, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbbrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbbrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbbrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint ncc, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray pt, jint offsetpt, jint ldpt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgbbrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldpt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nq = NULL;
  float *__npt = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nncc = ncc;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nldq = ldq;
  __nldpt = ldpt;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__npt = (*env)->GetPrimitiveArrayCritical(env, pt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgbbrd_(__nvect, &__nm, &__nn, &__nncc, &__nkl, &__nku, __nab + offsetab, &__nldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __npt + offsetpt, &__nldpt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__npt) (*env)->ReleasePrimitiveArrayCritical(env, pt, __npt, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbcon_)(const char *norm, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgbcon_(__nnorm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbequ_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  if (!sgbequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nrowcnd = 0;
  float __ncolcnd = 0;
  float __namax = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nrowcnd = (*env)->GetFloatField(env, rowcnd, floatW_val_fieldID);
  __ncolcnd = (*env)->GetFloatField(env, colcnd, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  sgbequ_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!__failed) (*env)->SetFloatField(env, colcnd, floatW_val_fieldID, __ncolcnd);
  if (!__failed) (*env)->SetFloatField(env, rowcnd, floatW_val_fieldID, __nrowcnd);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbrfs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nafb = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgbrfs_(__ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbsv_)(int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgbsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgbsv_(&__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbsvx_)(const char *fact, const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jobject equed, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgbsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nafb = NULL;
  int *__nipiv = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgbsvx_(__nfact, __ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbtf2_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbtf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbtf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!sgbtf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  sgbtf2_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbtrf_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbtrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbtrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!sgbtrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  sgbtrf_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgbtrs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgbtrs_(__ntrans, &__nn, &__nkl, &__nku, &__nnrhs, __nab + offsetab, &__nldab, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgebak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, float *scale, int *m, float *v, int *ldv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgebak(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgebak_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jfloatArray scale, jint offsetscale, jint m, jfloatArray v, jint offsetv, jint ldv, jobject info) {
  if (!sgebak_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nside = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nscale = NULL;
  float *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nm = m;
  __nldv = ldv;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  sgebak_(__njob, __nside, &__nn, &__nilo, &__nihi, __nscale + offsetscale, &__nm, __nv + offsetv, &__nldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgebal_)(const char *job, int *n, float *a, int *lda, int *ilo, int *ihi, float *scale, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgebal(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgebal_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jfloatArray a, jint offseta, jint lda, jobject ilo, jobject ihi, jfloatArray scale, jint offsetscale, jobject info) {
  if (!sgebal_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nscale = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  sgebal_(__njob, &__nn, __na + offseta, &__nlda, &__nilo, &__nihi, __nscale + offsetscale, &__ninfo);
done:
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgebd2_)(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgebd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgebd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebd2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgebd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntauq = NULL;
  float *__ntaup = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgebd2_(&__nm, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgebrd_)(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgebrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgebrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgebrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntauq = NULL;
  float *__ntaup = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgebrd_(&__nm, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgecon_)(const char *norm, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgecon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgecon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray a, jint offseta, jint lda, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgecon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgecon_(__nnorm, &__nn, __na + offseta, &__nlda, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeequ_)(int *m, int *n, float *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  if (!sgeequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nrowcnd = 0;
  float __ncolcnd = 0;
  float __namax = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nrowcnd = (*env)->GetFloatField(env, rowcnd, floatW_val_fieldID);
  __ncolcnd = (*env)->GetFloatField(env, colcnd, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  sgeequ_(&__nm, &__nn, __na + offseta, &__nlda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!__failed) (*env)->SetFloatField(env, colcnd, floatW_val_fieldID, __ncolcnd);
  if (!__failed) (*env)->SetFloatField(env, rowcnd, floatW_val_fieldID, __nrowcnd);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*sgees_)(const char *jobvs, const char *sort, const char *select, int *n, float *a, int *lda, int *sdim, float *wr, float *wi, float *vs, int *ldvs, float *work, int *lwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgees(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeesK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvs, UNUSED jstring sort, UNUSED jstring select, UNUSED jint n, UNUSED jfloatArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jobject sdim, UNUSED jfloatArray wr, UNUSED jint offsetwr, UNUSED jfloatArray wi, UNUSED jint offsetwi, UNUSED jfloatArray vs, UNUSED jint offsetvs, UNUSED jint ldvs, UNUSED jfloatArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sgeesx_)(const char *jobvs, const char *sort, const char *select, const char *sense, int *n, float *a, int *lda, int *sdim, float *wr, float *wi, float *vs, int *ldvs, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeesx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeesxK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvs, UNUSED jstring sort, UNUSED jstring select, UNUSED jstring sense, UNUSED jint n, UNUSED jfloatArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jobject sdim, UNUSED jfloatArray wr, UNUSED jint offsetwr, UNUSED jfloatArray wi, UNUSED jint offsetwi, UNUSED jfloatArray vs, UNUSED jint offsetvs, UNUSED jint ldvs, UNUSED jobject rconde, UNUSED jobject rcondv, UNUSED jfloatArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jintArray iwork, UNUSED jint offsetiwork, UNUSED jint liwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*sgeev_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgeev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeev_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jfloatArray scale, jint offsetscale, jobject abnrm, jfloatArray rconde, jint offsetrconde, jfloatArray rcondv, jint offsetrcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgeevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nbalanc = NULL;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  const char *__nsense = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  float __nabnrm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nscale = NULL;
  float *__nrconde = NULL;
  float *__nrcondv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetFloatField(env, abnrm, floatW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgeevx_(__nbalanc, __njobvl, __njobvr, __nsense, &__nn, __na + offseta, &__nlda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nilo, &__nihi, __nscale + offsetscale, &__nabnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, __failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, __failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, abnrm, floatW_val_fieldID, __nabnrm);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgegs_)(const char *jobvsl, const char *jobvsr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgegs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgegs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgegsK(JNIEnv *env, UNUSED jobject obj, jstring jobvsl, jstring jobvsr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vsl, jint offsetvsl, jint ldvsl, jfloatArray vsr, jint offsetvsr, jint ldvsr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgegs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvsl = NULL;
  const char *__njobvsr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvsl __attribute__((aligned(8)));
  int __nldvsr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nvsl = NULL;
  float *__nvsr = NULL;
  float *__nwork = NULL;
  if (!(__njobvsl = (*env)->GetStringUTFChars(env, jobvsl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvsr = (*env)->GetStringUTFChars(env, jobvsr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvsl = ldvsl;
  __nldvsr = ldvsr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvsl = (*env)->GetPrimitiveArrayCritical(env, vsl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvsr = (*env)->GetPrimitiveArrayCritical(env, vsr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgegs_(__njobvsl, __njobvsr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvsl + offsetvsl, &__nldvsl, __nvsr + offsetvsr, &__nldvsr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvsr) (*env)->ReleasePrimitiveArrayCritical(env, vsr, __nvsr, __failed ? JNI_ABORT : 0);
  if (__nvsl) (*env)->ReleasePrimitiveArrayCritical(env, vsl, __nvsl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvsr) (*env)->ReleaseStringUTFChars(env, jobvsr, __njobvsr);
  if (__njobvsl) (*env)->ReleaseStringUTFChars(env, jobvsl, __njobvsl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgegv_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgegv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgegv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgegvK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgegv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgegv_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgehd2_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgehd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgehd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgehd2K(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgehd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgehd2_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgehrd_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgehrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgehrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgehrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgehrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgehrd_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelq2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgelq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgelq2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelqf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgelqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgelqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgels_)(const char *trans, int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgels(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgels_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgels_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgels_(__ntrans, &__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelsd_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelsd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelsd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray s, jint offsets, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgelsd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__ns = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgelsd_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __ns + offsets, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelss_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelss(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelss_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelssK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray s, jint offsets, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgelss_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__ns = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgelss_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __ns + offsets, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelsx_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *jpvt, float *rcond, int *rank, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelsx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelsx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsxK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgelsx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  int *__njpvt = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgelsx_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __njpvt + offsetjpvt, &__nrcond, &__nrank, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgelsy_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *jpvt, float *rcond, int *rank, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgelsy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgelsy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsyK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgelsy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  int *__njpvt = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgelsy_(&__nm, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __njpvt + offsetjpvt, &__nrcond, &__nrank, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeql2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeql2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeql2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeql2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgeql2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeql2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeqlf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeqlf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeqlf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqlfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgeqlf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeqlf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeqp3_)(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeqp3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeqp3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqp3K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgeqp3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__njpvt = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeqp3_(&__nm, &__nn, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeqpf_)(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeqpf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeqpf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqpfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgeqpf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__njpvt = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeqpf_(&__nm, &__nn, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeqr2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeqr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeqr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgeqr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeqr2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgeqrf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgeqrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgeqrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgeqrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgeqrf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgerfs_)(const char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgerfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgerfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgerfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgerfs_(__ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgerq2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgerq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgerq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sgerq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgerq2_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgerqf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgerqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgerqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgerqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgerqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgesc2_)(int *n, float *a, int *lda, float *rhs, int *ipiv, int *jpiv, float *scale);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgesc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgesc2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesc2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray rhs, jint offsetrhs, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject scale) {
  if (!sgesc2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nscale = 0;
  float *__na = NULL;
  float *__nrhs = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nn = n;
  __nlda = lda;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  sgesc2_(&__nn, __na + offseta, &__nlda, __nrhs + offsetrhs, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__nscale);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgesdd_)(const char *jobz, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgesdd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgesdd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesddK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgesdd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ns = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldu = ldu;
  __nldvt = ldvt;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgesdd_(__njobz, &__nm, &__nn, __na + offseta, &__nlda, __ns + offsets, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgesv_)(int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgesv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgesv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgesv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgesv_(&__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgesvd_)(const char *jobu, const char *jobvt, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgesvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgesvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobvt, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgesvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobvt = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ns = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvt = (*env)->GetStringUTFChars(env, jobvt, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldu = ldu;
  __nldvt = ldvt;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgesvd_(__njobu, __njobvt, &__nm, &__nn, __na + offseta, &__nlda, __ns + offsets, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvt) (*env)->ReleaseStringUTFChars(env, jobvt, __njobvt);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgesvx_)(const char *fact, const char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgesvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgesvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jobject equed, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgesvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  int *__nipiv = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgesvx_(__nfact, __ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgetc2_)(int *n, float *a, int *lda, int *ipiv, int *jpiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgetc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgetc2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetc2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject info) {
  if (!sgetc2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  sgetc2_(&__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__ninfo);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgetf2_)(int *m, int *n, float *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgetf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgetf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!sgetf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  sgetf2_(&__nm, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgetrf_)(int *m, int *n, float *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgetrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgetrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!sgetrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  sgetrf_(&__nm, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgetri_)(int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgetri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgetri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetriK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgetri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgetri_(&__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgetrs_)(const char *trans, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgetrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgetrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgetrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgetrs_(__ntrans, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggbak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, float *lscale, float *rscale, int *m, float *v, int *ldv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggbak(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggbak_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggbakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jint m, jfloatArray v, jint offsetv, jint ldv, jobject info) {
  if (!sggbak_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nside = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nlscale = NULL;
  float *__nrscale = NULL;
  float *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nm = m;
  __nldv = ldv;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  sggbak_(__njob, __nside, &__nn, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nm, __nv + offsetv, &__nldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggbal_)(const char *job, int *n, float *a, int *lda, float *b, int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggbal(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggbal_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggbalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject ilo, jobject ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jfloatArray work, jint offsetwork, jobject info) {
  if (!sggbal_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nlscale = NULL;
  float *__nrscale = NULL;
  float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggbal_(__njob, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*sgges_)(const char *jobvsl, const char *jobvsr, const char *sort, const char *selctg, int *n, float *a, int *lda, float *b, int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *work, int *lwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgges(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggesK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvsl, UNUSED jstring jobvsr, UNUSED jstring sort, UNUSED jstring selctg, UNUSED jint n, UNUSED jfloatArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jfloatArray b, UNUSED jint offsetb, UNUSED jint ldb, UNUSED jobject sdim, UNUSED jfloatArray alphar, UNUSED jint offsetalphar, UNUSED jfloatArray alphai, UNUSED jint offsetalphai, UNUSED jfloatArray beta, UNUSED jint offsetbeta, UNUSED jfloatArray vsl, UNUSED jint offsetvsl, UNUSED jint ldvsl, UNUSED jfloatArray vsr, UNUSED jint offsetvsr, UNUSED jint ldvsr, UNUSED jfloatArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sggesx_)(const char *jobvsl, const char *jobvsr, const char *sort, const char *selctg, const char *sense, int *n, float *a, int *lda, float *b, int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggesx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggesxK(JNIEnv *env, UNUSED jobject obj, UNUSED jstring jobvsl, UNUSED jstring jobvsr, UNUSED jstring sort, UNUSED jstring selctg, UNUSED jstring sense, UNUSED jint n, UNUSED jfloatArray a, UNUSED jint offseta, UNUSED jint lda, UNUSED jfloatArray b, UNUSED jint offsetb, UNUSED jint ldb, UNUSED jobject sdim, UNUSED jfloatArray alphar, UNUSED jint offsetalphar, UNUSED jfloatArray alphai, UNUSED jint offsetalphai, UNUSED jfloatArray beta, UNUSED jint offsetbeta, UNUSED jfloatArray vsl, UNUSED jint offsetvsl, UNUSED jint ldvsl, UNUSED jfloatArray vsr, UNUSED jint offsetvsr, UNUSED jint ldvsr, UNUSED jfloatArray rconde, UNUSED jint offsetrconde, UNUSED jfloatArray rcondv, UNUSED jint offsetrcondv, UNUSED jfloatArray work, UNUSED jint offsetwork, UNUSED jint lwork, UNUSED jintArray iwork, UNUSED jint offsetiwork, UNUSED jint liwork, UNUSED jbooleanArray bwork, UNUSED jint offsetbwork, UNUSED jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*sggev_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sggev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggev_(__njobvl, __njobvr, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *bwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jobject abnrm, jobject bbnrm, jfloatArray rconde, jint offsetrconde, jfloatArray rcondv, jint offsetrcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  if (!sggevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nbalanc = NULL;
  const char *__njobvl = NULL;
  const char *__njobvr = NULL;
  const char *__nsense = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nilo = 0;
  int __nihi = 0;
  float __nabnrm = 0;
  float __nbbnrm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nlscale = NULL;
  float *__nrscale = NULL;
  float *__nrconde = NULL;
  float *__nrcondv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nbwork = NULL; jboolean *__jbwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetFloatField(env, abnrm, floatW_val_fieldID);
  __nbbnrm = (*env)->GetFloatField(env, bbnrm, floatW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__jbwork = (*env)->GetPrimitiveArrayCritical(env, bwork, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, bwork);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nbwork = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nbwork[i] = __jbwork[i]; }
  } while(0);
  sggevx_(__nbalanc, __njobvl, __njobvr, __nsense, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nabnrm, &__nbbnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nbwork + offsetbwork, &__ninfo);
done:
  if (__nbwork) { free(__nbwork); } if (__jbwork) (*env)->ReleasePrimitiveArrayCritical(env, bwork, __nbwork, JNI_ABORT);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, __failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, __failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, __failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, bbnrm, floatW_val_fieldID, __nbbnrm);
  if (!__failed) (*env)->SetFloatField(env, abnrm, floatW_val_fieldID, __nabnrm);
  if (!__failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!__failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggglm_)(int *n, int *m, int *p, float *a, int *lda, float *b, int *ldb, float *d, float *x, float *y, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggglm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggglm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggglmK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray d, jint offsetd, jfloatArray x, jint offsetx, jfloatArray y, jint offsety, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sggglm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nd = NULL;
  float *__nx = NULL;
  float *__ny = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nm = m;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggglm_(&__nn, &__nm, &__np, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nd + offsetd, __nx + offsetx, __ny + offsety, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgghrd_)(const char *compq, const char *compz, int *n, int *ilo, int *ihi, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgghrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgghrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgghrdK(JNIEnv *env, UNUSED jobject obj, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject info) {
  if (!sgghrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompq = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nq = NULL;
  float *__nz = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  sgghrd_(__ncompq, __ncompz, &__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgglse_)(int *m, int *n, int *p, float *a, int *lda, float *b, int *ldb, float *c, float *d, float *x, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgglse(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgglse_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgglseK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jfloatArray d, jint offsetd, jfloatArray x, jint offsetx, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sgglse_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  float *__nd = NULL;
  float *__nx = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sgglse_(&__nm, &__nn, &__np, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, __nd + offsetd, __nx + offsetx, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggqrf_)(int *n, int *m, int *p, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggqrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggqrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggqrfK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray taua, jint offsettaua, jfloatArray b, jint offsetb, jint ldb, jfloatArray taub, jint offsettaub, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sggqrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntaua = NULL;
  float *__nb = NULL;
  float *__ntaub = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nm = m;
  __np = p;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggqrf_(&__nn, &__nm, &__np, __na + offseta, &__nlda, __ntaua + offsettaua, __nb + offsetb, &__nldb, __ntaub + offsettaub, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggrqf_)(int *m, int *p, int *n, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggrqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggrqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint p, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray taua, jint offsettaua, jfloatArray b, jint offsetb, jint ldb, jfloatArray taub, jint offsettaub, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sggrqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntaua = NULL;
  float *__nb = NULL;
  float *__ntaub = NULL;
  float *__nwork = NULL;
  __nm = m;
  __np = p;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggrqf_(&__nm, &__np, &__nn, __na + offseta, &__nlda, __ntaua + offsettaua, __nb + offsetb, &__nldb, __ntaub + offsettaub, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggsvd_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *n, int *p, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggsvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggsvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggsvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint n, jint p, jobject k, jobject l, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alpha, jint offsetalpha, jfloatArray beta, jint offsetbeta, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sggsvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nk = 0;
  int __nl = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalpha = NULL;
  float *__nbeta = NULL;
  float *__nu = NULL;
  float *__nv = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __np = p;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __nlda = lda;
  __nldb = ldb;
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sggsvd_(__njobu, __njobv, __njobq, &__nm, &__nn, &__np, &__nk, &__nl, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sggsvp_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, int *k, int *l, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, int *iwork, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sggsvp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sggsvp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggsvpK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat tola, jfloat tolb, jobject k, jobject l, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jintArray iwork, jint offsetiwork, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sggsvp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __ntola __attribute__((aligned(8)));
  float __ntolb __attribute__((aligned(8)));
  int __nk = 0;
  int __nl = 0;
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nu = NULL;
  float *__nv = NULL;
  float *__nq = NULL;
  int *__niwork = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __np = p;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ntola = tola;
  __ntolb = tolb;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sggsvp_(__njobu, __njobv, __njobq, &__nm, &__np, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ntola, &__ntolb, &__nk, &__nl, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __niwork + offsetiwork, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgtcon_)(const char *norm, int *n, float *dl, float *d, float *du, float *du2, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgtcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgtcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgtcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgtcon_(__nnorm, &__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgtrfs_)(const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgtrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgtrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray dlf, jint offsetdlf, jfloatArray df, jint offsetdf, jfloatArray duf, jint offsetduf, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgtrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndlf = NULL;
  float *__ndf = NULL;
  float *__nduf = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgtrfs_(__ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgtsv_)(int *n, int *nrhs, float *dl, float *d, float *du, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgtsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgtsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgtsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgtsv_(&__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgtsvx_)(const char *fact, const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgtsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgtsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray dlf, jint offsetdlf, jfloatArray df, jint offsetdf, jfloatArray duf, jint offsetduf, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sgtsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndlf = NULL;
  float *__ndf = NULL;
  float *__nduf = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sgtsvx_(__nfact, __ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgttrf_)(int *n, float *dl, float *d, float *du, float *du2, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgttrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgttrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!sgttrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  sgttrf_(&__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgttrs_)(const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *du2, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgttrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgttrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgttrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sgttrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgttrs_(__ntrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sgtts2_)(int *itrans, int *n, int *nrhs, float *dl, float *d, float *du, float *du2, int *ipiv, float *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sgtts2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sgtts2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtts2K(JNIEnv *env, UNUSED jobject obj, jint itrans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb) {
  if (!sgtts2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitrans __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__ndu2 = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  __nitrans = itrans;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sgtts2_(&__nitrans, &__nn, &__nnrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*shgeqz_)(const char *job, const char *compq, const char *compz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *t, int *ldt, float *alphar, float *alphai, float *beta, float *q, int *ldq, float *z, int *ldz, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_shgeqz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return shgeqz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shgeqzK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray t, jint offsett, jint ldt, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!shgeqz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompq = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nt = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nq = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __nldt = ldt;
  __nldq = ldq;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  shgeqz_(__njob, __ncompq, __ncompz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nt + offsett, &__nldt, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*shsein_)(const char *side, const char *eigsrc, const char *initv, int *select, int *n, float *h, int *ldh, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *ifaill, int *ifailr, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_shsein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return shsein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shseinK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring eigsrc, jstring initv, jbooleanArray select, jint offsetselect, jint n, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jintArray ifaill, jint offsetifaill, jintArray ifailr, jint offsetifailr, jobject info) {
  if (!shsein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__neigsrc = NULL;
  const char *__ninitv = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__nh = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  int *__nifaill = NULL;
  int *__nifailr = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__neigsrc = (*env)->GetStringUTFChars(env, eigsrc, NULL))) { __failed = TRUE; goto done; }
  if (!(__ninitv = (*env)->GetStringUTFChars(env, initv, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldh = ldh;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifaill = (*env)->GetPrimitiveArrayCritical(env, ifaill, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifailr = (*env)->GetPrimitiveArrayCritical(env, ifailr, NULL))) { __failed = TRUE; goto done; }
  shsein_(__nside, __neigsrc, __ninitv, __nselect + offsetselect, &__nn, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, __nifaill + offsetifaill, __nifailr + offsetifailr, &__ninfo);
done:
  if (__nifailr) (*env)->ReleasePrimitiveArrayCritical(env, ifailr, __nifailr, __failed ? JNI_ABORT : 0);
  if (__nifaill) (*env)->ReleasePrimitiveArrayCritical(env, ifaill, __nifaill, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ninitv) (*env)->ReleaseStringUTFChars(env, initv, __ninitv);
  if (__neigsrc) (*env)->ReleaseStringUTFChars(env, eigsrc, __neigsrc);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*shseqr_)(const char *job, const char *compz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, float *z, int *ldz, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_shseqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return shseqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shseqrK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!shseqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  shseqr_(__njob, __ncompz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*sisnan_)(float *sin);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sisnan(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sisnan_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_sisnanK(JNIEnv *env, UNUSED jobject obj, jfloat sin) {
  if (!sisnan_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  float __nsin __attribute__((aligned(8)));
  __nsin = sin;
  __ret = sisnan_(&__nsin);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*slabad_)(float *small, float *large);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slabad(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slabad_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slabadK(JNIEnv *env, UNUSED jobject obj, jobject small, jobject large) {
  if (!slabad_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __nsmall = 0;
  float __nlarge = 0;
  __nsmall = (*env)->GetFloatField(env, small, floatW_val_fieldID);
  __nlarge = (*env)->GetFloatField(env, large, floatW_val_fieldID);
  slabad_(&__nsmall, &__nlarge);
done:
  if (!__failed) (*env)->SetFloatField(env, large, floatW_val_fieldID, __nlarge);
  if (!__failed) (*env)->SetFloatField(env, small, floatW_val_fieldID, __nsmall);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slabrd_)(int *m, int *n, int *nb, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *x, int *ldx, float *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slabrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slabrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slabrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray x, jint offsetx, jint ldx, jfloatArray y, jint offsety, jint ldy) {
  if (!slabrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntauq = NULL;
  float *__ntaup = NULL;
  float *__nx = NULL;
  float *__ny = NULL;
  __nm = m;
  __nn = n;
  __nnb = nb;
  __nlda = lda;
  __nldx = ldx;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  slabrd_(&__nm, &__nn, &__nnb, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nx + offsetx, &__nldx, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, __failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slacn2_)(int *n, float *v, float *x, int *isgn, float *est, int *kase, int *isave);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slacn2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slacn2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slacn2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray v, jint offsetv, jfloatArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase, jintArray isave, jint offsetisave) {
  if (!slacn2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nest = 0;
  int __nkase = 0;
  float *__nv = NULL;
  float *__nx = NULL;
  int *__nisgn = NULL;
  int *__nisave = NULL;
  __nn = n;
  __nest = (*env)->GetFloatField(env, est, floatW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisave = (*env)->GetPrimitiveArrayCritical(env, isave, NULL))) { __failed = TRUE; goto done; }
  slacn2_(&__nn, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase, __nisave + offsetisave);
done:
  if (__nisave) (*env)->ReleasePrimitiveArrayCritical(env, isave, __nisave, __failed ? JNI_ABORT : 0);
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!__failed) (*env)->SetFloatField(env, est, floatW_val_fieldID, __nest);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slacon_)(int *n, float *v, float *x, int *isgn, float *est, int *kase);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slacon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slacon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaconK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray v, jint offsetv, jfloatArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase) {
  if (!slacon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nest = 0;
  int __nkase = 0;
  float *__nv = NULL;
  float *__nx = NULL;
  int *__nisgn = NULL;
  __nn = n;
  __nest = (*env)->GetFloatField(env, est, floatW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) { __failed = TRUE; goto done; }
  slacon_(&__nn, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase);
done:
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!__failed) (*env)->SetFloatField(env, est, floatW_val_fieldID, __nest);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slacpy_)(const char *uplo, int *m, int *n, float *a, int *lda, float *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slacpy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slacpy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slacpyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb) {
  if (!slacpy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  slacpy_(__nuplo, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sladiv_)(float *a, float *b, float *c, float *d, float *p, float *q);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sladiv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sladiv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sladivK(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jfloat d, jobject p, jobject q) {
  if (!sladiv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __na __attribute__((aligned(8)));
  float __nb __attribute__((aligned(8)));
  float __nc __attribute__((aligned(8)));
  float __nd __attribute__((aligned(8)));
  float __np = 0;
  float __nq = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nd = d;
  __np = (*env)->GetFloatField(env, p, floatW_val_fieldID);
  __nq = (*env)->GetFloatField(env, q, floatW_val_fieldID);
  sladiv_(&__na, &__nb, &__nc, &__nd, &__np, &__nq);
done:
  if (!__failed) (*env)->SetFloatField(env, q, floatW_val_fieldID, __nq);
  if (!__failed) (*env)->SetFloatField(env, p, floatW_val_fieldID, __np);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slae2_)(float *a, float *b, float *c, float *rt1, float *rt2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slae2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slae2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slae2K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jobject rt1, jobject rt2) {
  if (!slae2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __na __attribute__((aligned(8)));
  float __nb __attribute__((aligned(8)));
  float __nc __attribute__((aligned(8)));
  float __nrt1 = 0;
  float __nrt2 = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nrt1 = (*env)->GetFloatField(env, rt1, floatW_val_fieldID);
  __nrt2 = (*env)->GetFloatField(env, rt2, floatW_val_fieldID);
  slae2_(&__na, &__nb, &__nc, &__nrt1, &__nrt2);
done:
  if (!__failed) (*env)->SetFloatField(env, rt2, floatW_val_fieldID, __nrt2);
  if (!__failed) (*env)->SetFloatField(env, rt1, floatW_val_fieldID, __nrt1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaebz_)(int *ijob, int *nitmax, int *n, int *mmax, int *minp, int *nbmin, float *abstol, float *reltol, float *pivmin, float *d, float *e, float *e2, int *nval, float *ab, float *c, int *mout, int *nab, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaebz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaebz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaebzK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint nitmax, jint n, jint mmax, jint minp, jint nbmin, jfloat abstol, jfloat reltol, jfloat pivmin, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jintArray nval, jint offsetnval, jfloatArray ab, jint offsetab, jfloatArray c, jint offsetc, jobject mout, jintArray nab, jint offsetnab, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slaebz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nnitmax __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nmmax __attribute__((aligned(8)));
  int __nminp __attribute__((aligned(8)));
  int __nnbmin __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  float __nreltol __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  int __nmout = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ne2 = NULL;
  int *__nnval = NULL;
  float *__nab = NULL;
  float *__nc = NULL;
  int *__nnab = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nijob = ijob;
  __nnitmax = nitmax;
  __nn = n;
  __nmmax = mmax;
  __nminp = minp;
  __nnbmin = nbmin;
  __nabstol = abstol;
  __nreltol = reltol;
  __npivmin = pivmin;
  __nmout = (*env)->GetIntField(env, mout, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnval = (*env)->GetPrimitiveArrayCritical(env, nval, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnab = (*env)->GetPrimitiveArrayCritical(env, nab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slaebz_(&__nijob, &__nnitmax, &__nn, &__nmmax, &__nminp, &__nnbmin, &__nabstol, &__nreltol, &__npivmin, __nd + offsetd, __ne + offsete, __ne2 + offsete2, __nnval + offsetnval, __nab + offsetab, __nc + offsetc, &__nmout, __nnab + offsetnab, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nnab) (*env)->ReleasePrimitiveArrayCritical(env, nab, __nnab, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nnval) (*env)->ReleasePrimitiveArrayCritical(env, nval, __nnval, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, mout, intW_val_fieldID, __nmout);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed0_)(int *icompq, int *qsiz, int *n, float *d, float *e, float *q, int *ldq, float *qstore, int *ldqs, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint qsiz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray qstore, jint offsetqstore, jint ldqs, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slaed0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldqs __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nq = NULL;
  float *__nqstore = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nqsiz = qsiz;
  __nn = n;
  __nldq = ldq;
  __nldqs = ldqs;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slaed0_(&__nicompq, &__nqsiz, &__nn, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __nqstore + offsetqstore, &__nldqs, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed1_)(int *n, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slaed1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  int *__nindxq = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nldq = ldq;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ncutpnt = cutpnt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slaed1_(&__nn, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed2_)(int *k, int *n, int *n1, float *d, float *q, int *ldq, int *indxq, float *rho, float *z, float *dlamda, float *w, float *q2, int *indx, int *indxc, int *indxp, int *coltyp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed2K(JNIEnv *env, UNUSED jobject obj, jobject k, jint n, jint n1, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jfloatArray z, jint offsetz, jfloatArray dlamda, jint offsetdlamda, jfloatArray w, jint offsetw, jfloatArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray indxc, jint offsetindxc, jintArray indxp, jint offsetindxp, jintArray coltyp, jint offsetcoltyp, jobject info) {
  if (!slaed2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk = 0;
  int __nn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  int *__nindxq = NULL;
  float *__nz = NULL;
  float *__ndlamda = NULL;
  float *__nw = NULL;
  float *__nq2 = NULL;
  int *__nindx = NULL;
  int *__nindxc = NULL;
  int *__nindxp = NULL;
  int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nn = n;
  __nn1 = n1;
  __nldq = ldq;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxc = (*env)->GetPrimitiveArrayCritical(env, indxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) { __failed = TRUE; goto done; }
  slaed2_(&__nk, &__nn, &__nn1, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, __nz + offsetz, __ndlamda + offsetdlamda, __nw + offsetw, __nq2 + offsetq2, __nindx + offsetindx, __nindxc + offsetindxc, __nindxp + offsetindxp, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, __failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, __failed ? JNI_ABORT : 0);
  if (__nindxc) (*env)->ReleasePrimitiveArrayCritical(env, indxc, __nindxc, __failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed3_)(int *k, int *n, int *n1, float *d, float *q, int *ldq, float *rho, float *dlamda, float *q2, int *indx, int *ctot, float *w, float *s, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed3K(JNIEnv *env, UNUSED jobject obj, jint k, jint n, jint n1, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloat rho, jfloatArray dlamda, jint offsetdlamda, jfloatArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray ctot, jint offsetctot, jfloatArray w, jint offsetw, jfloatArray s, jint offsets, jobject info) {
  if (!slaed3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  float *__ndlamda = NULL;
  float *__nq2 = NULL;
  int *__nindx = NULL;
  int *__nctot = NULL;
  float *__nw = NULL;
  float *__ns = NULL;
  __nk = k;
  __nn = n;
  __nn1 = n1;
  __nldq = ldq;
  __nrho = rho;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slaed3_(&__nk, &__nn, &__nn1, __nd + offsetd, __nq + offsetq, &__nldq, &__nrho, __ndlamda + offsetdlamda, __nq2 + offsetq2, __nindx + offsetindx, __nctot + offsetctot, __nw + offsetw, __ns + offsets, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, __failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed4_)(int *n, int *i, float *d, float *z, float *delta, float *rho, float *dlam, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dlam, jobject info) {
  if (!slaed4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ni __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  float __ndlam = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__ndelta = NULL;
  __nn = n;
  __ni = i;
  __nrho = rho;
  __ndlam = (*env)->GetFloatField(env, dlam, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  slaed4_(&__nn, &__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndlam, &__ninfo);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, dlam, floatW_val_fieldID, __ndlam);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed5_)(int *i, float *d, float *z, float *delta, float *rho, float *dlam);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed5K(JNIEnv *env, UNUSED jobject obj, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dlam) {
  if (!slaed5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  float __ndlam = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__ndelta = NULL;
  __ni = i;
  __nrho = rho;
  __ndlam = (*env)->GetFloatField(env, dlam, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  slaed5_(&__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndlam);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, dlam, floatW_val_fieldID, __ndlam);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed6_)(int *kniter, int *orgati, float *rho, float *d, float *z, float *finit, float *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed6K(JNIEnv *env, UNUSED jobject obj, jint kniter, jboolean orgati, jfloat rho, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloat finit, jobject tau, jobject info) {
  if (!slaed6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nkniter __attribute__((aligned(8)));
  int __norgati __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  float __nfinit __attribute__((aligned(8)));
  float __ntau = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  __nkniter = kniter;
  __norgati = orgati;
  __nrho = rho;
  __nfinit = finit;
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slaed6_(&__nkniter, &__norgati, &__nrho, __nd + offsetd, __nz + offsetz, &__nfinit, &__ntau, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed7_)(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed7(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed7_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint n, jint qsiz, jint tlvls, jint curlvl, jint curpbm, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray qstore, jint offsetqstore, jintArray qptr, jint offsetqptr, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slaed7_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __ntlvls __attribute__((aligned(8)));
  int __ncurlvl __attribute__((aligned(8)));
  int __ncurpbm __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  int *__nindxq = NULL;
  float *__nqstore = NULL;
  int *__nqptr = NULL;
  int *__nprmptr = NULL;
  int *__nperm = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nn = n;
  __nqsiz = qsiz;
  __ntlvls = tlvls;
  __ncurlvl = curlvl;
  __ncurpbm = curpbm;
  __nldq = ldq;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ncutpnt = cutpnt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slaed7_(&__nicompq, &__nn, &__nqsiz, &__ntlvls, &__ncurlvl, &__ncurpbm, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nqstore + offsetqstore, __nqptr + offsetqptr, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, __failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, __failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed8_)(int *icompq, int *k, int *n, int *qsiz, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *z, float *dlamda, float *q2, int *ldq2, float *w, int *perm, int *givptr, int *givcol, float *givnum, int *indxp, int *indx, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed8(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed8_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jobject k, jint n, jint qsiz, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray z, jint offsetz, jfloatArray dlamda, jint offsetdlamda, jfloatArray q2, jint offsetq2, jint ldq2, jfloatArray w, jint offsetw, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jintArray indxp, jint offsetindxp, jintArray indx, jint offsetindx, jobject info) {
  if (!slaed8_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nk = 0;
  int __nn __attribute__((aligned(8)));
  int __nqsiz __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho = 0;
  int __ncutpnt __attribute__((aligned(8)));
  int __nldq2 __attribute__((aligned(8)));
  int __ngivptr = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  int *__nindxq = NULL;
  float *__nz = NULL;
  float *__ndlamda = NULL;
  float *__nq2 = NULL;
  float *__nw = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  int *__nindxp = NULL;
  int *__nindx = NULL;
  __nicompq = icompq;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nn = n;
  __nqsiz = qsiz;
  __nldq = ldq;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ncutpnt = cutpnt;
  __nldq2 = ldq2;
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) { __failed = TRUE; goto done; }
  slaed8_(&__nicompq, &__nk, &__nn, &__nqsiz, __nd + offsetd, __nq + offsetq, &__nldq, __nindxq + offsetindxq, &__nrho, &__ncutpnt, __nz + offsetz, __ndlamda + offsetdlamda, __nq2 + offsetq2, &__nldq2, __nw + offsetw, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nindxp + offsetindxp, __nindx + offsetindx, &__ninfo);
done:
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, __failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaed9_)(int *k, int *kstart, int *kstop, int *n, float *d, float *q, int *ldq, float *rho, float *dlamda, float *w, float *s, int *lds, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaed9(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaed9_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed9K(JNIEnv *env, UNUSED jobject obj, jint k, jint kstart, jint kstop, jint n, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloat rho, jfloatArray dlamda, jint offsetdlamda, jfloatArray w, jint offsetw, jfloatArray s, jint offsets, jint lds, jobject info) {
  if (!slaed9_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nk __attribute__((aligned(8)));
  int __nkstart __attribute__((aligned(8)));
  int __nkstop __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  int __nlds __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  float *__ndlamda = NULL;
  float *__nw = NULL;
  float *__ns = NULL;
  __nk = k;
  __nkstart = kstart;
  __nkstop = kstop;
  __nn = n;
  __nldq = ldq;
  __nrho = rho;
  __nlds = lds;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slaed9_(&__nk, &__nkstart, &__nkstop, &__nn, __nd + offsetd, __nq + offsetq, &__nldq, &__nrho, __ndlamda + offsetdlamda, __nw + offsetw, __ns + offsets, &__nlds, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaeda_)(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *q, int *qptr, float *z, float *ztemp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaeda(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaeda_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaedaK(JNIEnv *env, UNUSED jobject obj, jint n, jint tlvls, jint curlvl, jint curpbm, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jfloatArray q, jint offsetq, jintArray qptr, jint offsetqptr, jfloatArray z, jint offsetz, jfloatArray ztemp, jint offsetztemp, jobject info) {
  if (!slaeda_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ntlvls __attribute__((aligned(8)));
  int __ncurlvl __attribute__((aligned(8)));
  int __ncurpbm __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nprmptr = NULL;
  int *__nperm = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  float *__nq = NULL;
  int *__nqptr = NULL;
  float *__nz = NULL;
  float *__nztemp = NULL;
  __nn = n;
  __ntlvls = tlvls;
  __ncurlvl = curlvl;
  __ncurpbm = curpbm;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nztemp = (*env)->GetPrimitiveArrayCritical(env, ztemp, NULL))) { __failed = TRUE; goto done; }
  slaeda_(&__nn, &__ntlvls, &__ncurlvl, &__ncurpbm, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nq + offsetq, __nqptr + offsetqptr, __nz + offsetz, __nztemp + offsetztemp, &__ninfo);
done:
  if (__nztemp) (*env)->ReleasePrimitiveArrayCritical(env, ztemp, __nztemp, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaein_)(int *rightv, int *noinit, int *n, float *h, int *ldh, float *wr, float *wi, float *vr, float *vi, float *b, int *ldb, float *work, float *eps3, float *smlnum, float *bignum, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaeinK(JNIEnv *env, UNUSED jobject obj, jboolean rightv, jboolean noinit, jint n, jfloatArray h, jint offseth, jint ldh, jfloat wr, jfloat wi, jfloatArray vr, jint offsetvr, jfloatArray vi, jint offsetvi, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jfloat eps3, jfloat smlnum, jfloat bignum, jobject info) {
  if (!slaein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nrightv __attribute__((aligned(8)));
  int __nnoinit __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  float __nwr __attribute__((aligned(8)));
  float __nwi __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __neps3 __attribute__((aligned(8)));
  float __nsmlnum __attribute__((aligned(8)));
  float __nbignum __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nvr = NULL;
  float *__nvi = NULL;
  float *__nb = NULL;
  float *__nwork = NULL;
  __nrightv = rightv;
  __nnoinit = noinit;
  __nn = n;
  __nldh = ldh;
  __nwr = wr;
  __nwi = wi;
  __nldb = ldb;
  __neps3 = eps3;
  __nsmlnum = smlnum;
  __nbignum = bignum;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvi = (*env)->GetPrimitiveArrayCritical(env, vi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaein_(&__nrightv, &__nnoinit, &__nn, __nh + offseth, &__nldh, &__nwr, &__nwi, __nvr + offsetvr, __nvi + offsetvi, __nb + offsetb, &__nldb, __nwork + offsetwork, &__neps3, &__nsmlnum, &__nbignum, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nvi) (*env)->ReleasePrimitiveArrayCritical(env, vi, __nvi, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaev2_)(float *a, float *b, float *c, float *rt1, float *rt2, float *cs1, float *sn1);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaev2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaev2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaev2K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jobject rt1, jobject rt2, jobject cs1, jobject sn1) {
  if (!slaev2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __na __attribute__((aligned(8)));
  float __nb __attribute__((aligned(8)));
  float __nc __attribute__((aligned(8)));
  float __nrt1 = 0;
  float __nrt2 = 0;
  float __ncs1 = 0;
  float __nsn1 = 0;
  __na = a;
  __nb = b;
  __nc = c;
  __nrt1 = (*env)->GetFloatField(env, rt1, floatW_val_fieldID);
  __nrt2 = (*env)->GetFloatField(env, rt2, floatW_val_fieldID);
  __ncs1 = (*env)->GetFloatField(env, cs1, floatW_val_fieldID);
  __nsn1 = (*env)->GetFloatField(env, sn1, floatW_val_fieldID);
  slaev2_(&__na, &__nb, &__nc, &__nrt1, &__nrt2, &__ncs1, &__nsn1);
done:
  if (!__failed) (*env)->SetFloatField(env, sn1, floatW_val_fieldID, __nsn1);
  if (!__failed) (*env)->SetFloatField(env, cs1, floatW_val_fieldID, __ncs1);
  if (!__failed) (*env)->SetFloatField(env, rt2, floatW_val_fieldID, __nrt2);
  if (!__failed) (*env)->SetFloatField(env, rt1, floatW_val_fieldID, __nrt1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaexc_)(int *wantq, int *n, float *t, int *ldt, float *q, int *ldq, int *j1, int *n1, int *n2, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jint j1, jint n1, jint n2, jfloatArray work, jint offsetwork, jobject info) {
  if (!slaexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nj1 __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nt = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  __nwantq = wantq;
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nj1 = j1;
  __nn1 = n1;
  __nn2 = n2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaexc_(&__nwantq, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, &__nj1, &__nn1, &__nn2, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slag2_)(float *a, int *lda, float *b, int *ldb, float *safmin, float *scale1, float *scale2, float *wr1, float *wr2, float *wi);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slag2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slag2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slag2K(JNIEnv *env, UNUSED jobject obj, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat safmin, jobject scale1, jobject scale2, jobject wr1, jobject wr2, jobject wi) {
  if (!slag2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nsafmin __attribute__((aligned(8)));
  float __nscale1 = 0;
  float __nscale2 = 0;
  float __nwr1 = 0;
  float __nwr2 = 0;
  float __nwi = 0;
  float *__na = NULL;
  float *__nb = NULL;
  __nlda = lda;
  __nldb = ldb;
  __nsafmin = safmin;
  __nscale1 = (*env)->GetFloatField(env, scale1, floatW_val_fieldID);
  __nscale2 = (*env)->GetFloatField(env, scale2, floatW_val_fieldID);
  __nwr1 = (*env)->GetFloatField(env, wr1, floatW_val_fieldID);
  __nwr2 = (*env)->GetFloatField(env, wr2, floatW_val_fieldID);
  __nwi = (*env)->GetFloatField(env, wi, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  slag2_(__na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nsafmin, &__nscale1, &__nscale2, &__nwr1, &__nwr2, &__nwi);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, wi, floatW_val_fieldID, __nwi);
  if (!__failed) (*env)->SetFloatField(env, wr2, floatW_val_fieldID, __nwr2);
  if (!__failed) (*env)->SetFloatField(env, wr1, floatW_val_fieldID, __nwr1);
  if (!__failed) (*env)->SetFloatField(env, scale2, floatW_val_fieldID, __nscale2);
  if (!__failed) (*env)->SetFloatField(env, scale1, floatW_val_fieldID, __nscale1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slag2d_)(int *m, int *n, float *sa, int *ldsa, double *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slag2d(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slag2d_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slag2dK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray sa, jint offsetsa, jint ldsa, jdoubleArray a, jint offseta, jint lda, jobject info) {
  if (!slag2d_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldsa __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nsa = NULL;
  double *__na = NULL;
  __nm = m;
  __nn = n;
  __nldsa = ldsa;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nsa = (*env)->GetPrimitiveArrayCritical(env, sa, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slag2d_(&__nm, &__nn, __nsa + offsetsa, &__nldsa, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nsa) (*env)->ReleasePrimitiveArrayCritical(env, sa, __nsa, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slags2_)(int *upper, float *a1, float *a2, float *a3, float *b1, float *b2, float *b3, float *csu, float *snu, float *csv, float *snv, float *csq, float *snq);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slags2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slags2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slags2K(JNIEnv *env, UNUSED jobject obj, jboolean upper, jfloat a1, jfloat a2, jfloat a3, jfloat b1, jfloat b2, jfloat b3, jobject csu, jobject snu, jobject csv, jobject snv, jobject csq, jobject snq) {
  if (!slags2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nupper __attribute__((aligned(8)));
  float __na1 __attribute__((aligned(8)));
  float __na2 __attribute__((aligned(8)));
  float __na3 __attribute__((aligned(8)));
  float __nb1 __attribute__((aligned(8)));
  float __nb2 __attribute__((aligned(8)));
  float __nb3 __attribute__((aligned(8)));
  float __ncsu = 0;
  float __nsnu = 0;
  float __ncsv = 0;
  float __nsnv = 0;
  float __ncsq = 0;
  float __nsnq = 0;
  __nupper = upper;
  __na1 = a1;
  __na2 = a2;
  __na3 = a3;
  __nb1 = b1;
  __nb2 = b2;
  __nb3 = b3;
  __ncsu = (*env)->GetFloatField(env, csu, floatW_val_fieldID);
  __nsnu = (*env)->GetFloatField(env, snu, floatW_val_fieldID);
  __ncsv = (*env)->GetFloatField(env, csv, floatW_val_fieldID);
  __nsnv = (*env)->GetFloatField(env, snv, floatW_val_fieldID);
  __ncsq = (*env)->GetFloatField(env, csq, floatW_val_fieldID);
  __nsnq = (*env)->GetFloatField(env, snq, floatW_val_fieldID);
  slags2_(&__nupper, &__na1, &__na2, &__na3, &__nb1, &__nb2, &__nb3, &__ncsu, &__nsnu, &__ncsv, &__nsnv, &__ncsq, &__nsnq);
done:
  if (!__failed) (*env)->SetFloatField(env, snq, floatW_val_fieldID, __nsnq);
  if (!__failed) (*env)->SetFloatField(env, csq, floatW_val_fieldID, __ncsq);
  if (!__failed) (*env)->SetFloatField(env, snv, floatW_val_fieldID, __nsnv);
  if (!__failed) (*env)->SetFloatField(env, csv, floatW_val_fieldID, __ncsv);
  if (!__failed) (*env)->SetFloatField(env, snu, floatW_val_fieldID, __nsnu);
  if (!__failed) (*env)->SetFloatField(env, csu, floatW_val_fieldID, __ncsu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slagtf_)(int *n, float *a, float *lambda, float *b, float *c, float *tol, float *d, int *in, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slagtf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slagtf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jfloat lambda, jfloatArray b, jint offsetb, jfloatArray c, jint offsetc, jfloat tol, jfloatArray d, jint offsetd, jintArray in, jint offsetin, jobject info) {
  if (!slagtf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nlambda __attribute__((aligned(8)));
  float __ntol __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  float *__nd = NULL;
  int *__nin = NULL;
  __nn = n;
  __nlambda = lambda;
  __ntol = tol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) { __failed = TRUE; goto done; }
  slagtf_(&__nn, __na + offseta, &__nlambda, __nb + offsetb, __nc + offsetc, &__ntol, __nd + offsetd, __nin + offsetin, &__ninfo);
done:
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slagtm_)(const char *trans, int *n, int *nrhs, float *alpha, float *dl, float *d, float *du, float *x, int *ldx, float *beta, float *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slagtm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slagtm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtmK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloat alpha, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray x, jint offsetx, jint ldx, jfloat beta, jfloatArray b, jint offsetb, jint ldb) {
  if (!slagtm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  float __nalpha __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nbeta __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  float *__nx = NULL;
  float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nalpha = alpha;
  __nldx = ldx;
  __nbeta = beta;
  __nldb = ldb;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  slagtm_(__ntrans, &__nn, &__nnrhs, &__nalpha, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nx + offsetx, &__nldx, &__nbeta, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slagts_)(int *job, int *n, float *a, float *b, float *c, float *d, int *in, float *y, float *tol, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slagts(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slagts_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtsK(JNIEnv *env, UNUSED jobject obj, jint job, jint n, jfloatArray a, jint offseta, jfloatArray b, jint offsetb, jfloatArray c, jint offsetc, jfloatArray d, jint offsetd, jintArray in, jint offsetin, jfloatArray y, jint offsety, jobject tol, jobject info) {
  if (!slagts_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __njob __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  float __ntol = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  float *__nd = NULL;
  int *__nin = NULL;
  float *__ny = NULL;
  __njob = job;
  __nn = n;
  __ntol = (*env)->GetFloatField(env, tol, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  slagts_(&__njob, &__nn, __na + offseta, __nb + offsetb, __nc + offsetc, __nd + offsetd, __nin + offsetin, __ny + offsety, &__ntol, &__ninfo);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, tol, floatW_val_fieldID, __ntol);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slagv2_)(float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *csl, float *snl, float *csr, float *snr);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slagv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slagv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagv2K(JNIEnv *env, UNUSED jobject obj, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jobject csl, jobject snl, jobject csr, jobject snr) {
  if (!slagv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __ncsl = 0;
  float __nsnl = 0;
  float __ncsr = 0;
  float __nsnr = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  __nlda = lda;
  __nldb = ldb;
  __ncsl = (*env)->GetFloatField(env, csl, floatW_val_fieldID);
  __nsnl = (*env)->GetFloatField(env, snl, floatW_val_fieldID);
  __ncsr = (*env)->GetFloatField(env, csr, floatW_val_fieldID);
  __nsnr = (*env)->GetFloatField(env, snr, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  slagv2_(__na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, &__ncsl, &__nsnl, &__ncsr, &__nsnr);
done:
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, snr, floatW_val_fieldID, __nsnr);
  if (!__failed) (*env)->SetFloatField(env, csr, floatW_val_fieldID, __ncsr);
  if (!__failed) (*env)->SetFloatField(env, snl, floatW_val_fieldID, __nsnl);
  if (!__failed) (*env)->SetFloatField(env, csl, floatW_val_fieldID, __ncsl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slahqr_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slahqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slahqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahqrK(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject info) {
  if (!slahqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nz = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slahqr_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slahr2_)(int *n, int *k, int *nb, float *a, int *lda, float *tau, float *t, int *ldt, float *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slahr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slahr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahr2K(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt, jfloatArray y, jint offsety, jint ldy) {
  if (!slahr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nt = NULL;
  float *__ny = NULL;
  __nn = n;
  __nk = k;
  __nnb = nb;
  __nlda = lda;
  __nldt = ldt;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  slahr2_(&__nn, &__nk, &__nnb, __na + offseta, &__nlda, __ntau + offsettau, __nt + offsett, &__nldt, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slahrd_)(int *n, int *k, int *nb, float *a, int *lda, float *tau, float *t, int *ldt, float *y, int *ldy);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slahrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slahrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt, jfloatArray y, jint offsety, jint ldy) {
  if (!slahrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldy __attribute__((aligned(8)));
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nt = NULL;
  float *__ny = NULL;
  __nn = n;
  __nk = k;
  __nnb = nb;
  __nlda = lda;
  __nldt = ldt;
  __nldy = ldy;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  slahrd_(&__nn, &__nk, &__nnb, __na + offseta, &__nlda, __ntau + offsettau, __nt + offsett, &__nldt, __ny + offsety, &__nldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaic1_)(int *job, int *j, float *x, float *sest, float *w, float *gamma, float *sestpr, float *s, float *c);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaic1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaic1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaic1K(JNIEnv *env, UNUSED jobject obj, jint job, jint j, jfloatArray x, jint offsetx, jfloat sest, jfloatArray w, jint offsetw, jfloat gamma, jobject sestpr, jobject s, jobject c) {
  if (!slaic1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __njob __attribute__((aligned(8)));
  int __nj __attribute__((aligned(8)));
  float __nsest __attribute__((aligned(8)));
  float __ngamma __attribute__((aligned(8)));
  float __nsestpr = 0;
  float __ns = 0;
  float __nc = 0;
  float *__nx = NULL;
  float *__nw = NULL;
  __njob = job;
  __nj = j;
  __nsest = sest;
  __ngamma = gamma;
  __nsestpr = (*env)->GetFloatField(env, sestpr, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  slaic1_(&__njob, &__nj, __nx + offsetx, &__nsest, __nw + offsetw, &__ngamma, &__nsestpr, &__ns, &__nc);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!__failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!__failed) (*env)->SetFloatField(env, sestpr, floatW_val_fieldID, __nsestpr);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*slaisnan_)(float *sin1, float *sin2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaisnan(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaisnan_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_slaisnanK(JNIEnv *env, UNUSED jobject obj, jfloat sin1, jfloat sin2) {
  if (!slaisnan_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  float __nsin1 __attribute__((aligned(8)));
  float __nsin2 __attribute__((aligned(8)));
  __nsin1 = sin1;
  __nsin2 = sin2;
  __ret = slaisnan_(&__nsin1, &__nsin2);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*slaln2_)(int *ltrans, int *na, int *nw, float *smin, float *ca, float *a, int *lda, float *d1, float *d2, float *b, int *ldb, float *wr, float *wi, float *x, int *ldx, float *scale, float *xnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaln2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaln2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaln2K(JNIEnv *env, UNUSED jobject obj, jboolean ltrans, jint na, jint nw, jfloat smin, jfloat ca, jfloatArray a, jint offseta, jint lda, jfloat d1, jfloat d2, jfloatArray b, jint offsetb, jint ldb, jfloat wr, jfloat wi, jfloatArray x, jint offsetx, jint ldx, jobject scale, jobject xnorm, jobject info) {
  if (!slaln2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltrans __attribute__((aligned(8)));
  int __nna __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  float __nsmin __attribute__((aligned(8)));
  float __nca __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nd1 __attribute__((aligned(8)));
  float __nd2 __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nwr __attribute__((aligned(8)));
  float __nwi __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nscale = 0;
  float __nxnorm = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  __nltrans = ltrans;
  __nna = na;
  __nnw = nw;
  __nsmin = smin;
  __nca = ca;
  __nlda = lda;
  __nd1 = d1;
  __nd2 = d2;
  __nldb = ldb;
  __nwr = wr;
  __nwi = wi;
  __nldx = ldx;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nxnorm = (*env)->GetFloatField(env, xnorm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slaln2_(&__nltrans, &__nna, &__nnw, &__nsmin, &__nca, __na + offseta, &__nlda, &__nd1, &__nd2, __nb + offsetb, &__nldb, &__nwr, &__nwi, __nx + offsetx, &__nldx, &__nscale, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, xnorm, floatW_val_fieldID, __nxnorm);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slals0_)(int *icompq, int *nl, int *nr, int *sqre, int *nrhs, float *b, int *ldb, float *bx, int *ldbx, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *poles, float *difl, float *difr, float *z, int *k, float *c, float *s, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slals0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slals0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slals0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jint nrhs, jfloatArray b, jint offsetb, jint ldb, jfloatArray bx, jint offsetbx, jint ldbx, jintArray perm, jint offsetperm, jint givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jfloatArray poles, jint offsetpoles, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jint k, jfloat c, jfloat s, jfloatArray work, jint offsetwork, jobject info) {
  if (!slals0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldbx __attribute__((aligned(8)));
  int __ngivptr __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  float __nc __attribute__((aligned(8)));
  float __ns __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nb = NULL;
  float *__nbx = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  float *__npoles = NULL;
  float *__ndifl = NULL;
  float *__ndifr = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldbx = ldbx;
  __ngivptr = givptr;
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nk = k;
  __nc = c;
  __ns = s;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slals0_(&__nicompq, &__nnl, &__nnr, &__nsqre, &__nnrhs, __nb + offsetb, &__nldb, __nbx + offsetbx, &__nldbx, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slalsa_)(int *icompq, int *smlsiz, int *n, int *nrhs, float *b, int *ldb, float *bx, int *ldbx, float *u, int *ldu, float *vt, int *k, float *difl, float *difr, float *z, float *poles, int *givptr, int *givcol, int *ldgcol, int *perm, float *givnum, float *c, float *s, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slalsa(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slalsa_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slalsaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint nrhs, jfloatArray b, jint offsetb, jint ldb, jfloatArray bx, jint offsetbx, jint ldbx, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jintArray k, jint offsetk, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jfloatArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jfloatArray givnum, jint offsetgivnum, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slalsa_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldbx __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nb = NULL;
  float *__nbx = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  int *__nk = NULL;
  float *__ndifl = NULL;
  float *__ndifr = NULL;
  float *__nz = NULL;
  float *__npoles = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  int *__nperm = NULL;
  float *__ngivnum = NULL;
  float *__nc = NULL;
  float *__ns = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nsmlsiz = smlsiz;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldbx = ldbx;
  __nldu = ldu;
  __nldgcol = ldgcol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slalsa_(&__nicompq, &__nsmlsiz, &__nn, &__nnrhs, __nb + offsetb, &__nldb, __nbx + offsetbx, &__nldbx, __nu + offsetu, &__nldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &__nldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slalsd_)(const char *uplo, int *smlsiz, int *n, int *nrhs, float *d, float *e, float *b, int *ldb, float *rcond, int *rank, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slalsd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slalsd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slalsdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint smlsiz, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slalsd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nrcond __attribute__((aligned(8)));
  int __nrank = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nb = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nsmlsiz = smlsiz;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nrcond = rcond;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slalsd_(__nuplo, &__nsmlsiz, &__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__nrcond, &__nrank, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slamrg_)(int *n1, int *n2, float *a, int *strd1, int *strd2, int *index);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamrg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slamrg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamrgK(JNIEnv *env, UNUSED jobject obj, jint n1, jint n2, jfloatArray a, jint offseta, jint strd1, jint strd2, jintArray index, jint offsetindex) {
  if (!slamrg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nstrd1 __attribute__((aligned(8)));
  int __nstrd2 __attribute__((aligned(8)));
  float *__na = NULL;
  int *__nindex = NULL;
  __nn1 = n1;
  __nn2 = n2;
  __nstrd1 = strd1;
  __nstrd2 = strd2;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindex = (*env)->GetPrimitiveArrayCritical(env, index, NULL))) { __failed = TRUE; goto done; }
  slamrg_(&__nn1, &__nn2, __na + offseta, &__nstrd1, &__nstrd2, __nindex + offsetindex);
done:
  if (__nindex) (*env)->ReleasePrimitiveArrayCritical(env, index, __nindex, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static int (*slaneg_)(int *n, float *d, float *lld, float *sigma, float *pivmin, int *r);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaneg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaneg_ != NULL;
}

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_slanegK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray lld, jint offsetlld, jfloat sigma, jfloat pivmin, jint r) {
  if (!slaneg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jint __ret = 0;
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nsigma __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  int __nr __attribute__((aligned(8)));
  float *__nd = NULL;
  float *__nlld = NULL;
  __nn = n;
  __nsigma = sigma;
  __npivmin = pivmin;
  __nr = r;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  __ret = slaneg_(&__nn, __nd + offsetd, __nlld + offsetlld, &__nsigma, &__npivmin, &__nr);
done:
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slangb_)(const char *norm, int *n, int *kl, int *ku, float *ab, int *ldab, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slangb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slangb_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  if (!slangb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float *__nab = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slangb_(__nnorm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slange_)(const char *norm, int *m, int *n, float *a, int *lda, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slange(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slange_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangeK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  if (!slange_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slange_(__nnorm, &__nm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slangt_)(const char *norm, int *n, float *dl, float *d, float *du);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slangt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slangt_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangtK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu) {
  if (!slangt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  float *__ndl = NULL;
  float *__nd = NULL;
  float *__ndu = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) { __failed = TRUE; goto done; }
  __ret = slangt_(__nnorm, &__nn, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu);
done:
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slanhs_)(const char *norm, int *n, float *a, int *lda, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slanhs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slanhs_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanhsK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  if (!slanhs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slanhs_(__nnorm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slansb_)(const char *norm, const char *uplo, int *n, int *k, float *ab, int *ldab, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slansb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slansb_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slansbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jint k, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  if (!slansb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float *__nab = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slansb_(__nnorm, __nuplo, &__nn, &__nk, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slansp_)(const char *norm, const char *uplo, int *n, float *ap, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slansp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slansp_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanspK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray work, jint offsetwork) {
  if (!slansp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float *__nap = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slansp_(__nnorm, __nuplo, &__nn, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slanst_)(const char *norm, int *n, float *d, float *e);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slanst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slanst_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanstK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete) {
  if (!slanst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  int __nn __attribute__((aligned(8)));
  float *__nd = NULL;
  float *__ne = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  __ret = slanst_(__nnorm, &__nn, __nd + offsetd, __ne + offsete);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slansy_)(const char *norm, const char *uplo, int *n, float *a, int *lda, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slansy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slansy_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slansyK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  if (!slansy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slansy_(__nnorm, __nuplo, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slantb_)(const char *norm, const char *uplo, const char *diag, int *n, int *k, float *ab, int *ldab, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slantb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slantb_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint k, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  if (!slantb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float *__nab = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldab = ldab;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slantb_(__nnorm, __nuplo, __ndiag, &__nn, &__nk, __nab + offsetab, &__nldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slantp_)(const char *norm, const char *uplo, const char *diag, int *n, float *ap, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slantp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slantp_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantpK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jfloatArray work, jint offsetwork) {
  if (!slantp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  float *__nap = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slantp_(__nnorm, __nuplo, __ndiag, &__nn, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slantr_)(const char *norm, const char *uplo, const char *diag, int *m, int *n, float *a, int *lda, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slantr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slantr_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantrK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  if (!slantr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  __ret = slantr_(__nnorm, __nuplo, __ndiag, &__nm, &__nn, __na + offseta, &__nlda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*slanv2_)(float *a, float *b, float *c, float *d, float *rt1r, float *rt1i, float *rt2r, float *rt2i, float *cs, float *sn);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slanv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slanv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slanv2K(JNIEnv *env, UNUSED jobject obj, jobject a, jobject b, jobject c, jobject d, jobject rt1r, jobject rt1i, jobject rt2r, jobject rt2i, jobject cs, jobject sn) {
  if (!slanv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __na = 0;
  float __nb = 0;
  float __nc = 0;
  float __nd = 0;
  float __nrt1r = 0;
  float __nrt1i = 0;
  float __nrt2r = 0;
  float __nrt2i = 0;
  float __ncs = 0;
  float __nsn = 0;
  __na = (*env)->GetFloatField(env, a, floatW_val_fieldID);
  __nb = (*env)->GetFloatField(env, b, floatW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __nd = (*env)->GetFloatField(env, d, floatW_val_fieldID);
  __nrt1r = (*env)->GetFloatField(env, rt1r, floatW_val_fieldID);
  __nrt1i = (*env)->GetFloatField(env, rt1i, floatW_val_fieldID);
  __nrt2r = (*env)->GetFloatField(env, rt2r, floatW_val_fieldID);
  __nrt2i = (*env)->GetFloatField(env, rt2i, floatW_val_fieldID);
  __ncs = (*env)->GetFloatField(env, cs, floatW_val_fieldID);
  __nsn = (*env)->GetFloatField(env, sn, floatW_val_fieldID);
  slanv2_(&__na, &__nb, &__nc, &__nd, &__nrt1r, &__nrt1i, &__nrt2r, &__nrt2i, &__ncs, &__nsn);
done:
  if (!__failed) (*env)->SetFloatField(env, sn, floatW_val_fieldID, __nsn);
  if (!__failed) (*env)->SetFloatField(env, cs, floatW_val_fieldID, __ncs);
  if (!__failed) (*env)->SetFloatField(env, rt2i, floatW_val_fieldID, __nrt2i);
  if (!__failed) (*env)->SetFloatField(env, rt2r, floatW_val_fieldID, __nrt2r);
  if (!__failed) (*env)->SetFloatField(env, rt1i, floatW_val_fieldID, __nrt1i);
  if (!__failed) (*env)->SetFloatField(env, rt1r, floatW_val_fieldID, __nrt1r);
  if (!__failed) (*env)->SetFloatField(env, d, floatW_val_fieldID, __nd);
  if (!__failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!__failed) (*env)->SetFloatField(env, b, floatW_val_fieldID, __nb);
  if (!__failed) (*env)->SetFloatField(env, a, floatW_val_fieldID, __na);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slapll_)(int *n, float *x, int *incx, float *y, int *incy, float *ssmin);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slapll(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slapll_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slapllK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jobject ssmin) {
  if (!slapll_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  float __nssmin = 0;
  float *__nx = NULL;
  float *__ny = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  slapll_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, &__nssmin);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slapmt_)(int *forwrd, int *m, int *n, float *x, int *ldx, int *k);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slapmt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slapmt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slapmtK(JNIEnv *env, UNUSED jobject obj, jboolean forwrd, jint m, jint n, jfloatArray x, jint offsetx, jint ldx, jintArray k, jint offsetk) {
  if (!slapmt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nforwrd __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float *__nx = NULL;
  int *__nk = NULL;
  __nforwrd = forwrd;
  __nm = m;
  __nn = n;
  __nldx = ldx;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  slapmt_(&__nforwrd, &__nm, &__nn, __nx + offsetx, &__nldx, __nk + offsetk);
done:
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static float (*slapy2_)(float *x, float *y);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slapy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slapy2_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slapy2K(JNIEnv *env, UNUSED jobject obj, jfloat x, jfloat y) {
  if (!slapy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  float __nx __attribute__((aligned(8)));
  float __ny __attribute__((aligned(8)));
  __nx = x;
  __ny = y;
  __ret = slapy2_(&__nx, &__ny);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slapy3_)(float *x, float *y, float *z);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slapy3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slapy3_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slapy3K(JNIEnv *env, UNUSED jobject obj, jfloat x, jfloat y, jfloat z) {
  if (!slapy3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  float __nx __attribute__((aligned(8)));
  float __ny __attribute__((aligned(8)));
  float __nz __attribute__((aligned(8)));
  __nx = x;
  __ny = y;
  __nz = z;
  __ret = slapy3_(&__nx, &__ny, &__nz);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static void (*slaqgb_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqgb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqgb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqgbK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloat rowcnd, jfloat colcnd, jfloat amax, jobject equed) {
  if (!slaqgb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nrowcnd __attribute__((aligned(8)));
  float __ncolcnd __attribute__((aligned(8)));
  float __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  float *__nab = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  __nm = m;
  __nn = n;
  __nkl = kl;
  __nku = ku;
  __nldab = ldab;
  __nrowcnd = rowcnd;
  __ncolcnd = colcnd;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  slaqgb_(&__nm, &__nn, &__nkl, &__nku, __nab + offsetab, &__nldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqge_)(int *m, int *n, float *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqge(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqge_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqgeK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloat rowcnd, jfloat colcnd, jfloat amax, jobject equed) {
  if (!slaqge_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nrowcnd __attribute__((aligned(8)));
  float __ncolcnd __attribute__((aligned(8)));
  float __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  float *__na = NULL;
  float *__nr = NULL;
  float *__nc = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nrowcnd = rowcnd;
  __ncolcnd = colcnd;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  slaqge_(&__nm, &__nn, __na + offseta, &__nlda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqp2_)(int *m, int *n, int *offset, float *a, int *lda, int *jpvt, float *tau, float *vn1, float *vn2, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqp2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqp2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqp2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray vn1, jint offsetvn1, jfloatArray vn2, jint offsetvn2, jfloatArray work, jint offsetwork) {
  if (!slaqp2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  int *__njpvt = NULL;
  float *__ntau = NULL;
  float *__nvn1 = NULL;
  float *__nvn2 = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __noffset = offset;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqp2_(&__nm, &__nn, &__noffset, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, __failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqps_)(int *m, int *n, int *offset, int *nb, int *kb, float *a, int *lda, int *jpvt, float *tau, float *vn1, float *vn2, float *auxv, float *f, int *ldf);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqps(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqps_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqpsK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jint nb, jobject kb, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray vn1, jint offsetvn1, jfloatArray vn2, jint offsetvn2, jfloatArray auxv, jint offsetauxv, jfloatArray f, jint offsetf, jint ldf) {
  if (!slaqps_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nkb = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  float *__na = NULL;
  int *__njpvt = NULL;
  float *__ntau = NULL;
  float *__nvn1 = NULL;
  float *__nvn2 = NULL;
  float *__nauxv = NULL;
  float *__nf = NULL;
  __nm = m;
  __nn = n;
  __noffset = offset;
  __nnb = nb;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __nlda = lda;
  __nldf = ldf;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nauxv = (*env)->GetPrimitiveArrayCritical(env, auxv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  slaqps_(&__nm, &__nn, &__noffset, &__nnb, &__nkb, __na + offseta, &__nlda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nauxv + offsetauxv, __nf + offsetf, &__nldf);
done:
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__nauxv) (*env)->ReleasePrimitiveArrayCritical(env, auxv, __nauxv, __failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, __failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr0_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr0K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!slaqr0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqr0_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr1_)(int *n, float *h, int *ldh, float *sr1, float *si1, float *sr2, float *si2, float *v);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray h, jint offseth, jint ldh, jfloat sr1, jfloat si1, jfloat sr2, jfloat si2, jfloatArray v, jint offsetv) {
  if (!slaqr1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  float __nsr1 __attribute__((aligned(8)));
  float __nsi1 __attribute__((aligned(8)));
  float __nsr2 __attribute__((aligned(8)));
  float __nsi2 __attribute__((aligned(8)));
  float *__nh = NULL;
  float *__nv = NULL;
  __nn = n;
  __nldh = ldh;
  __nsr1 = sr1;
  __nsi1 = si1;
  __nsr2 = sr2;
  __nsi2 = si2;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  slaqr1_(&__nn, __nh + offseth, &__nldh, &__nsr1, &__nsi1, &__nsr2, &__nsi2, __nv + offsetv);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr2_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, int *ns, int *nd, float *sr, float *si, float *v, int *ldv, int *nh, float *t, int *ldt, int *nv, float *wv, int *ldwv, float *work, int *lwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr2K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray v, jint offsetv, jint ldv, jint nh, jfloatArray t, jint offsett, jint ldt, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jfloatArray work, jint offsetwork, jint lwork) {
  if (!slaqr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nns = 0;
  int __nnd = 0;
  int __nldv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  float *__nh = NULL;
  float *__nz = NULL;
  float *__nsr = NULL;
  float *__nsi = NULL;
  float *__nv = NULL;
  float *__nt = NULL;
  float *__nwv = NULL;
  float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnw = nw;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nldv = ldv;
  __nnh = nh;
  __nldt = ldt;
  __nnv = nv;
  __nldwv = ldwv;
  __nlwork = lwork;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqr2_(&__nwantt, &__nwantz, &__nn, &__nktop, &__nkbot, &__nnw, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &__nldv, &__nnh, __nt + offsett, &__nldt, &__nnv, __nwv + offsetwv, &__nldwv, __nwork + offsetwork, &__nlwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr3_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, int *ns, int *nd, float *sr, float *si, float *v, int *ldv, int *nh, float *t, int *ldt, int *nv, float *wv, int *ldwv, float *work, int *lwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr3K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray v, jint offsetv, jint ldv, jint nh, jfloatArray t, jint offsett, jint ldt, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jfloatArray work, jint offsetwork, jint lwork) {
  if (!slaqr3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnw __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nns = 0;
  int __nnd = 0;
  int __nldv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  float *__nh = NULL;
  float *__nz = NULL;
  float *__nsr = NULL;
  float *__nsi = NULL;
  float *__nv = NULL;
  float *__nt = NULL;
  float *__nwv = NULL;
  float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnw = nw;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nldv = ldv;
  __nnh = nh;
  __nldt = ldt;
  __nnv = nv;
  __nldwv = ldwv;
  __nlwork = lwork;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqr3_(&__nwantt, &__nwantz, &__nn, &__nktop, &__nkbot, &__nnw, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &__nldv, &__nnh, __nt + offsett, &__nldt, &__nnv, __nwv + offsetwv, &__nldwv, __nwork + offsetwork, &__nlwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr4_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr4K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!slaqr4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nh = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqr4_(&__nwantt, &__nwantz, &__nn, &__nilo, &__nihi, __nh + offseth, &__nldh, __nwr + offsetwr, __nwi + offsetwi, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqr5_)(int *wantt, int *wantz, int *kacc22, int *n, int *ktop, int *kbot, int *nshfts, float *sr, float *si, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, float *v, int *ldv, float *u, int *ldu, int *nv, float *wv, int *ldwv, int *nh, float *wh, int *ldwh);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqr5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqr5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr5K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint kacc22, jint n, jint ktop, jint kbot, jint nshfts, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray v, jint offsetv, jint ldv, jfloatArray u, jint offsetu, jint ldu, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jint nh, jfloatArray wh, jint offsetwh, jint ldwh) {
  if (!slaqr5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantt __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nkacc22 __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nktop __attribute__((aligned(8)));
  int __nkbot __attribute__((aligned(8)));
  int __nnshfts __attribute__((aligned(8)));
  int __nldh __attribute__((aligned(8)));
  int __niloz __attribute__((aligned(8)));
  int __nihiz __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nnv __attribute__((aligned(8)));
  int __nldwv __attribute__((aligned(8)));
  int __nnh __attribute__((aligned(8)));
  int __nldwh __attribute__((aligned(8)));
  float *__nsr = NULL;
  float *__nsi = NULL;
  float *__nh = NULL;
  float *__nz = NULL;
  float *__nv = NULL;
  float *__nu = NULL;
  float *__nwv = NULL;
  float *__nwh = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nkacc22 = kacc22;
  __nn = n;
  __nktop = ktop;
  __nkbot = kbot;
  __nnshfts = nshfts;
  __nldh = ldh;
  __niloz = iloz;
  __nihiz = ihiz;
  __nldz = ldz;
  __nldv = ldv;
  __nldu = ldu;
  __nnv = nv;
  __nldwv = ldwv;
  __nnh = nh;
  __nldwh = ldwh;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) { __failed = TRUE; goto done; }
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwh = (*env)->GetPrimitiveArrayCritical(env, wh, NULL))) { __failed = TRUE; goto done; }
  slaqr5_(&__nwantt, &__nwantz, &__nkacc22, &__nn, &__nktop, &__nkbot, &__nnshfts, __nsr + offsetsr, __nsi + offsetsi, __nh + offseth, &__nldh, &__niloz, &__nihiz, __nz + offsetz, &__nldz, __nv + offsetv, &__nldv, __nu + offsetu, &__nldu, &__nnv, __nwv + offsetwv, &__nldwv, &__nnh, __nwh + offsetwh, &__nldwh);
done:
  if (__nwh) (*env)->ReleasePrimitiveArrayCritical(env, wh, __nwh, __failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, __failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, __failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqsb_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *s, float *scond, float *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqsb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqsb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqsbK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  if (!slaqsb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nscond __attribute__((aligned(8)));
  float __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  float *__nab = NULL;
  float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slaqsb_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqsp_)(const char *uplo, int *n, float *ap, float *s, float *scond, float *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqsp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqsp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqspK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  if (!slaqsp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nscond __attribute__((aligned(8)));
  float __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  float *__nap = NULL;
  float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slaqsp_(__nuplo, &__nn, __nap + offsetap, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqsy_)(const char *uplo, int *n, float *a, int *lda, float *s, float *scond, float *amax, char *equed);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqsy(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqsy_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqsyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  if (!slaqsy_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nscond __attribute__((aligned(8)));
  float __namax __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  float *__na = NULL;
  float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nscond = scond;
  __namax = amax;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slaqsy_(__nuplo, &__nn, __na + offseta, &__nlda, __ns + offsets, &__nscond, &__namax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaqtr_)(int *ltran, int *lreal, int *n, float *t, int *ldt, float *b, float *w, float *scale, float *x, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaqtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaqtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqtrK(JNIEnv *env, UNUSED jobject obj, jboolean ltran, jboolean lreal, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray b, jint offsetb, jfloat w, jobject scale, jfloatArray x, jint offsetx, jfloatArray work, jint offsetwork, jobject info) {
  if (!slaqtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltran __attribute__((aligned(8)));
  int __nlreal __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  float __nw __attribute__((aligned(8)));
  float __nscale = 0;
  int __ninfo = 0;
  float *__nt = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nwork = NULL;
  __nltran = ltran;
  __nlreal = lreal;
  __nn = n;
  __nldt = ldt;
  __nw = w;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slaqtr_(&__nltran, &__nlreal, &__nn, __nt + offsett, &__nldt, __nb + offsetb, &__nw, &__nscale, __nx + offsetx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slar1v_)(int *n, int *b1, int *bn, float *lambda, float *d, float *l, float *ld, float *lld, float *pivmin, float *gaptol, float *z, int *wantnc, int *negcnt, float *ztz, float *mingma, int *r, int *isuppz, float *nrminv, float *resid, float *rqcorr, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slar1v(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slar1v_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slar1vK(JNIEnv *env, UNUSED jobject obj, jint n, jint b1, jint bn, jfloat lambda, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloatArray ld, jint offsetld, jfloatArray lld, jint offsetlld, jfloat pivmin, jfloat gaptol, jfloatArray z, jint offsetz, jboolean wantnc, jobject negcnt, jobject ztz, jobject mingma, jobject r, jintArray isuppz, jint offsetisuppz, jobject nrminv, jobject resid, jobject rqcorr, jfloatArray work, jint offsetwork) {
  if (!slar1v_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nb1 __attribute__((aligned(8)));
  int __nbn __attribute__((aligned(8)));
  float __nlambda __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  float __ngaptol __attribute__((aligned(8)));
  int __nwantnc __attribute__((aligned(8)));
  int __nnegcnt = 0;
  float __nztz = 0;
  float __nmingma = 0;
  int __nr = 0;
  float __nnrminv = 0;
  float __nresid = 0;
  float __nrqcorr = 0;
  float *__nd = NULL;
  float *__nl = NULL;
  float *__nld = NULL;
  float *__nlld = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nb1 = b1;
  __nbn = bn;
  __nlambda = lambda;
  __npivmin = pivmin;
  __ngaptol = gaptol;
  __nwantnc = wantnc;
  __nnegcnt = (*env)->GetIntField(env, negcnt, intW_val_fieldID);
  __nztz = (*env)->GetFloatField(env, ztz, floatW_val_fieldID);
  __nmingma = (*env)->GetFloatField(env, mingma, floatW_val_fieldID);
  __nr = (*env)->GetIntField(env, r, intW_val_fieldID);
  __nnrminv = (*env)->GetFloatField(env, nrminv, floatW_val_fieldID);
  __nresid = (*env)->GetFloatField(env, resid, floatW_val_fieldID);
  __nrqcorr = (*env)->GetFloatField(env, rqcorr, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slar1v_(&__nn, &__nb1, &__nbn, &__nlambda, __nd + offsetd, __nl + offsetl, __nld + offsetld, __nlld + offsetlld, &__npivmin, &__ngaptol, __nz + offsetz, &__nwantnc, &__nnegcnt, &__nztz, &__nmingma, &__nr, __nisuppz + offsetisuppz, &__nnrminv, &__nresid, &__nrqcorr, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, rqcorr, floatW_val_fieldID, __nrqcorr);
  if (!__failed) (*env)->SetFloatField(env, resid, floatW_val_fieldID, __nresid);
  if (!__failed) (*env)->SetFloatField(env, nrminv, floatW_val_fieldID, __nnrminv);
  if (!__failed) (*env)->SetIntField(env, r, intW_val_fieldID, __nr);
  if (!__failed) (*env)->SetFloatField(env, mingma, floatW_val_fieldID, __nmingma);
  if (!__failed) (*env)->SetFloatField(env, ztz, floatW_val_fieldID, __nztz);
  if (!__failed) (*env)->SetIntField(env, negcnt, intW_val_fieldID, __nnegcnt);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slar2v_)(int *n, float *x, float *y, float *z, int *incx, float *c, float *s, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slar2v(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slar2v_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slar2vK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jfloatArray y, jint offsety, jfloatArray z, jint offsetz, jint incx, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jint incc) {
  if (!slar2v_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  float *__nx = NULL;
  float *__ny = NULL;
  float *__nz = NULL;
  float *__nc = NULL;
  float *__ns = NULL;
  __nn = n;
  __nincx = incx;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slar2v_(&__nn, __nx + offsetx, __ny + offsety, __nz + offsetz, &__nincx, __nc + offsetc, __ns + offsets, &__nincc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarf_)(const char *side, int *m, int *n, float *v, int *incv, float *tau, float *c, int *Ldc, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  if (!slarf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  float __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarf_(__nside, &__nm, &__nn, __nv + offsetv, &__nincv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarfb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, float *v, int *ldv, float *t, int *ldt, float *c, int *Ldc, float *work, int *ldwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarfb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarfb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray t, jint offsett, jint ldt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint ldwork) {
  if (!slarfb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldwork __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nt = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  __nLdc = Ldc;
  __nldwork = ldwork;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarfb_(__nside, __ntrans, __ndirect, __nstorev, &__nm, &__nn, &__nk, __nv + offsetv, &__nldv, __nt + offsett, &__nldt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarfg_)(int *n, float *alpha, float *x, int *incx, float *tau);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarfg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarfg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfgK(JNIEnv *env, UNUSED jobject obj, jint n, jobject alpha, jfloatArray x, jint offsetx, jint incx, jobject tau) {
  if (!slarfg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nalpha = 0;
  int __nincx __attribute__((aligned(8)));
  float __ntau = 0;
  float *__nx = NULL;
  __nn = n;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __nincx = incx;
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slarfg_(&__nn, &__nalpha, __nx + offsetx, &__nincx, &__ntau);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (!__failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarft_)(const char *direct, const char *storev, int *n, int *k, float *v, int *ldv, float *tau, float *t, int *ldt);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarft(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarft_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarftK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt) {
  if (!slarft_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__ntau = NULL;
  float *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  slarft_(__ndirect, __nstorev, &__nn, &__nk, __nv + offsetv, &__nldv, __ntau + offsettau, __nt + offsett, &__nldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarfx_)(const char *side, int *m, int *n, float *v, float *tau, float *c, int *Ldc, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarfx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarfx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfxK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  if (!slarfx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  float __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarfx_(__nside, &__nm, &__nn, __nv + offsetv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slargv_)(int *n, float *x, int *incx, float *y, int *incy, float *c, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slargv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slargv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slargvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jfloatArray c, jint offsetc, jint incc) {
  if (!slargv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  float *__nx = NULL;
  float *__ny = NULL;
  float *__nc = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  slargv_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, __nc + offsetc, &__nincc);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarnv_)(int *idist, int *iseed, int *n, float *x);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarnv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarnv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarnvK(JNIEnv *env, UNUSED jobject obj, jint idist, jintArray iseed, jint offsetiseed, jint n, jfloatArray x, jint offsetx) {
  if (!slarnv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nidist __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int *__niseed = NULL;
  float *__nx = NULL;
  __nidist = idist;
  __nn = n;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slarnv_(&__nidist, __niseed + offsetiseed, &__nn, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarra_)(int *n, float *d, float *e, float *e2, float *spltol, float *tnrm, int *nsplit, int *isplit, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarra(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarra_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarraK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat spltol, jfloat tnrm, jobject nsplit, jintArray isplit, jint offsetisplit, jobject info) {
  if (!slarra_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nspltol __attribute__((aligned(8)));
  float __ntnrm __attribute__((aligned(8)));
  int __nnsplit = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ne2 = NULL;
  int *__nisplit = NULL;
  __nn = n;
  __nspltol = spltol;
  __ntnrm = tnrm;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  slarra_(&__nn, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__nspltol, &__ntnrm, &__nnsplit, __nisplit + offsetisplit, &__ninfo);
done:
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrb_)(int *n, float *d, float *lld, int *ifirst, int *ilast, float *rtol1, float *rtol2, int *offset, float *w, float *wgap, float *werr, float *work, int *iwork, float *pivmin, float *spdiam, int *twist, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrbK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray lld, jint offsetlld, jint ifirst, jint ilast, jfloat rtol1, jfloat rtol2, jint offset, jfloatArray w, jint offsetw, jfloatArray wgap, jint offsetwgap, jfloatArray werr, jint offsetwerr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jfloat pivmin, jfloat spdiam, jint twist, jobject info) {
  if (!slarrb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nifirst __attribute__((aligned(8)));
  int __nilast __attribute__((aligned(8)));
  float __nrtol1 __attribute__((aligned(8)));
  float __nrtol2 __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  float __nspdiam __attribute__((aligned(8)));
  int __ntwist __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nlld = NULL;
  float *__nw = NULL;
  float *__nwgap = NULL;
  float *__nwerr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nifirst = ifirst;
  __nilast = ilast;
  __nrtol1 = rtol1;
  __nrtol2 = rtol2;
  __noffset = offset;
  __npivmin = pivmin;
  __nspdiam = spdiam;
  __ntwist = twist;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slarrb_(&__nn, __nd + offsetd, __nlld + offsetlld, &__nifirst, &__nilast, &__nrtol1, &__nrtol2, &__noffset, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &__npivmin, &__nspdiam, &__ntwist, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrc_)(const char *jobt, int *n, float *vl, float *vu, float *d, float *e, float *pivmin, int *eigcnt, int *lcnt, int *rcnt, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrcK(JNIEnv *env, UNUSED jobject obj, jstring jobt, jint n, jfloat vl, jfloat vu, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat pivmin, jobject eigcnt, jobject lcnt, jobject rcnt, jobject info) {
  if (!slarrc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobt = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  int __neigcnt = 0;
  int __nlcnt = 0;
  int __nrcnt = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  if (!(__njobt = (*env)->GetStringUTFChars(env, jobt, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __npivmin = pivmin;
  __neigcnt = (*env)->GetIntField(env, eigcnt, intW_val_fieldID);
  __nlcnt = (*env)->GetIntField(env, lcnt, intW_val_fieldID);
  __nrcnt = (*env)->GetIntField(env, rcnt, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  slarrc_(__njobt, &__nn, &__nvl, &__nvu, __nd + offsetd, __ne + offsete, &__npivmin, &__neigcnt, &__nlcnt, &__nrcnt, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, rcnt, intW_val_fieldID, __nrcnt);
  if (!__failed) (*env)->SetIntField(env, lcnt, intW_val_fieldID, __nlcnt);
  if (!__failed) (*env)->SetIntField(env, eigcnt, intW_val_fieldID, __neigcnt);
  if (__njobt) (*env)->ReleaseStringUTFChars(env, jobt, __njobt);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrd_)(const char *range, const char *order, int *n, float *vl, float *vu, int *il, int *iu, float *gers, float *reltol, float *d, float *e, float *e2, float *pivmin, int *nsplit, int *isplit, int *m, float *w, float *werr, float *wl, float *wu, int *iblock, int *indexw, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrdK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jfloat vl, jfloat vu, jint il, jint iu, jfloatArray gers, jint offsetgers, jfloat reltol, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat pivmin, jint nsplit, jintArray isplit, jint offsetisplit, jobject m, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jobject wl, jobject wu, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slarrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  const char *__norder = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nreltol __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  int __nnsplit __attribute__((aligned(8)));
  int __nm = 0;
  float __nwl = 0;
  float __nwu = 0;
  int __ninfo = 0;
  float *__ngers = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ne2 = NULL;
  int *__nisplit = NULL;
  float *__nw = NULL;
  float *__nwerr = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nreltol = reltol;
  __npivmin = pivmin;
  __nnsplit = nsplit;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nwl = (*env)->GetFloatField(env, wl, floatW_val_fieldID);
  __nwu = (*env)->GetFloatField(env, wu, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slarrd_(__nrange, __norder, &__nn, &__nvl, &__nvu, &__nil, &__niu, __ngers + offsetgers, &__nreltol, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__npivmin, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, &__nwl, &__nwu, __niblock + offsetiblock, __nindexw + offsetindexw, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, wu, floatW_val_fieldID, __nwu);
  if (!__failed) (*env)->SetFloatField(env, wl, floatW_val_fieldID, __nwl);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarre_)(const char *range, int *n, float *vl, float *vu, int *il, int *iu, float *d, float *e, float *e2, float *rtol1, float *rtol2, float *spltol, int *nsplit, int *isplit, int *m, float *w, float *werr, float *wgap, int *iblock, int *indexw, float *gers, float *pivmin, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarre(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarre_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarreK(JNIEnv *env, UNUSED jobject obj, jstring range, jint n, jobject vl, jobject vu, jint il, jint iu, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat rtol1, jfloat rtol2, jfloat spltol, jobject nsplit, jintArray isplit, jint offsetisplit, jobject m, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray gers, jint offsetgers, jobject pivmin, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slarre_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl = 0;
  float __nvu = 0;
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nrtol1 __attribute__((aligned(8)));
  float __nrtol2 __attribute__((aligned(8)));
  float __nspltol __attribute__((aligned(8)));
  int __nnsplit = 0;
  int __nm = 0;
  float __npivmin = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ne2 = NULL;
  int *__nisplit = NULL;
  float *__nw = NULL;
  float *__nwerr = NULL;
  float *__nwgap = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  float *__ngers = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = (*env)->GetFloatField(env, vl, floatW_val_fieldID);
  __nvu = (*env)->GetFloatField(env, vu, floatW_val_fieldID);
  __nil = il;
  __niu = iu;
  __nrtol1 = rtol1;
  __nrtol2 = rtol2;
  __nspltol = spltol;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npivmin = (*env)->GetFloatField(env, pivmin, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slarre_(__nrange, &__nn, &__nvl, &__nvu, &__nil, &__niu, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &__nrtol1, &__nrtol2, &__nspltol, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, &__npivmin, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, pivmin, floatW_val_fieldID, __npivmin);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!__failed) (*env)->SetFloatField(env, vu, floatW_val_fieldID, __nvu);
  if (!__failed) (*env)->SetFloatField(env, vl, floatW_val_fieldID, __nvl);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrf_)(int *n, float *d, float *l, float *ld, int *clstrt, int *clend, float *w, float *wgap, float *werr, float *spdiam, float *clgapl, float *clgapr, float *pivmin, float *sigma, float *dplus, float *lplus, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloatArray ld, jint offsetld, jint clstrt, jint clend, jfloatArray w, jint offsetw, jfloatArray wgap, jint offsetwgap, jfloatArray werr, jint offsetwerr, jfloat spdiam, jfloat clgapl, jfloat clgapr, jfloat pivmin, jobject sigma, jfloatArray dplus, jint offsetdplus, jfloatArray lplus, jint offsetlplus, jfloatArray work, jint offsetwork, jobject info) {
  if (!slarrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nclstrt __attribute__((aligned(8)));
  int __nclend __attribute__((aligned(8)));
  float __nspdiam __attribute__((aligned(8)));
  float __nclgapl __attribute__((aligned(8)));
  float __nclgapr __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  float __nsigma = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nl = NULL;
  float *__nld = NULL;
  float *__nw = NULL;
  float *__nwgap = NULL;
  float *__nwerr = NULL;
  float *__ndplus = NULL;
  float *__nlplus = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nclstrt = clstrt;
  __nclend = clend;
  __nspdiam = spdiam;
  __nclgapl = clgapl;
  __nclgapr = clgapr;
  __npivmin = pivmin;
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndplus = (*env)->GetPrimitiveArrayCritical(env, dplus, NULL))) { __failed = TRUE; goto done; }
  if (!(__nlplus = (*env)->GetPrimitiveArrayCritical(env, lplus, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarrf_(&__nn, __nd + offsetd, __nl + offsetl, __nld + offsetld, &__nclstrt, &__nclend, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, &__nspdiam, &__nclgapl, &__nclgapr, &__npivmin, &__nsigma, __ndplus + offsetdplus, __nlplus + offsetlplus, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nlplus) (*env)->ReleasePrimitiveArrayCritical(env, lplus, __nlplus, __failed ? JNI_ABORT : 0);
  if (__ndplus) (*env)->ReleasePrimitiveArrayCritical(env, dplus, __ndplus, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrj_)(int *n, float *d, float *e2, int *ifirst, int *ilast, float *rtol, int *offset, float *w, float *werr, float *work, int *iwork, float *pivmin, float *spdiam, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrj(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrj_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrjK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e2, jint offsete2, jint ifirst, jint ilast, jfloat rtol, jint offset, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jfloat pivmin, jfloat spdiam, jobject info) {
  if (!slarrj_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nifirst __attribute__((aligned(8)));
  int __nilast __attribute__((aligned(8)));
  float __nrtol __attribute__((aligned(8)));
  int __noffset __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  float __nspdiam __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne2 = NULL;
  float *__nw = NULL;
  float *__nwerr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nifirst = ifirst;
  __nilast = ilast;
  __nrtol = rtol;
  __noffset = offset;
  __npivmin = pivmin;
  __nspdiam = spdiam;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slarrj_(&__nn, __nd + offsetd, __ne2 + offsete2, &__nifirst, &__nilast, &__nrtol, &__noffset, __nw + offsetw, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &__npivmin, &__nspdiam, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrk_)(int *n, int *iw, float *gl, float *gu, float *d, float *e2, float *pivmin, float *reltol, float *w, float *werr, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrk(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrk_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrkK(JNIEnv *env, UNUSED jobject obj, jint n, jint iw, jfloat gl, jfloat gu, jfloatArray d, jint offsetd, jfloatArray e2, jint offsete2, jfloat pivmin, jfloat reltol, jobject w, jobject werr, jobject info) {
  if (!slarrk_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __niw __attribute__((aligned(8)));
  float __ngl __attribute__((aligned(8)));
  float __ngu __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  float __nreltol __attribute__((aligned(8)));
  float __nw = 0;
  float __nwerr = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne2 = NULL;
  __nn = n;
  __niw = iw;
  __ngl = gl;
  __ngu = gu;
  __npivmin = pivmin;
  __nreltol = reltol;
  __nw = (*env)->GetFloatField(env, w, floatW_val_fieldID);
  __nwerr = (*env)->GetFloatField(env, werr, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) { __failed = TRUE; goto done; }
  slarrk_(&__nn, &__niw, &__ngl, &__ngu, __nd + offsetd, __ne2 + offsete2, &__npivmin, &__nreltol, &__nw, &__nwerr, &__ninfo);
done:
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, werr, floatW_val_fieldID, __nwerr);
  if (!__failed) (*env)->SetFloatField(env, w, floatW_val_fieldID, __nw);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrr_)(int *n, float *d, float *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrrK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  if (!slarrr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  slarrr_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarrv_)(int *n, float *vl, float *vu, float *d, float *l, float *pivmin, int *isplit, int *m, int *dol, int *dou, float *minrgp, float *rtol1, float *rtol2, float *w, float *werr, float *wgap, int *iblock, int *indexw, float *gers, float *z, int *ldz, int *isuppz, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarrv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarrv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloat vl, jfloat vu, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloat pivmin, jintArray isplit, jint offsetisplit, jint m, jint dol, jint dou, jfloat minrgp, jobject rtol1, jobject rtol2, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray gers, jint offsetgers, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slarrv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  float __npivmin __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __ndol __attribute__((aligned(8)));
  int __ndou __attribute__((aligned(8)));
  float __nminrgp __attribute__((aligned(8)));
  float __nrtol1 = 0;
  float __nrtol2 = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nl = NULL;
  int *__nisplit = NULL;
  float *__nw = NULL;
  float *__nwerr = NULL;
  float *__nwgap = NULL;
  int *__niblock = NULL;
  int *__nindexw = NULL;
  float *__ngers = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __npivmin = pivmin;
  __nm = m;
  __ndol = dol;
  __ndou = dou;
  __nminrgp = minrgp;
  __nrtol1 = (*env)->GetFloatField(env, rtol1, floatW_val_fieldID);
  __nrtol2 = (*env)->GetFloatField(env, rtol2, floatW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slarrv_(&__nn, &__nvl, &__nvu, __nd + offsetd, __nl + offsetl, &__npivmin, __nisplit + offsetisplit, &__nm, &__ndol, &__ndou, &__nminrgp, &__nrtol1, &__nrtol2, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, __failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, __failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rtol2, floatW_val_fieldID, __nrtol2);
  if (!__failed) (*env)->SetFloatField(env, rtol1, floatW_val_fieldID, __nrtol1);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slartg_)(float *f, float *g, float *cs, float *sn, float *r);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slartg(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slartg_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slartgK(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jobject cs, jobject sn, jobject r) {
  if (!slartg_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __nf __attribute__((aligned(8)));
  float __ng __attribute__((aligned(8)));
  float __ncs = 0;
  float __nsn = 0;
  float __nr = 0;
  __nf = f;
  __ng = g;
  __ncs = (*env)->GetFloatField(env, cs, floatW_val_fieldID);
  __nsn = (*env)->GetFloatField(env, sn, floatW_val_fieldID);
  __nr = (*env)->GetFloatField(env, r, floatW_val_fieldID);
  slartg_(&__nf, &__ng, &__ncs, &__nsn, &__nr);
done:
  if (!__failed) (*env)->SetFloatField(env, r, floatW_val_fieldID, __nr);
  if (!__failed) (*env)->SetFloatField(env, sn, floatW_val_fieldID, __nsn);
  if (!__failed) (*env)->SetFloatField(env, cs, floatW_val_fieldID, __ncs);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slartv_)(int *n, float *x, int *incx, float *y, int *incy, float *c, float *s, int *incc);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slartv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slartv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slartvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jint incc) {
  if (!slartv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  int __nincy __attribute__((aligned(8)));
  int __nincc __attribute__((aligned(8)));
  float *__nx = NULL;
  float *__ny = NULL;
  float *__nc = NULL;
  float *__ns = NULL;
  __nn = n;
  __nincx = incx;
  __nincy = incy;
  __nincc = incc;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  slartv_(&__nn, __nx + offsetx, &__nincx, __ny + offsety, &__nincy, __nc + offsetc, __ns + offsets, &__nincc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaruv_)(int *iseed, int *n, float *x);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaruv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaruv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaruvK(JNIEnv *env, UNUSED jobject obj, jintArray iseed, jint offsetiseed, jint n, jfloatArray x, jint offsetx) {
  if (!slaruv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int *__niseed = NULL;
  float *__nx = NULL;
  __nn = n;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slaruv_(__niseed + offsetiseed, &__nn, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarz_)(const char *side, int *m, int *n, int *l, float *v, int *incv, float *tau, float *c, int *Ldc, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarzK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jint l, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  if (!slarz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  float __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nl = l;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarz_(__nside, &__nm, &__nn, &__nl, __nv + offsetv, &__nincv, &__ntau, __nc + offsetc, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarzb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, int *l, float *v, int *ldv, float *t, int *ldt, float *c, int *Ldc, float *work, int *ldwork);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarzb(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarzb_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarzbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jint l, jfloatArray v, jint offsetv, jint ldv, jfloatArray t, jint offsett, jint ldt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint ldwork) {
  if (!slarzb_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldwork __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nt = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nldv = ldv;
  __nldt = ldt;
  __nLdc = Ldc;
  __nldwork = ldwork;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slarzb_(__nside, __ntrans, __ndirect, __nstorev, &__nm, &__nn, &__nk, &__nl, __nv + offsetv, &__nldv, __nt + offsett, &__nldt, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slarzt_)(const char *direct, const char *storev, int *n, int *k, float *v, int *ldv, float *tau, float *t, int *ldt);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slarzt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slarzt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarztK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt) {
  if (!slarzt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ndirect = NULL;
  const char *__nstorev = NULL;
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__ntau = NULL;
  float *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nk = k;
  __nldv = ldv;
  __nldt = ldt;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  slarzt_(__ndirect, __nstorev, &__nn, &__nk, __nv + offsetv, &__nldv, __ntau + offsettau, __nt + offsett, &__nldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slas2_)(float *f, float *g, float *h, float *ssmin, float *ssmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slas2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slas2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slas2K(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jfloat h, jobject ssmin, jobject ssmax) {
  if (!slas2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __nf __attribute__((aligned(8)));
  float __ng __attribute__((aligned(8)));
  float __nh __attribute__((aligned(8)));
  float __nssmin = 0;
  float __nssmax = 0;
  __nf = f;
  __ng = g;
  __nh = h;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  __nssmax = (*env)->GetFloatField(env, ssmax, floatW_val_fieldID);
  slas2_(&__nf, &__ng, &__nh, &__nssmin, &__nssmax);
done:
  if (!__failed) (*env)->SetFloatField(env, ssmax, floatW_val_fieldID, __nssmax);
  if (!__failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slascl_)(const char *type, int *kl, int *ku, float *cfrom, float *cto, int *m, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slascl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slascl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasclK(JNIEnv *env, UNUSED jobject obj, jstring type, jint kl, jint ku, jfloat cfrom, jfloat cto, jint m, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!slascl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntype = NULL;
  int __nkl __attribute__((aligned(8)));
  int __nku __attribute__((aligned(8)));
  float __ncfrom __attribute__((aligned(8)));
  float __ncto __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__ntype = (*env)->GetStringUTFChars(env, type, NULL))) { __failed = TRUE; goto done; }
  __nkl = kl;
  __nku = ku;
  __ncfrom = cfrom;
  __ncto = cto;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slascl_(__ntype, &__nkl, &__nku, &__ncfrom, &__ncto, &__nm, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntype) (*env)->ReleaseStringUTFChars(env, type, __ntype);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd0_)(int *n, int *sqre, float *d, float *e, float *u, int *ldu, float *vt, int *ldvt, int *smlsiz, int *iwork, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd0(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd0_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd0K(JNIEnv *env, UNUSED jobject obj, jint n, jint sqre, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jint smlsiz, jintArray iwork, jint offsetiwork, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasd0_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  int *__niwork = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nsqre = sqre;
  __nldu = ldu;
  __nldvt = ldvt;
  __nsmlsiz = smlsiz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasd0_(&__nn, &__nsqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, &__nsmlsiz, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd1_)(int *nl, int *nr, int *sqre, float *d, float *alpha, float *beta, float *u, int *ldu, float *vt, int *ldvt, int *idxq, int *iwork, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd1K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jfloatArray d, jint offsetd, jobject alpha, jobject beta, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jintArray idxq, jint offsetidxq, jintArray iwork, jint offsetiwork, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasd1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  float __nalpha = 0;
  float __nbeta = 0;
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  int *__nidxq = NULL;
  int *__niwork = NULL;
  float *__nwork = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __nbeta = (*env)->GetFloatField(env, beta, floatW_val_fieldID);
  __nldu = ldu;
  __nldvt = ldvt;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasd1_(&__nnl, &__nnr, &__nsqre, __nd + offsetd, &__nalpha, &__nbeta, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __nidxq + offsetidxq, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, beta, floatW_val_fieldID, __nbeta);
  if (!__failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd2_)(int *nl, int *nr, int *sqre, int *k, float *d, float *z, float *alpha, float *beta, float *u, int *ldu, float *vt, int *ldvt, float *dsigma, float *u2, int *ldu2, float *vt2, int *ldvt2, int *idxp, int *idx, int *idxc, int *idxq, int *coltyp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd2K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jobject k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloat alpha, jfloat beta, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray dsigma, jint offsetdsigma, jfloatArray u2, jint offsetu2, jint ldu2, jfloatArray vt2, jint offsetvt2, jint ldvt2, jintArray idxp, jint offsetidxp, jintArray idx, jint offsetidx, jintArray idxc, jint offsetidxc, jintArray idxq, jint offsetidxq, jintArray coltyp, jint offsetcoltyp, jobject info) {
  if (!slasd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk = 0;
  float __nalpha __attribute__((aligned(8)));
  float __nbeta __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu2 __attribute__((aligned(8)));
  int __nldvt2 __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  float *__ndsigma = NULL;
  float *__nu2 = NULL;
  float *__nvt2 = NULL;
  int *__nidxp = NULL;
  int *__nidx = NULL;
  int *__nidxc = NULL;
  int *__nidxq = NULL;
  int *__ncoltyp = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nalpha = alpha;
  __nbeta = beta;
  __nldu = ldu;
  __nldvt = ldvt;
  __nldu2 = ldu2;
  __nldvt2 = ldvt2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) { __failed = TRUE; goto done; }
  slasd2_(&__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nz + offsetz, &__nalpha, &__nbeta, __nu + offsetu, &__nldu, __nvt + offsetvt, &__nldvt, __ndsigma + offsetdsigma, __nu2 + offsetu2, &__nldu2, __nvt2 + offsetvt2, &__nldvt2, __nidxp + offsetidxp, __nidx + offsetidx, __nidxc + offsetidxc, __nidxq + offsetidxq, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, __failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, __failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, __failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, __failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd3_)(int *nl, int *nr, int *sqre, int *k, float *d, float *q, int *ldq, float *dsigma, float *u, int *ldu, float *u2, int *ldu2, float *vt, int *ldvt, float *vt2, int *ldvt2, int *idxc, int *ctot, float *z, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd3K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jint k, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloatArray dsigma, jint offsetdsigma, jfloatArray u, jint offsetu, jint ldu, jfloatArray u2, jint offsetu2, jint ldu2, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray vt2, jint offsetvt2, jint ldvt2, jintArray idxc, jint offsetidxc, jintArray ctot, jint offsetctot, jfloatArray z, jint offsetz, jobject info) {
  if (!slasd3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldu2 __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldvt2 __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nq = NULL;
  float *__ndsigma = NULL;
  float *__nu = NULL;
  float *__nu2 = NULL;
  float *__nvt = NULL;
  float *__nvt2 = NULL;
  int *__nidxc = NULL;
  int *__nctot = NULL;
  float *__nz = NULL;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = k;
  __nldq = ldq;
  __nldu = ldu;
  __nldu2 = ldu2;
  __nldvt = ldvt;
  __nldvt2 = ldvt2;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) { __failed = TRUE; goto done; }
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasd3_(&__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nq + offsetq, &__nldq, __ndsigma + offsetdsigma, __nu + offsetu, &__nldu, __nu2 + offsetu2, &__nldu2, __nvt + offsetvt, &__nldvt, __nvt2 + offsetvt2, &__nldvt2, __nidxc + offsetidxc, __nctot + offsetctot, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, __failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, __failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd4_)(int *n, int *i, float *d, float *z, float *delta, float *rho, float *sigma, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject sigma, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasd4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ni __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  float __nsigma = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__ndelta = NULL;
  float *__nwork = NULL;
  __nn = n;
  __ni = i;
  __nrho = rho;
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasd4_(&__nn, &__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__nsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd5_)(int *i, float *d, float *z, float *delta, float *rho, float *dsigma, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd5K(JNIEnv *env, UNUSED jobject obj, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dsigma, jfloatArray work, jint offsetwork) {
  if (!slasd5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni __attribute__((aligned(8)));
  float __nrho __attribute__((aligned(8)));
  float __ndsigma = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__ndelta = NULL;
  float *__nwork = NULL;
  __ni = i;
  __nrho = rho;
  __ndsigma = (*env)->GetFloatField(env, dsigma, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasd5_(&__ni, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &__nrho, &__ndsigma, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, dsigma, floatW_val_fieldID, __ndsigma);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd6_)(int *icompq, int *nl, int *nr, int *sqre, float *d, float *vf, float *vl, float *alpha, float *beta, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *poles, float *difl, float *difr, float *z, int *k, float *c, float *s, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd6K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jfloatArray d, jint offsetd, jfloatArray vf, jint offsetvf, jfloatArray vl, jint offsetvl, jobject alpha, jobject beta, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jfloatArray poles, jint offsetpoles, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jobject k, jobject c, jobject s, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slasd6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  float __nalpha = 0;
  float __nbeta = 0;
  int __ngivptr = 0;
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  int __nk = 0;
  float __nc = 0;
  float __ns = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nvf = NULL;
  float *__nvl = NULL;
  int *__nidxq = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  float *__npoles = NULL;
  float *__ndifl = NULL;
  float *__ndifr = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __nbeta = (*env)->GetFloatField(env, beta, floatW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slasd6_(&__nicompq, &__nnl, &__nnr, &__nsqre, __nd + offsetd, __nvf + offsetvf, __nvl + offsetvl, &__nalpha, &__nbeta, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!__failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetFloatField(env, beta, floatW_val_fieldID, __nbeta);
  if (!__failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd7_)(int *icompq, int *nl, int *nr, int *sqre, int *k, float *d, float *z, float *zw, float *vf, float *vfw, float *vl, float *vlw, float *alpha, float *beta, float *dsigma, int *idx, int *idxp, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *c, float *s, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd7(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd7_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jobject k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray zw, jint offsetzw, jfloatArray vf, jint offsetvf, jfloatArray vfw, jint offsetvfw, jfloatArray vl, jint offsetvl, jfloatArray vlw, jint offsetvlw, jfloat alpha, jfloat beta, jfloatArray dsigma, jint offsetdsigma, jintArray idx, jint offsetidx, jintArray idxp, jint offsetidxp, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jobject c, jobject s, jobject info) {
  if (!slasd7_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nnl __attribute__((aligned(8)));
  int __nnr __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nk = 0;
  float __nalpha __attribute__((aligned(8)));
  float __nbeta __attribute__((aligned(8)));
  int __ngivptr = 0;
  int __nldgcol __attribute__((aligned(8)));
  int __nldgnum __attribute__((aligned(8)));
  float __nc = 0;
  float __ns = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__nzw = NULL;
  float *__nvf = NULL;
  float *__nvfw = NULL;
  float *__nvl = NULL;
  float *__nvlw = NULL;
  float *__ndsigma = NULL;
  int *__nidx = NULL;
  int *__nidxp = NULL;
  int *__nidxq = NULL;
  int *__nperm = NULL;
  int *__ngivcol = NULL;
  float *__ngivnum = NULL;
  __nicompq = icompq;
  __nnl = nl;
  __nnr = nr;
  __nsqre = sqre;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nalpha = alpha;
  __nbeta = beta;
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nldgcol = ldgcol;
  __nldgnum = ldgnum;
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nzw = (*env)->GetPrimitiveArrayCritical(env, zw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvfw = (*env)->GetPrimitiveArrayCritical(env, vfw, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvlw = (*env)->GetPrimitiveArrayCritical(env, vlw, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  slasd7_(&__nicompq, &__nnl, &__nnr, &__nsqre, &__nk, __nd + offsetd, __nz + offsetz, __nzw + offsetzw, __nvf + offsetvf, __nvfw + offsetvfw, __nvl + offsetvl, __nvlw + offsetvlw, &__nalpha, &__nbeta, __ndsigma + offsetdsigma, __nidx + offsetidx, __nidxp + offsetidxp, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &__nldgcol, __ngivnum + offsetgivnum, &__nldgnum, &__nc, &__ns, &__ninfo);
done:
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, __failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, __failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__nvlw) (*env)->ReleasePrimitiveArrayCritical(env, vlw, __nvlw, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvfw) (*env)->ReleasePrimitiveArrayCritical(env, vfw, __nvfw, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nzw) (*env)->ReleasePrimitiveArrayCritical(env, zw, __nzw, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!__failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!__failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!__failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasd8_)(int *icompq, int *k, float *d, float *z, float *vf, float *vl, float *difl, float *difr, int *lddifr, float *dsigma, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasd8(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasd8_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray vf, jint offsetvf, jfloatArray vl, jint offsetvl, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jint lddifr, jfloatArray dsigma, jint offsetdsigma, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasd8_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlddifr __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__nz = NULL;
  float *__nvf = NULL;
  float *__nvl = NULL;
  float *__ndifl = NULL;
  float *__ndifr = NULL;
  float *__ndsigma = NULL;
  float *__nwork = NULL;
  __nicompq = icompq;
  __nk = k;
  __nlddifr = lddifr;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasd8_(&__nicompq, &__nk, __nd + offsetd, __nz + offsetz, __nvf + offsetvf, __nvl + offsetvl, __ndifl + offsetdifl, __ndifr + offsetdifr, &__nlddifr, __ndsigma + offsetdsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasda_)(int *icompq, int *smlsiz, int *n, int *sqre, float *d, float *e, float *u, int *ldu, float *vt, int *k, float *difl, float *difr, float *z, float *poles, int *givptr, int *givcol, int *ldgcol, int *perm, float *givnum, float *c, float *s, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasda(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasda_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint sqre, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jintArray k, jint offsetk, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jfloatArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jfloatArray givnum, jint offsetgivnum, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!slasda_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nicompq __attribute__((aligned(8)));
  int __nsmlsiz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nsqre __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldgcol __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nu = NULL;
  float *__nvt = NULL;
  int *__nk = NULL;
  float *__ndifl = NULL;
  float *__ndifr = NULL;
  float *__nz = NULL;
  float *__npoles = NULL;
  int *__ngivptr = NULL;
  int *__ngivcol = NULL;
  int *__nperm = NULL;
  float *__ngivnum = NULL;
  float *__nc = NULL;
  float *__ns = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nicompq = icompq;
  __nsmlsiz = smlsiz;
  __nn = n;
  __nsqre = sqre;
  __nldu = ldu;
  __nldgcol = ldgcol;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) { __failed = TRUE; goto done; }
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) { __failed = TRUE; goto done; }
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  slasda_(&__nicompq, &__nsmlsiz, &__nn, &__nsqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &__nldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &__nldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, __failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, __failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, __failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, __failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, __failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, __failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasdq_)(const char *uplo, int *sqre, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, float *vt, int *ldvt, float *u, int *ldu, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasdq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasdq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdqK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint sqre, jint n, jint ncvt, jint nru, jint ncc, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray u, jint offsetu, jint ldu, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasdq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nsqre __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nncvt __attribute__((aligned(8)));
  int __nnru __attribute__((aligned(8)));
  int __nncc __attribute__((aligned(8)));
  int __nldvt __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nvt = NULL;
  float *__nu = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nsqre = sqre;
  __nn = n;
  __nncvt = ncvt;
  __nnru = nru;
  __nncc = ncc;
  __nldvt = ldvt;
  __nldu = ldu;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasdq_(__nuplo, &__nsqre, &__nn, &__nncvt, &__nnru, &__nncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &__nldvt, __nu + offsetu, &__nldu, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasdt_)(int *n, int *lvl, int *nd, int *inode, int *ndiml, int *ndimr, int *msub);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasdt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasdt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdtK(JNIEnv *env, UNUSED jobject obj, jint n, jobject lvl, jobject nd, jintArray inode, jint offsetinode, jintArray ndiml, jint offsetndiml, jintArray ndimr, jint offsetndimr, jint msub) {
  if (!slasdt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlvl = 0;
  int __nnd = 0;
  int __nmsub __attribute__((aligned(8)));
  int *__ninode = NULL;
  int *__nndiml = NULL;
  int *__nndimr = NULL;
  __nn = n;
  __nlvl = (*env)->GetIntField(env, lvl, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  __nmsub = msub;
  if (!(__ninode = (*env)->GetPrimitiveArrayCritical(env, inode, NULL))) { __failed = TRUE; goto done; }
  if (!(__nndiml = (*env)->GetPrimitiveArrayCritical(env, ndiml, NULL))) { __failed = TRUE; goto done; }
  if (!(__nndimr = (*env)->GetPrimitiveArrayCritical(env, ndimr, NULL))) { __failed = TRUE; goto done; }
  slasdt_(&__nn, &__nlvl, &__nnd, __ninode + offsetinode, __nndiml + offsetndiml, __nndimr + offsetndimr, &__nmsub);
done:
  if (__nndimr) (*env)->ReleasePrimitiveArrayCritical(env, ndimr, __nndimr, __failed ? JNI_ABORT : 0);
  if (__nndiml) (*env)->ReleasePrimitiveArrayCritical(env, ndiml, __nndiml, __failed ? JNI_ABORT : 0);
  if (__ninode) (*env)->ReleasePrimitiveArrayCritical(env, inode, __ninode, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!__failed) (*env)->SetIntField(env, lvl, intW_val_fieldID, __nlvl);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaset_)(const char *uplo, int *m, int *n, float *alpha, float *beta, float *a, int *lda);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaset(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaset_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasetK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jfloat alpha, jfloat beta, jfloatArray a, jint offseta, jint lda) {
  if (!slaset_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  float __nalpha __attribute__((aligned(8)));
  float __nbeta __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nalpha = alpha;
  __nbeta = beta;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slaset_(__nuplo, &__nm, &__nn, &__nalpha, &__nbeta, __na + offseta, &__nlda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq1_)(int *n, float *d, float *e, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq1_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray work, jint offsetwork, jobject info) {
  if (!slasq1_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nwork = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slasq1_(&__nn, __nd + offsetd, __ne + offsete, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq2_)(int *n, float *z, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray z, jint offsetz, jobject info) {
  if (!slasq2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nz = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasq2_(&__nn, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq3_)(int *i0, int *n0, float *z, int *pp, float *dmin, float *sigma, float *desig, float *qmax, int *nfail, int *iter, int *ndiv, int *ieee);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq3K(JNIEnv *env, UNUSED jobject obj, jint i0, jobject n0, jfloatArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee) {
  if (!slasq3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 = 0;
  int __npp __attribute__((aligned(8)));
  float __ndmin = 0;
  float __nsigma = 0;
  float __ndesig = 0;
  float __nqmax = 0;
  int __nnfail = 0;
  int __niter = 0;
  int __nndiv = 0;
  int __nieee __attribute__((aligned(8)));
  float *__nz = NULL;
  __ni0 = i0;
  __nn0 = (*env)->GetIntField(env, n0, intW_val_fieldID);
  __npp = pp;
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ndesig = (*env)->GetFloatField(env, desig, floatW_val_fieldID);
  __nqmax = (*env)->GetFloatField(env, qmax, floatW_val_fieldID);
  __nnfail = (*env)->GetIntField(env, nfail, intW_val_fieldID);
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __nndiv = (*env)->GetIntField(env, ndiv, intW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasq3_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ndmin, &__nsigma, &__ndesig, &__nqmax, &__nnfail, &__niter, &__nndiv, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, ndiv, intW_val_fieldID, __nndiv);
  if (!__failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (!__failed) (*env)->SetIntField(env, nfail, intW_val_fieldID, __nnfail);
  if (!__failed) (*env)->SetFloatField(env, qmax, floatW_val_fieldID, __nqmax);
  if (!__failed) (*env)->SetFloatField(env, desig, floatW_val_fieldID, __ndesig);
  if (!__failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (!__failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (!__failed) (*env)->SetIntField(env, n0, intW_val_fieldID, __nn0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq4_)(int *i0, int *n0, float *z, int *pp, int *n0in, float *dmin, float *dmin1, float *dmin2, float *dn, float *dn1, float *dn2, float *tau, int *ttype);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq4_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq4K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jint n0in, jfloat dmin, jfloat dmin1, jfloat dmin2, jfloat dn, jfloat dn1, jfloat dn2, jobject tau, jobject ttype) {
  if (!slasq4_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  int __nn0in __attribute__((aligned(8)));
  float __ndmin __attribute__((aligned(8)));
  float __ndmin1 __attribute__((aligned(8)));
  float __ndmin2 __attribute__((aligned(8)));
  float __ndn __attribute__((aligned(8)));
  float __ndn1 __attribute__((aligned(8)));
  float __ndn2 __attribute__((aligned(8)));
  float __ntau = 0;
  int __nttype = 0;
  float *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __nn0in = n0in;
  __ndmin = dmin;
  __ndmin1 = dmin1;
  __ndmin2 = dmin2;
  __ndn = dn;
  __ndn1 = dn1;
  __ndn2 = dn2;
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  __nttype = (*env)->GetIntField(env, ttype, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasq4_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__nn0in, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndn1, &__ndn2, &__ntau, &__nttype);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, ttype, intW_val_fieldID, __nttype);
  if (!__failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq5_)(int *i0, int *n0, float *z, int *pp, float *tau, float *dmin, float *dmin1, float *dmin2, float *dn, float *dnm1, float *dnm2, int *ieee);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq5_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq5K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jfloat tau, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2, jboolean ieee) {
  if (!slasq5_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  float __ntau __attribute__((aligned(8)));
  float __ndmin = 0;
  float __ndmin1 = 0;
  float __ndmin2 = 0;
  float __ndn = 0;
  float __ndnm1 = 0;
  float __ndnm2 = 0;
  int __nieee __attribute__((aligned(8)));
  float *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __ntau = tau;
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __ndmin1 = (*env)->GetFloatField(env, dmin1, floatW_val_fieldID);
  __ndmin2 = (*env)->GetFloatField(env, dmin2, floatW_val_fieldID);
  __ndn = (*env)->GetFloatField(env, dn, floatW_val_fieldID);
  __ndnm1 = (*env)->GetFloatField(env, dnm1, floatW_val_fieldID);
  __ndnm2 = (*env)->GetFloatField(env, dnm2, floatW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasq5_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ntau, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, dnm2, floatW_val_fieldID, __ndnm2);
  if (!__failed) (*env)->SetFloatField(env, dnm1, floatW_val_fieldID, __ndnm1);
  if (!__failed) (*env)->SetFloatField(env, dn, floatW_val_fieldID, __ndn);
  if (!__failed) (*env)->SetFloatField(env, dmin2, floatW_val_fieldID, __ndmin2);
  if (!__failed) (*env)->SetFloatField(env, dmin1, floatW_val_fieldID, __ndmin1);
  if (!__failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasq6_)(int *i0, int *n0, float *z, int *pp, float *dmin, float *dmin1, float *dmin2, float *dn, float *dnm1, float *dnm2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasq6(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasq6_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq6K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2) {
  if (!slasq6_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __ni0 __attribute__((aligned(8)));
  int __nn0 __attribute__((aligned(8)));
  int __npp __attribute__((aligned(8)));
  float __ndmin = 0;
  float __ndmin1 = 0;
  float __ndmin2 = 0;
  float __ndn = 0;
  float __ndnm1 = 0;
  float __ndnm2 = 0;
  float *__nz = NULL;
  __ni0 = i0;
  __nn0 = n0;
  __npp = pp;
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __ndmin1 = (*env)->GetFloatField(env, dmin1, floatW_val_fieldID);
  __ndmin2 = (*env)->GetFloatField(env, dmin2, floatW_val_fieldID);
  __ndn = (*env)->GetFloatField(env, dn, floatW_val_fieldID);
  __ndnm1 = (*env)->GetFloatField(env, dnm1, floatW_val_fieldID);
  __ndnm2 = (*env)->GetFloatField(env, dnm2, floatW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  slasq6_(&__ni0, &__nn0, __nz + offsetz, &__npp, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, dnm2, floatW_val_fieldID, __ndnm2);
  if (!__failed) (*env)->SetFloatField(env, dnm1, floatW_val_fieldID, __ndnm1);
  if (!__failed) (*env)->SetFloatField(env, dn, floatW_val_fieldID, __ndn);
  if (!__failed) (*env)->SetFloatField(env, dmin2, floatW_val_fieldID, __ndmin2);
  if (!__failed) (*env)->SetFloatField(env, dmin1, floatW_val_fieldID, __ndmin1);
  if (!__failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasr_)(const char *side, const char *pivot, const char *direct, int *m, int *n, float *c, float *s, float *a, int *lda);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring pivot, jstring direct, jint m, jint n, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray a, jint offseta, jint lda) {
  if (!slasr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__npivot = NULL;
  const char *__ndirect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__nc = NULL;
  float *__ns = NULL;
  float *__na = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__npivot = (*env)->GetStringUTFChars(env, pivot, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slasr_(__nside, __npivot, __ndirect, &__nm, &__nn, __nc + offsetc, __ns + offsets, __na + offseta, &__nlda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__npivot) (*env)->ReleaseStringUTFChars(env, pivot, __npivot);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasrt_)(const char *id, int *n, float *d, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasrt(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasrt_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasrtK(JNIEnv *env, UNUSED jobject obj, jstring id, jint n, jfloatArray d, jint offsetd, jobject info) {
  if (!slasrt_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nid = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  if (!(__nid = (*env)->GetStringUTFChars(env, id, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  slasrt_(__nid, &__nn, __nd + offsetd, &__ninfo);
done:
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nid) (*env)->ReleaseStringUTFChars(env, id, __nid);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slassq_)(int *n, float *x, int *incx, float *scale, float *sumsq);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slassq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slassq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slassqK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jobject scale, jobject sumsq) {
  if (!slassq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  float __nscale = 0;
  float __nsumsq = 0;
  float *__nx = NULL;
  __nn = n;
  __nincx = incx;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nsumsq = (*env)->GetFloatField(env, sumsq, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slassq_(&__nn, __nx + offsetx, &__nincx, &__nscale, &__nsumsq);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, sumsq, floatW_val_fieldID, __nsumsq);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasv2_)(float *f, float *g, float *h, float *ssmin, float *ssmax, float *snr, float *csr, float *snl, float *csl);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasv2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasv2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasv2K(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jfloat h, jobject ssmin, jobject ssmax, jobject snr, jobject csr, jobject snl, jobject csl) {
  if (!slasv2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  float __nf __attribute__((aligned(8)));
  float __ng __attribute__((aligned(8)));
  float __nh __attribute__((aligned(8)));
  float __nssmin = 0;
  float __nssmax = 0;
  float __nsnr = 0;
  float __ncsr = 0;
  float __nsnl = 0;
  float __ncsl = 0;
  __nf = f;
  __ng = g;
  __nh = h;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  __nssmax = (*env)->GetFloatField(env, ssmax, floatW_val_fieldID);
  __nsnr = (*env)->GetFloatField(env, snr, floatW_val_fieldID);
  __ncsr = (*env)->GetFloatField(env, csr, floatW_val_fieldID);
  __nsnl = (*env)->GetFloatField(env, snl, floatW_val_fieldID);
  __ncsl = (*env)->GetFloatField(env, csl, floatW_val_fieldID);
  slasv2_(&__nf, &__ng, &__nh, &__nssmin, &__nssmax, &__nsnr, &__ncsr, &__nsnl, &__ncsl);
done:
  if (!__failed) (*env)->SetFloatField(env, csl, floatW_val_fieldID, __ncsl);
  if (!__failed) (*env)->SetFloatField(env, snl, floatW_val_fieldID, __nsnl);
  if (!__failed) (*env)->SetFloatField(env, csr, floatW_val_fieldID, __ncsr);
  if (!__failed) (*env)->SetFloatField(env, snr, floatW_val_fieldID, __nsnr);
  if (!__failed) (*env)->SetFloatField(env, ssmax, floatW_val_fieldID, __nssmax);
  if (!__failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slaswp_)(int *n, float *a, int *lda, int *k1, int *k2, int *ipiv, int *incx);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slaswp(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slaswp_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaswpK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jint k1, jint k2, jintArray ipiv, jint offsetipiv, jint incx) {
  if (!slaswp_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nk1 __attribute__((aligned(8)));
  int __nk2 __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  float *__na = NULL;
  int *__nipiv = NULL;
  __nn = n;
  __nlda = lda;
  __nk1 = k1;
  __nk2 = k2;
  __nincx = incx;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  slaswp_(&__nn, __na + offseta, &__nlda, &__nk1, &__nk2, __nipiv + offsetipiv, &__nincx);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasy2_)(int *ltranl, int *ltranr, int *isgn, int *n1, int *n2, float *tl, int *ldtl, float *tr, int *ldtr, float *b, int *ldb, float *scale, float *x, int *ldx, float *xnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasy2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasy2K(JNIEnv *env, UNUSED jobject obj, jboolean ltranl, jboolean ltranr, jint isgn, jint n1, jint n2, jfloatArray tl, jint offsettl, jint ldtl, jfloatArray tr, jint offsettr, jint ldtr, jfloatArray b, jint offsetb, jint ldb, jobject scale, jfloatArray x, jint offsetx, jint ldx, jobject xnorm, jobject info) {
  if (!slasy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nltranl __attribute__((aligned(8)));
  int __nltranr __attribute__((aligned(8)));
  int __nisgn __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nldtl __attribute__((aligned(8)));
  int __nldtr __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nscale = 0;
  int __nldx __attribute__((aligned(8)));
  float __nxnorm = 0;
  int __ninfo = 0;
  float *__ntl = NULL;
  float *__ntr = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  __nltranl = ltranl;
  __nltranr = ltranr;
  __nisgn = isgn;
  __nn1 = n1;
  __nn2 = n2;
  __nldtl = ldtl;
  __nldtr = ldtr;
  __nldb = ldb;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nldx = ldx;
  __nxnorm = (*env)->GetFloatField(env, xnorm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ntl = (*env)->GetPrimitiveArrayCritical(env, tl, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntr = (*env)->GetPrimitiveArrayCritical(env, tr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  slasy2_(&__nltranl, &__nltranr, &__nisgn, &__nn1, &__nn2, __ntl + offsettl, &__nldtl, __ntr + offsettr, &__nldtr, __nb + offsetb, &__nldb, &__nscale, __nx + offsetx, &__nldx, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ntr) (*env)->ReleasePrimitiveArrayCritical(env, tr, __ntr, __failed ? JNI_ABORT : 0);
  if (__ntl) (*env)->ReleasePrimitiveArrayCritical(env, tl, __ntl, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, xnorm, floatW_val_fieldID, __nxnorm);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slasyf_)(const char *uplo, int *n, int *nb, int *kb, float *a, int *lda, int *ipiv, float *w, int *ldw, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slasyf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slasyf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasyfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jobject kb, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray w, jint offsetw, jint ldw, jobject info) {
  if (!slasyf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nkb = 0;
  int __nlda __attribute__((aligned(8)));
  int __nldw __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnb = nb;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __nlda = lda;
  __nldw = ldw;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  slasyf_(__nuplo, &__nn, &__nnb, &__nkb, __na + offseta, &__nlda, __nipiv + offsetipiv, __nw + offsetw, &__nldw, &__ninfo);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatbs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, int *kd, float *ab, int *ldab, float *x, float *scale, float *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatbs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatbs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatbsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  if (!slatbs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nscale = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nx = NULL;
  float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  slatbs_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, &__nkd, __nab + offsetab, &__nldab, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatdf_)(int *ijob, int *n, float *z, int *ldz, float *rhs, float *rdsum, float *rdscal, int *ipiv, int *jpiv);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatdf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatdf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatdfK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint n, jfloatArray z, jint offsetz, jint ldz, jfloatArray rhs, jint offsetrhs, jobject rdsum, jobject rdscal, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv) {
  if (!slatdf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  float __nrdsum = 0;
  float __nrdscal = 0;
  float *__nz = NULL;
  float *__nrhs = NULL;
  int *__nipiv = NULL;
  int *__njpiv = NULL;
  __nijob = ijob;
  __nn = n;
  __nldz = ldz;
  __nrdsum = (*env)->GetFloatField(env, rdsum, floatW_val_fieldID);
  __nrdscal = (*env)->GetFloatField(env, rdscal, floatW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) { __failed = TRUE; goto done; }
  slatdf_(&__nijob, &__nn, __nz + offsetz, &__nldz, __nrhs + offsetrhs, &__nrdsum, &__nrdscal, __nipiv + offsetipiv, __njpiv + offsetjpiv);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetFloatField(env, rdscal, floatW_val_fieldID, __nrdscal);
  if (!__failed) (*env)->SetFloatField(env, rdsum, floatW_val_fieldID, __nrdsum);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatps_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, float *ap, float *x, float *scale, float *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatps(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatps_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatpsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jfloatArray ap, jint offsetap, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  if (!slatps_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  float __nscale = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nx = NULL;
  float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  slatps_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, __nap + offsetap, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatrd_)(const char *uplo, int *n, int *nb, float *a, int *lda, float *e, float *tau, float *w, int *ldw);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jfloatArray w, jint offsetw, jint ldw) {
  if (!slatrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnb __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldw __attribute__((aligned(8)));
  float *__na = NULL;
  float *__ne = NULL;
  float *__ntau = NULL;
  float *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnb = nb;
  __nlda = lda;
  __nldw = ldw;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  slatrd_(__nuplo, &__nn, &__nnb, __na + offseta, &__nlda, __ne + offsete, __ntau + offsettau, __nw + offsetw, &__nldw);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatrs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, float *a, int *lda, float *x, float *scale, float *cnorm, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  if (!slatrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  const char *__nnormin = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nscale = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nx = NULL;
  float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) { __failed = TRUE; goto done; }
  slatrs_(__nuplo, __ntrans, __ndiag, __nnormin, &__nn, __na + offseta, &__nlda, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatrz_)(int *m, int *n, int *l, float *a, int *lda, float *tau, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatrz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatrz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrzK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork) {
  if (!slatrz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nl = l;
  __nlda = lda;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slatrz_(&__nm, &__nn, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slatzm_)(const char *side, int *m, int *n, float *v, int *incv, float *tau, float *c1, float *c2, int *Ldc, float *work);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slatzm(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slatzm_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatzmK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c1, jint offsetc1, jfloatArray c2, jint offsetc2, jint Ldc, jfloatArray work, jint offsetwork) {
  if (!slatzm_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nincv __attribute__((aligned(8)));
  float __ntau __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  float *__nv = NULL;
  float *__nc1 = NULL;
  float *__nc2 = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nincv = incv;
  __ntau = tau;
  __nLdc = Ldc;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc1 = (*env)->GetPrimitiveArrayCritical(env, c1, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc2 = (*env)->GetPrimitiveArrayCritical(env, c2, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  slatzm_(__nside, &__nm, &__nn, __nv + offsetv, &__nincv, &__ntau, __nc1 + offsetc1, __nc2 + offsetc2, &__nLdc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc2) (*env)->ReleasePrimitiveArrayCritical(env, c2, __nc2, __failed ? JNI_ABORT : 0);
  if (__nc1) (*env)->ReleasePrimitiveArrayCritical(env, c1, __nc1, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slauu2_)(const char *uplo, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slauu2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slauu2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slauu2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!slauu2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slauu2_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*slauum_)(const char *uplo, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slauum(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slauum_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slauumK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!slauum_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  slauum_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

// static void (*slazq3_)(int *i0, int *n0, float *z, int *pp, float *dmin, float *sigma, float *desig, float *qmax, int *nfail, int *iter, int *ndiv, int *ieee, int *ttype, float *dmin1, float *dmin2, float *dn, float *dn1, float *dn2, float *tau);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slazq3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slazq3K(JNIEnv *env, UNUSED jobject obj, UNUSED jint i0, UNUSED jobject n0, UNUSED jfloatArray z, UNUSED jint offsetz, UNUSED jint pp, UNUSED jobject dmin, UNUSED jobject sigma, UNUSED jobject desig, UNUSED jobject qmax, UNUSED jobject nfail, UNUSED jobject iter, UNUSED jobject ndiv, UNUSED jboolean ieee, UNUSED jobject ttype, UNUSED jobject dmin1, UNUSED jobject dmin2, UNUSED jobject dn, UNUSED jobject dn1, UNUSED jobject dn2, UNUSED jobject tau) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*slazq4_)(int *i0, int *n0, float *z, int *pp, int *n0in, float *dmin, float *dmin1, float *dmin2, float *dn, float *dn1, float *dn2, float *tau, int *ttype, float *g);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slazq4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slazq4K(JNIEnv *env, UNUSED jobject obj, UNUSED jint i0, UNUSED jint n0, UNUSED jfloatArray z, UNUSED jint offsetz, UNUSED jint pp, UNUSED jint n0in, UNUSED jfloat dmin, UNUSED jfloat dmin1, UNUSED jfloat dmin2, UNUSED jfloat dn, UNUSED jfloat dn1, UNUSED jfloat dn2, UNUSED jobject tau, UNUSED jobject ttype, UNUSED jobject g) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static void (*sopgtr_)(const char *uplo, int *n, float *ap, float *tau, float *q, int *ldq, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sopgtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sopgtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sopgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray tau, jint offsettau, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject info) {
  if (!sopgtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__ntau = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sopgtr_(__nuplo, &__nn, __nap + offsetap, __ntau + offsettau, __nq + offsetq, &__nldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sopmtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, float *ap, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sopmtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sopmtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sopmtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jfloatArray ap, jint offsetap, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sopmtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sopmtr_(__nside, __nuplo, __ntrans, &__nm, &__nn, __nap + offsetap, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorg2l_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorg2l(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorg2l_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorg2lK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorg2l_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorg2l_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorg2r_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorg2r(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorg2r_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorg2rK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorg2r_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorg2r_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgbr_)(const char *vect, int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgbr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgbr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorgbr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgbr_(__nvect, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorghr_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorghr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorghr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorghrK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorghr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorghr_(&__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgl2_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgl2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgl2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgl2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorgl2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgl2_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorglq_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorglq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorglq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorglqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorglq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorglq_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgql_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgql(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgql_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgqlK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorgql_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgql_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgqr_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgqrK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorgqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgqr_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgr2_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorgr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgr2_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgrq_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgrq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgrq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgrqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorgrq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgrq_(&__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorgtr_)(const char *uplo, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorgtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorgtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sorgtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorgtr_(__nuplo, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorm2l_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorm2l(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorm2l_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorm2lK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorm2l_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorm2l_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorm2r_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorm2r(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorm2r_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorm2rK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorm2r_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorm2r_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormbr_)(const char *vect, const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormbr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormbr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormbr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormbr_(__nvect, __nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormhr_)(const char *side, const char *trans, int *m, int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormhr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormhr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormhrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormhr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nilo __attribute__((aligned(8)));
  int __nihi __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nilo = ilo;
  __nihi = ihi;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormhr_(__nside, __ntrans, &__nm, &__nn, &__nilo, &__nihi, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sorml2_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sorml2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sorml2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorml2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sorml2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sorml2_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormlq_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormlq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormlq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormlqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormlq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormlq_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormql_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormql(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormql_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormqlK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormql_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormql_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormqr_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormqrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormqr_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormr2_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormr2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormr2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormr2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sormr2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormr2_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormr3_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormr3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormr3_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormr3K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  if (!sormr3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nLdc = Ldc;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormr3_(__nside, __ntrans, &__nm, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormrq_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormrq(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormrq_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormrqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormrq_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormrq_(__nside, __ntrans, &__nm, &__nn, &__nk, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormrz_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormrz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormrz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormrzK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormrz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormrz_(__nside, __ntrans, &__nm, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sormtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sormtr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sormtr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!sormtr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nc = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nLdc = Ldc;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sormtr_(__nside, __nuplo, __ntrans, &__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nc + offsetc, &__nLdc, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbcon_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!spbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  spbcon_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbequ_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *s, float *scond, float *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!spbequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nscond = 0;
  float __namax = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  spbequ_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!__failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbrfs_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!spbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nafb = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  spbrfs_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbstf_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbstf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbstf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbstfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  if (!spbstf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  spbstf_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbsv_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!spbsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  spbsv_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbsvx_)(const char *fact, const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!spbsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldafb __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nafb = NULL;
  float *__ns = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldafb = ldafb;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  spbsvx_(__nfact, __nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nafb + offsetafb, &__nldafb, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbtf2_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbtf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbtf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  if (!spbtf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  spbtf2_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbtrf_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbtrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbtrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  if (!spbtrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  spbtrf_(__nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spbtrs_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!spbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  spbtrs_(__nuplo, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spocon_)(const char *uplo, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spocon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spocon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spoconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!spocon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  spocon_(__nuplo, &__nn, __na + offseta, &__nlda, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spoequ_)(int *n, float *a, int *lda, float *s, float *scond, float *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spoequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spoequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spoequK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!spoequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nscond = 0;
  float __namax = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__ns = NULL;
  __nn = n;
  __nlda = lda;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  spoequ_(&__nn, __na + offseta, &__nlda, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!__failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sporfs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sporfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sporfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sporfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sporfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sporfs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sposv_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sposv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sposv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sposvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sposv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sposv_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sposvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sposvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sposvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sposvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sposvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  float *__ns = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sposvx_(__nfact, __nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spotf2_)(const char *uplo, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spotf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spotf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!spotf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  spotf2_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spotrf_)(const char *uplo, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spotrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spotrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!spotrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  spotrf_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spotri_)(const char *uplo, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spotri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spotri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!spotri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  spotri_(__nuplo, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spotrs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spotrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spotrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!spotrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  spotrs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sppcon_)(const char *uplo, int *n, float *ap, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sppcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sppcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sppcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sppcon_(__nuplo, &__nn, __nap + offsetap, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sppequ_)(const char *uplo, int *n, float *ap, float *s, float *scond, float *amax, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sppequ(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sppequ_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  if (!sppequ_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nscond = 0;
  float __namax = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  sppequ_(__nuplo, &__nn, __nap + offsetap, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!__failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spprfs_)(const char *uplo, int *n, int *nrhs, float *ap, float *afp, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!spprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nafp = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  spprfs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sppsv_)(const char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sppsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sppsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sppsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sppsv_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sppsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *ap, float *afp, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sppsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sppsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sppsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  char *__nequed = NULL; jstring __jequed = NULL;
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nafp = NULL;
  float *__ns = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) { __failed = TRUE; goto done; }
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sppsvx_(__nfact, __nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nequed, __ns + offsets, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!__failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spptrf_)(const char *uplo, int *n, float *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spptrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spptrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jobject info) {
  if (!spptrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  spptrf_(__nuplo, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spptri_)(const char *uplo, int *n, float *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jobject info) {
  if (!spptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  spptri_(__nuplo, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spptrs_)(const char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!spptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  spptrs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sptcon_)(int *n, float *d, float *e, float *anorm, float *rcond, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sptcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sptcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptconK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jobject info) {
  if (!sptcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sptcon_(&__nn, __nd + offsetd, __ne + offsete, &__nanorm, &__nrcond, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spteqr_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spteqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spteqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!spteqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  spteqr_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sptrfs_)(int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sptrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sptrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptrfsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray df, jint offsetdf, jfloatArray ef, jint offsetef, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jobject info) {
  if (!sptrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ndf = NULL;
  float *__nef = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sptrfs_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sptsv_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sptsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sptsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sptsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sptsv_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sptsvx_)(const char *fact, int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sptsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sptsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray df, jint offsetdf, jfloatArray ef, jint offsetef, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jobject info) {
  if (!sptsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ndf = NULL;
  float *__nef = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) { __failed = TRUE; goto done; }
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sptsvx_(__nfact, &__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, __failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spttrf_)(int *n, float *d, float *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spttrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spttrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  if (!spttrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  spttrf_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*spttrs_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_spttrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return spttrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spttrsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!spttrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  spttrs_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sptts2_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sptts2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sptts2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptts2K(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb) {
  if (!sptts2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nb = NULL;
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sptts2_(&__nn, &__nnrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &__nldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*srscl_)(int *n, float *sa, float *sx, int *incx);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_srscl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return srscl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_srsclK(JNIEnv *env, UNUSED jobject obj, jint n, jfloat sa, jfloatArray sx, jint offsetsx, jint incx) {
  if (!srscl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  float __nsa __attribute__((aligned(8)));
  int __nincx __attribute__((aligned(8)));
  float *__nsx = NULL;
  __nn = n;
  __nsa = sa;
  __nincx = incx;
  if (!(__nsx = (*env)->GetPrimitiveArrayCritical(env, sx, NULL))) { __failed = TRUE; goto done; }
  srscl_(&__nn, &__nsa, __nsx + offsetsx, &__nincx);
done:
  if (__nsx) (*env)->ReleasePrimitiveArrayCritical(env, sx, __nsx, __failed ? JNI_ABORT : 0);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbev_)(const char *jobz, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssbev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssbev_(__njobz, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbevd_)(const char *jobz, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!ssbevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssbevd_(__njobz, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbevx_)(const char *jobz, const char *range, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray q, jint offsetq, jint ldq, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!ssbevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nq = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldq = ldq;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  ssbevx_(__njobz, __nrange, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nq + offsetq, &__nldq, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbgst_)(const char *vect, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *x, int *ldx, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbgst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbgst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgstK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray x, jint offsetx, jint ldx, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssbgst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nbb = NULL;
  float *__nx = NULL;
  float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssbgst_(__nvect, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nx + offsetx, &__nldx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbgv_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *w, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbgv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbgv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssbgv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nbb = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssbgv_(__njobz, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbgvd_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbgvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbgvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!ssbgvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nbb = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssbgvd_(__njobz, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbgvx_)(const char *jobz, const char *range, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbgvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbgvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray q, jint offsetq, jint ldq, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!ssbgvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nka __attribute__((aligned(8)));
  int __nkb __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldbb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nbb = NULL;
  float *__nq = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nka = ka;
  __nkb = kb;
  __nldab = ldab;
  __nldbb = ldbb;
  __nldq = ldq;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  ssbgvx_(__njobz, __nrange, __nuplo, &__nn, &__nka, &__nkb, __nab + offsetab, &__nldab, __nbb + offsetbb, &__nldbb, __nq + offsetq, &__nldq, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssbtrd_)(const char *vect, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssbtrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssbtrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbtrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssbtrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nvect = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nldq = ldq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssbtrd_(__nvect, __nuplo, &__nn, &__nkd, __nab + offsetab, &__nldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &__nldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspcon_)(const char *uplo, int *n, float *ap, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sspcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sspcon_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspev_)(const char *jobz, const char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!sspev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sspev_(__njobz, __nuplo, &__nn, __nap + offsetap, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspevd_)(const char *jobz, const char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sspevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sspevd_(__njobz, __nuplo, &__nn, __nap + offsetap, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspevx_)(const char *jobz, const char *range, const char *uplo, int *n, float *ap, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!sspevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  sspevx_(__njobz, __nrange, __nuplo, &__nn, __nap + offsetap, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspgst_)(int *itype, const char *uplo, int *n, float *ap, float *bp, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspgst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspgst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jobject info) {
  if (!sspgst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nbp = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  sspgst_(&__nitype, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, &__ninfo);
done:
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspgv_)(int *itype, const char *jobz, const char *uplo, int *n, float *ap, float *bp, float *w, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspgv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspgv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!sspgv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nbp = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sspgv_(&__nitype, __njobz, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspgvd_)(int *itype, const char *jobz, const char *uplo, int *n, float *ap, float *bp, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspgvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspgvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sspgvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nbp = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sspgvd_(&__nitype, __njobz, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspgvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, float *ap, float *bp, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspgvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspgvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!sspgvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nbp = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  sspgvx_(&__nitype, __njobz, __nrange, __nuplo, &__nn, __nap + offsetap, __nbp + offsetbp, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssprfs_)(const char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!ssprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nafp = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssprfs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspsv_)(const char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspsv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspsv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!sspsv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  sspsv_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sspsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sspsvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sspsvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sspsvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nafp = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sspsvx_(__nfact, __nuplo, &__nn, &__nnrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssptrd_)(const char *uplo, int *n, float *ap, float *d, float *e, float *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssptrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssptrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jobject info) {
  if (!ssptrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  ssptrd_(__nuplo, &__nn, __nap + offsetap, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssptrf_)(const char *uplo, int *n, float *ap, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssptrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssptrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!ssptrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  ssptrf_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssptri_)(const char *uplo, int *n, float *ap, int *ipiv, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssptri_(__nuplo, &__nn, __nap + offsetap, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssptrs_)(const char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!ssptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  ssptrs_(__nuplo, &__nn, &__nnrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstebz_)(const char *range, const char *order, int *n, float *vl, float *vu, int *il, int *iu, float *abstol, float *d, float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstebz(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstebz_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstebzK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject m, jobject nsplit, jfloatArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!sstebz_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nrange = NULL;
  const char *__norder = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nnsplit = 0;
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  int *__niblock = NULL;
  int *__nisplit = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstebz_(__nrange, __norder, &__nn, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, __nd + offsetd, __ne + offsete, &__nm, &__nnsplit, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstedc_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstedc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstedc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstedcK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sstedc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstedc_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstegr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstegr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstegr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstegrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sstegr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstegr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstein_)(int *n, float *d, float *e, int *m, float *w, int *iblock, int *isplit, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstein(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstein_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssteinK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jint m, jfloatArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!sstein_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  int *__niblock = NULL;
  int *__nisplit = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nn = n;
  __nm = m;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  sstein_(&__nn, __nd + offsetd, __ne + offsete, &__nm, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, __failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstemr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, int *m, float *w, float *z, int *ldz, int *nzc, int *isuppz, int *tryrac, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstemr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstemr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstemrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jint nzc, jintArray isuppz, jint offsetisuppz, jobject tryrac, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sstemr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nnzc __attribute__((aligned(8)));
  int __ntryrac = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nnzc = nzc;
  __ntryrac = (*env)->GetBooleanField(env, tryrac, booleanW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstemr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, &__nnzc, __nisuppz + offsetisuppz, &__ntryrac, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetBooleanField(env, tryrac, booleanW_val_fieldID, __ntryrac);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssteqr_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssteqr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssteqr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssteqr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssteqr_(__ncompz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssterf_)(int *n, float *d, float *e, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssterf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssterf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssterfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  if (!ssterf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  ssterf_(&__nn, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstev_)(const char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  if (!sstev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  sstev_(__njobz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstevd_)(const char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sstevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstevd_(__njobz, &__nn, __nd + offsetd, __ne + offsete, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstevr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstevr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstevr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!sstevr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  sstevr_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*sstevx_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_sstevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return sstevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!sstevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  int __nn __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  sstevx_(__njobz, __nrange, &__nn, __nd + offsetd, __ne + offsete, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssycon_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssycon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssycon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!ssycon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nanorm __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nanorm = anorm;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssycon_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__nanorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssyev_)(const char *jobz, const char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssyev(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssyev_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!ssyev_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nw = NULL;
  float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssyev_(__njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nw + offsetw, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssyevd_)(const char *jobz, const char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssyevd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssyevd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!ssyevd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nw = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssyevd_(__njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nw + offsetw, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssyevr_)(const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssyevr(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssyevr_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!ssyevr_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  int *__nisuppz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssyevr_(__njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssyevx_)(const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssyevx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssyevx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!ssyevx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  ssyevx_(__njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssygs2_)(int *itype, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssygs2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssygs2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygs2K(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!ssygs2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  ssygs2_(&__nitype, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssygst_)(int *itype, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssygst(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssygst_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!ssygst_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  __nitype = itype;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  ssygst_(&__nitype, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssygv_)(int *itype, const char *jobz, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *w, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssygv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssygv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!ssygv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nw = NULL;
  float *__nwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssygv_(&__nitype, __njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nw + offsetw, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssygvd_)(int *itype, const char *jobz, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *w, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssygvd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssygvd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!ssygvd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nw = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssygvd_(&__nitype, __njobz, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nw + offsetw, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssygvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *ifail, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssygvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssygvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  if (!ssygvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nitype __attribute__((aligned(8)));
  const char *__njobz = NULL;
  const char *__nrange = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __nvl __attribute__((aligned(8)));
  float __nvu __attribute__((aligned(8)));
  int __nil __attribute__((aligned(8)));
  int __niu __attribute__((aligned(8)));
  float __nabstol __attribute__((aligned(8)));
  int __nm = 0;
  int __nldz __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nw = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  int *__nifail = NULL;
  __nitype = itype;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) { __failed = TRUE; goto done; }
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nvl = vl;
  __nvu = vu;
  __nil = il;
  __niu = iu;
  __nabstol = abstol;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldz = ldz;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) { __failed = TRUE; goto done; }
  ssygvx_(&__nitype, __njobz, __nrange, __nuplo, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__nvl, &__nvu, &__nil, &__niu, &__nabstol, &__nm, __nw + offsetw, __nz + offsetz, &__nldz, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, __failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssyrfs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssyrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssyrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!ssyrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssyrfs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssysv_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssysv(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssysv_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssysvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!ssysv_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssysv_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssysvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssysvx(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssysvx_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssysvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!ssysvx_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nfact = NULL;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldaf __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  float __nrcond = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__naf = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldaf = ldaf;
  __nldb = ldb;
  __nldx = ldx;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  ssysvx_(__nfact, __nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __naf + offsetaf, &__nldaf, __nipiv + offsetipiv, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytd2_)(const char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytd2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytd2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytd2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jobject info) {
  if (!ssytd2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  ssytd2_(__nuplo, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytf2_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytf2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytf2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  if (!ssytf2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  ssytf2_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytrd_)(const char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytrd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytrd_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!ssytrd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssytrd_(__nuplo, &__nn, __na + offseta, &__nlda, __nd + offsetd, __ne + offsete, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytrf_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytrf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytrf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!ssytrf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssytrf_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytri_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jobject info) {
  if (!ssytri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  ssytri_(__nuplo, &__nn, __na + offseta, &__nlda, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*ssytrs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_ssytrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return ssytrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!ssytrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  int *__nipiv = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  ssytrs_(__nuplo, &__nn, &__nnrhs, __na + offseta, &__nlda, __nipiv + offsetipiv, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stbcon_)(const char *norm, const char *uplo, const char *diag, int *n, int *kd, float *ab, int *ldab, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stbcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stbcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stbcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nldab = ldab;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stbcon_(__nnorm, __nuplo, __ndiag, &__nn, &__nkd, __nab + offsetab, &__nldab, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stbrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stbrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stbrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stbrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stbrfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stbtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stbtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stbtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!stbtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nkd __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldab __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nab = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nkd = kd;
  __nnrhs = nrhs;
  __nldab = ldab;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  stbtrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nkd, &__nnrhs, __nab + offsetab, &__nldab, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgevc_)(const char *side, const char *howmny, int *select, int *n, float *s, int *lds, float *p, int *ldp, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgevc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgevc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray s, jint offsets, jint lds, jfloatArray p, jint offsetp, jint ldp, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jobject info) {
  if (!stgevc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlds __attribute__((aligned(8)));
  int __nldp __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__ns = NULL;
  float *__np = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlds = lds;
  __nldp = ldp;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__np = (*env)->GetPrimitiveArrayCritical(env, p, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  stgevc_(__nside, __nhowmny, __nselect + offsetselect, &__nn, __ns + offsets, &__nlds, __np + offsetp, &__nldp, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__np) (*env)->ReleasePrimitiveArrayCritical(env, p, __np, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgex2_)(int *wantq, int *wantz, int *n, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *j1, int *n1, int *n2, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgex2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgex2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgex2K(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jint j1, jint n1, jint n2, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!stgex2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nj1 __attribute__((aligned(8)));
  int __nn1 __attribute__((aligned(8)));
  int __nn2 __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nq = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nj1 = j1;
  __nn1 = n1;
  __nn2 = n2;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  stgex2_(&__nwantq, &__nwantz, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nj1, &__nn1, &__nn2, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgexc_)(int *wantq, int *wantz, int *n, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *ifst, int *ilst, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject ifst, jobject ilst, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!stgexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nifst = 0;
  int __nilst = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nq = NULL;
  float *__nz = NULL;
  float *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  stgexc_(&__nwantq, &__nwantz, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nifst, &__nilst, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!__failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgsen_)(int *ijob, int *wantq, int *wantz, int *select, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *q, int *ldq, float *z, int *ldz, int *m, float *pl, float *pr, float *dif, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgsen(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgsen_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsenK(JNIEnv *env, UNUSED jobject obj, jint ijob, jboolean wantq, jboolean wantz, jbooleanArray select, jint offsetselect, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject m, jobject pl, jobject pr, jfloatArray dif, jint offsetdif, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!stgsen_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nijob __attribute__((aligned(8)));
  int __nwantq __attribute__((aligned(8)));
  int __nwantz __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nldz __attribute__((aligned(8)));
  int __nm = 0;
  float __npl = 0;
  float __npr = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalphar = NULL;
  float *__nalphai = NULL;
  float *__nbeta = NULL;
  float *__nq = NULL;
  float *__nz = NULL;
  float *__ndif = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  __nijob = ijob;
  __nwantq = wantq;
  __nwantz = wantz;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldq = ldq;
  __nldz = ldz;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npl = (*env)->GetFloatField(env, pl, floatW_val_fieldID);
  __npr = (*env)->GetFloatField(env, pr, floatW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stgsen_(&__nijob, &__nwantq, &__nwantz, __nselect + offsetselect, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &__nldq, __nz + offsetz, &__nldz, &__nm, &__npl, &__npr, __ndif + offsetdif, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, __failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, __failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, pr, floatW_val_fieldID, __npr);
  if (!__failed) (*env)->SetFloatField(env, pl, floatW_val_fieldID, __npl);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgsja_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *ncycle, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgsja(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgsja_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsjaK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat tola, jfloat tolb, jfloatArray alpha, jint offsetalpha, jfloatArray beta, jint offsetbeta, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject ncycle, jobject info) {
  if (!stgsja_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njobu = NULL;
  const char *__njobv = NULL;
  const char *__njobq = NULL;
  int __nm __attribute__((aligned(8)));
  int __np __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nk __attribute__((aligned(8)));
  int __nl __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  float __ntola __attribute__((aligned(8)));
  float __ntolb __attribute__((aligned(8)));
  int __nldu __attribute__((aligned(8)));
  int __nldv __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nncycle = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nalpha = NULL;
  float *__nbeta = NULL;
  float *__nu = NULL;
  float *__nv = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) { __failed = TRUE; goto done; }
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) { __failed = TRUE; goto done; }
  __nm = m;
  __np = p;
  __nn = n;
  __nk = k;
  __nl = l;
  __nlda = lda;
  __nldb = ldb;
  __ntola = tola;
  __ntolb = tolb;
  __nldu = ldu;
  __nldv = ldv;
  __nldq = ldq;
  __nncycle = (*env)->GetIntField(env, ncycle, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) { __failed = TRUE; goto done; }
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) { __failed = TRUE; goto done; }
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) { __failed = TRUE; goto done; }
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  stgsja_(__njobu, __njobv, __njobq, &__nm, &__np, &__nn, &__nk, &__nl, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ntola, &__ntolb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &__nldu, __nv + offsetv, &__nldv, __nq + offsetq, &__nldq, __nwork + offsetwork, &__nncycle, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, __failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, __failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, __failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ncycle, intW_val_fieldID, __nncycle);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgsna_)(const char *job, const char *howmny, int *select, int *n, float *a, int *lda, float *b, int *ldb, float *vl, int *ldvl, float *vr, int *ldvr, float *s, float *dif, int *mm, int *m, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgsna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgsna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray s, jint offsets, jfloatArray dif, jint offsetdif, jint mm, jobject m, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stgsna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__ns = NULL;
  float *__ndif = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stgsna_(__njob, __nhowmny, __nselect + offsetselect, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __ns + offsets, __ndif + offsetdif, &__nmm, &__nm, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgsy2_)(const char *trans, int *ijob, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *d, int *ldd, float *e, int *lde, float *f, int *ldf, float *scale, float *rdsum, float *rdscal, int *iwork, int *pq, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgsy2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgsy2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsy2K(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jfloatArray d, jint offsetd, jint ldd, jfloatArray e, jint offsete, jint lde, jfloatArray f, jint offsetf, jint ldf, jobject scale, jobject rdsum, jobject rdscal, jintArray iwork, jint offsetiwork, jobject pq, jobject info) {
  if (!stgsy2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nijob __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldd __attribute__((aligned(8)));
  int __nlde __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  float __nscale = 0;
  float __nrdsum = 0;
  float __nrdscal = 0;
  int __npq = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nf = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nijob = ijob;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nldd = ldd;
  __nlde = lde;
  __nldf = ldf;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nrdsum = (*env)->GetFloatField(env, rdsum, floatW_val_fieldID);
  __nrdscal = (*env)->GetFloatField(env, rdscal, floatW_val_fieldID);
  __npq = (*env)->GetIntField(env, pq, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stgsy2_(__ntrans, &__nijob, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, __nd + offsetd, &__nldd, __ne + offsete, &__nlde, __nf + offsetf, &__nldf, &__nscale, &__nrdsum, &__nrdscal, __niwork + offsetiwork, &__npq, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, pq, intW_val_fieldID, __npq);
  if (!__failed) (*env)->SetFloatField(env, rdscal, floatW_val_fieldID, __nrdscal);
  if (!__failed) (*env)->SetFloatField(env, rdsum, floatW_val_fieldID, __nrdsum);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stgsyl_)(const char *trans, int *ijob, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *d, int *ldd, float *e, int *lde, float *f, int *ldf, float *scale, float *dif, float *work, int *lwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stgsyl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stgsyl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsylK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jfloatArray d, jint offsetd, jint ldd, jfloatArray e, jint offsete, jint lde, jfloatArray f, jint offsetf, jint ldf, jobject scale, jobject dif, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stgsyl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrans = NULL;
  int __nijob __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  int __nldd __attribute__((aligned(8)));
  int __nlde __attribute__((aligned(8)));
  int __nldf __attribute__((aligned(8)));
  float __nscale = 0;
  float __ndif = 0;
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  float *__nd = NULL;
  float *__ne = NULL;
  float *__nf = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  __nijob = ijob;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nldd = ldd;
  __nlde = lde;
  __nldf = ldf;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ndif = (*env)->GetFloatField(env, dif, floatW_val_fieldID);
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) { __failed = TRUE; goto done; }
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) { __failed = TRUE; goto done; }
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stgsyl_(__ntrans, &__nijob, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, __nd + offsetd, &__nldd, __ne + offsete, &__nlde, __nf + offsetf, &__nldf, &__nscale, &__ndif, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, __failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, __failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, __failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, dif, floatW_val_fieldID, __ndif);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stpcon_)(const char *norm, const char *uplo, const char *diag, int *n, float *ap, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stpcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stpcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stpconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stpcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stpcon_(__nnorm, __nuplo, __ndiag, &__nn, __nap + offsetap, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stprfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stprfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stprfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!stprfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  stprfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stptri_)(const char *uplo, const char *diag, int *n, float *ap, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stptri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stptri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jobject info) {
  if (!stptri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  stptri_(__nuplo, __ndiag, &__nn, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stptrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stptrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stptrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!stptrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__nap = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  stptrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __nap + offsetap, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strcon_)(const char *norm, const char *uplo, const char *diag, int *n, float *a, int *lda, float *rcond, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strcon(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strcon_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!strcon_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nnorm = NULL;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  float __nrcond = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) { __failed = TRUE; goto done; }
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  strcon_(__nnorm, __nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strevc_)(const char *side, const char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strevc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strevc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jobject info) {
  if (!strevc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nside = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__nt = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  strevc_(__nside, __nhowmny, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, &__nmm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strexc_)(const char *compq, int *n, float *t, int *ldt, float *q, int *ldq, int *ifst, int *ilst, float *work, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strexc(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strexc_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strexcK(JNIEnv *env, UNUSED jobject obj, jstring compq, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jobject ifst, jobject ilst, jfloatArray work, jint offsetwork, jobject info) {
  if (!strexc_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nifst = 0;
  int __nilst = 0;
  int __ninfo = 0;
  float *__nt = NULL;
  float *__nq = NULL;
  float *__nwork = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  strexc_(__ncompq, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, &__nifst, &__nilst, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!__failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strrfs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strrfs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!strrfs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nldx __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nx = NULL;
  float *__nferr = NULL;
  float *__nberr = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __nldx = ldx;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) { __failed = TRUE; goto done; }
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  strrfs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nx + offsetx, &__nldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, __failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, __failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strsen_)(const char *job, const char *compq, int *select, int *n, float *t, int *ldt, float *q, int *ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int *lwork, int *iwork, int *liwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strsen(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strsen_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsenK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jobject m, jobject s, jobject sep, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  if (!strsen_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__ncompq = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldq __attribute__((aligned(8)));
  int __nm = 0;
  float __ns = 0;
  float __nsep = 0;
  int __nlwork __attribute__((aligned(8)));
  int __nliwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__nt = NULL;
  float *__nq = NULL;
  float *__nwr = NULL;
  float *__nwi = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldq = ldq;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __nsep = (*env)->GetFloatField(env, sep, floatW_val_fieldID);
  __nlwork = lwork;
  __nliwork = liwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  strsen_(__njob, __ncompq, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nq + offsetq, &__nldq, __nwr + offsetwr, __nwi + offsetwi, &__nm, &__ns, &__nsep, __nwork + offsetwork, &__nlwork, __niwork + offsetiwork, &__nliwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, __failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, __failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, sep, floatW_val_fieldID, __nsep);
  if (!__failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strsna_)(const char *job, const char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, float *s, float *sep, int *mm, int *m, float *work, int *ldwork, int *iwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strsna(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strsna_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray s, jint offsets, jfloatArray sep, jint offsetsep, jint mm, jobject m, jfloatArray work, jint offsetwork, jint ldwork, jintArray iwork, jint offsetiwork, jobject info) {
  if (!strsna_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__njob = NULL;
  const char *__nhowmny = NULL;
  int __nn __attribute__((aligned(8)));
  int __nldt __attribute__((aligned(8)));
  int __nldvl __attribute__((aligned(8)));
  int __nldvr __attribute__((aligned(8)));
  int __nmm __attribute__((aligned(8)));
  int __nm = 0;
  int __nldwork __attribute__((aligned(8)));
  int __ninfo = 0;
  int *__nselect = NULL; jboolean *__jselect = NULL;
  float *__nt = NULL;
  float *__nvl = NULL;
  float *__nvr = NULL;
  float *__ns = NULL;
  float *__nsep = NULL;
  float *__nwork = NULL;
  int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) { __failed = TRUE; goto done; }
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nldt = ldt;
  __nldvl = ldvl;
  __nldvr = ldvr;
  __nmm = mm;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nldwork = ldwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { __failed = TRUE; goto done; }
  do {
    int __length = (*env)->GetArrayLength(env, select);
    if (__length <= 0) { __failed = TRUE; goto done; }
    if (!(__nselect = malloc(sizeof(int) * __length))) { __failed = TRUE; goto done; }
    for (int i = 0; i < __length; i++) { __nselect[i] = __jselect[i]; }
  } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) { __failed = TRUE; goto done; }
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) { __failed = TRUE; goto done; }
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) { __failed = TRUE; goto done; }
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) { __failed = TRUE; goto done; }
  strsna_(__njob, __nhowmny, __nselect + offsetselect, &__nn, __nt + offsett, &__nldt, __nvl + offsetvl, &__nldvl, __nvr + offsetvr, &__nldvr, __ns + offsets, __nsep + offsetsep, &__nmm, &__nm, __nwork + offsetwork, &__nldwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, __failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, __failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, __failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, __failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, __failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, __failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strsyl_)(const char *trana, const char *tranb, int *isgn, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *scale, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strsyl(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strsyl_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsylK(JNIEnv *env, UNUSED jobject obj, jstring trana, jstring tranb, jint isgn, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jobject scale, jobject info) {
  if (!strsyl_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__ntrana = NULL;
  const char *__ntranb = NULL;
  int __nisgn __attribute__((aligned(8)));
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __nLdc __attribute__((aligned(8)));
  float __nscale = 0;
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  float *__nc = NULL;
  if (!(__ntrana = (*env)->GetStringUTFChars(env, trana, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntranb = (*env)->GetStringUTFChars(env, tranb, NULL))) { __failed = TRUE; goto done; }
  __nisgn = isgn;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nldb = ldb;
  __nLdc = Ldc;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) { __failed = TRUE; goto done; }
  strsyl_(__ntrana, __ntranb, &__nisgn, &__nm, &__nn, __na + offseta, &__nlda, __nb + offsetb, &__nldb, __nc + offsetc, &__nLdc, &__nscale, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, __failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!__failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntranb) (*env)->ReleaseStringUTFChars(env, tranb, __ntranb);
  if (__ntrana) (*env)->ReleaseStringUTFChars(env, trana, __ntrana);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strti2_)(const char *uplo, const char *diag, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strti2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strti2_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strti2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!strti2_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  strti2_(__nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strtri_)(const char *uplo, const char *diag, int *n, float *a, int *lda, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strtri(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strtri_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strtriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  if (!strtri_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  strtri_(__nuplo, __ndiag, &__nn, __na + offseta, &__nlda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*strtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_strtrs(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return strtrs_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  if (!strtrs_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  const char *__nuplo = NULL;
  const char *__ntrans = NULL;
  const char *__ndiag = NULL;
  int __nn __attribute__((aligned(8)));
  int __nnrhs __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nldb __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) { __failed = TRUE; goto done; }
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) { __failed = TRUE; goto done; }
  __nn = n;
  __nnrhs = nrhs;
  __nlda = lda;
  __nldb = ldb;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) { __failed = TRUE; goto done; }
  strtrs_(__nuplo, __ntrans, __ndiag, &__nn, &__nnrhs, __na + offseta, &__nlda, __nb + offsetb, &__nldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stzrqf_)(int *m, int *n, float *a, int *lda, float *tau, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stzrqf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stzrqf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stzrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jobject info) {
  if (!stzrqf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  stzrqf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*stzrzf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_stzrzf(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return stzrzf_ != NULL;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stzrzfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  if (!stzrzf_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __failed = FALSE;
  int __nm __attribute__((aligned(8)));
  int __nn __attribute__((aligned(8)));
  int __nlda __attribute__((aligned(8)));
  int __nlwork __attribute__((aligned(8)));
  int __ninfo = 0;
  float *__na = NULL;
  float *__ntau = NULL;
  float *__nwork = NULL;
  __nm = m;
  __nn = n;
  __nlda = lda;
  __nlwork = lwork;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) { __failed = TRUE; goto done; }
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) { __failed = TRUE; goto done; }
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) { __failed = TRUE; goto done; }
  stzrzf_(&__nm, &__nn, __na + offseta, &__nlda, __ntau + offsettau, __nwork + offsetwork, &__nlwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, __failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, __failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, __failed ? JNI_ABORT : 0);
  if (!__failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static double (*dlamch_)(const char *cmach);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamch(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlamch_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamchK(JNIEnv *env, UNUSED jobject obj, jstring cmach) {
  if (!dlamch_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  const char *__ncmach = NULL;
  if (!(__ncmach = (*env)->GetStringUTFChars(env, cmach, NULL))) { __failed = TRUE; goto done; }
  __ret = dlamch_(__ncmach);
done:
  if (__ncmach) (*env)->ReleaseStringUTFChars(env, cmach, __ncmach);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

// static void (*dlamc1_)(int *beta, int *t, int *rnd, int *ieee1);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamc1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc1K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject beta, UNUSED jobject t, UNUSED jobject rnd, UNUSED jobject ieee1) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dlamc2_)(int *beta, int *t, int *rnd, double *eps, int *emin, double *rmin, int *emax, double *rmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc2K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject beta, UNUSED jobject t, UNUSED jobject rnd, UNUSED jobject eps, UNUSED jobject emin, UNUSED jobject rmin, UNUSED jobject emax, UNUSED jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static double (*dlamc3_)(double *a, double *b);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamc3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dlamc3_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc3K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b) {
  if (!dlamc3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  double __na __attribute__((aligned(8)));
  double __nb __attribute__((aligned(8)));
  __na = a;
  __nb = b;
  __ret = dlamc3_(&__na, &__nb);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

// static void (*dlamc4_)(int *emin, double *start, int *base);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamc4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc4K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject emin, UNUSED jdouble start, UNUSED jint base) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dlamc5_)(int *beta, int *p, int *emin, int *ieee, int *emax, double *rmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dlamc5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc5K(JNIEnv *env, UNUSED jobject obj, UNUSED jint beta, UNUSED jint p, UNUSED jint emin, UNUSED jboolean ieee, UNUSED jobject emax, UNUSED jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static double (*dsecnd_)();

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_dsecnd(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return dsecnd_ != NULL;
}

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dsecndK(JNIEnv *env, UNUSED jobject obj) {
  if (!dsecnd_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jdouble __ret = 0;
  jboolean __failed = FALSE;
  __ret = dsecnd_();
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static int (*lsame_)(const char *ca, const char *cb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_lsame(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return lsame_ != NULL;
}

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_lsameK(JNIEnv *env, UNUSED jobject obj, jstring ca, jstring cb) {
  if (!lsame_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jboolean __ret = 0;
  jboolean __failed = FALSE;
  const char *__nca = NULL;
  const char *__ncb = NULL;
  if (!(__nca = (*env)->GetStringUTFChars(env, ca, NULL))) { __failed = TRUE; goto done; }
  if (!(__ncb = (*env)->GetStringUTFChars(env, cb, NULL))) { __failed = TRUE; goto done; }
  __ret = lsame_(__nca, __ncb);
done:
  if (__ncb) (*env)->ReleaseStringUTFChars(env, cb, __ncb);
  if (__nca) (*env)->ReleaseStringUTFChars(env, ca, __nca);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*second_)();

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_second(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return second_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_secondK(JNIEnv *env, UNUSED jobject obj) {
  if (!second_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  __ret = second_();
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

static float (*slamch_)(const char *cmach);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamch(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slamch_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slamchK(JNIEnv *env, UNUSED jobject obj, jstring cmach) {
  if (!slamch_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  const char *__ncmach = NULL;
  if (!(__ncmach = (*env)->GetStringUTFChars(env, cmach, NULL))) { __failed = TRUE; goto done; }
  __ret = slamch_(__ncmach);
done:
  if (__ncmach) (*env)->ReleaseStringUTFChars(env, cmach, __ncmach);
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

// static void (*slamc1_)(int *beta, int *t, int *rnd, int *ieee1);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamc1(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc1K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject beta, UNUSED jobject t, UNUSED jobject rnd, UNUSED jobject ieee1) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*slamc2_)(int *beta, int *t, int *rnd, float *eps, int *emin, float *rmin, int *emax, float *rmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamc2(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc2K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject beta, UNUSED jobject t, UNUSED jobject rnd, UNUSED jobject eps, UNUSED jobject emin, UNUSED jobject rmin, UNUSED jobject emax, UNUSED jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

static float (*slamc3_)(float *a, float *b);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamc3(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return slamc3_ != NULL;
}

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc3K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b) {
  if (!slamc3_) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "symbol isn't available in native library");
  jfloat __ret = 0;
  jboolean __failed = FALSE;
  float __na __attribute__((aligned(8)));
  float __nb __attribute__((aligned(8)));
  __na = a;
  __nb = b;
  __ret = slamc3_(&__na, &__nb);
done:
  if (__failed) (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
  return __ret;
}

// static void (*slamc4_)(int *emin, float *start, int *base);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamc4(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc4K(JNIEnv *env, UNUSED jobject obj, UNUSED jobject emin, UNUSED jfloat start, UNUSED jint base) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*slamc5_)(int *beta, int *p, int *emin, int *ieee, int *emax, float *rmax);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_has_slamc5(UNUSED JNIEnv *env, UNUSED jobject obj) {
  return FALSE;
}

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc5K(JNIEnv *env, UNUSED jobject obj, UNUSED jint beta, UNUSED jint p, UNUSED jint emin, UNUSED jboolean ieee, UNUSED jobject emax, UNUSED jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

jboolean get_system_property(JNIEnv *env, jstring key, jstring def, jstring *res) {
  jclass System_class = (*env)->FindClass(env, "java/lang/System");
  if (!System_class) {
    return FALSE;
  }
  jmethodID System_getProperty_methodID = (*env)->GetStaticMethodID(env, System_class, "getProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
  if (!System_getProperty_methodID) {
    return FALSE;
  }
  *res = (jstring)(*env)->CallStaticObjectMethod(env, System_class, System_getProperty_methodID, key, def);
  return TRUE;
}

jboolean load_symbols(void) {
#define LOAD_SYMBOL(name) \
  name = dlsym(NULL, #name);

  LOAD_SYMBOL(dbdsdc_);
  LOAD_SYMBOL(dbdsqr_);
  LOAD_SYMBOL(ddisna_);
  LOAD_SYMBOL(dgbbrd_);
  LOAD_SYMBOL(dgbcon_);
  LOAD_SYMBOL(dgbequ_);
  LOAD_SYMBOL(dgbrfs_);
  LOAD_SYMBOL(dgbsv_);
  LOAD_SYMBOL(dgbsvx_);
  LOAD_SYMBOL(dgbtf2_);
  LOAD_SYMBOL(dgbtrf_);
  LOAD_SYMBOL(dgbtrs_);
  LOAD_SYMBOL(dgebak_);
  LOAD_SYMBOL(dgebal_);
  LOAD_SYMBOL(dgebd2_);
  LOAD_SYMBOL(dgebrd_);
  LOAD_SYMBOL(dgecon_);
  LOAD_SYMBOL(dgeequ_);
  // LOAD_SYMBOL(dgees_);
  // LOAD_SYMBOL(dgeesx_);
  LOAD_SYMBOL(dgeev_);
  LOAD_SYMBOL(dgeevx_);
  LOAD_SYMBOL(dgegs_);
  LOAD_SYMBOL(dgegv_);
  LOAD_SYMBOL(dgehd2_);
  LOAD_SYMBOL(dgehrd_);
  LOAD_SYMBOL(dgelq2_);
  LOAD_SYMBOL(dgelqf_);
  LOAD_SYMBOL(dgels_);
  LOAD_SYMBOL(dgelsd_);
  LOAD_SYMBOL(dgelss_);
  LOAD_SYMBOL(dgelsx_);
  LOAD_SYMBOL(dgelsy_);
  LOAD_SYMBOL(dgeql2_);
  LOAD_SYMBOL(dgeqlf_);
  LOAD_SYMBOL(dgeqp3_);
  LOAD_SYMBOL(dgeqpf_);
  LOAD_SYMBOL(dgeqr2_);
  LOAD_SYMBOL(dgeqrf_);
  LOAD_SYMBOL(dgerfs_);
  LOAD_SYMBOL(dgerq2_);
  LOAD_SYMBOL(dgerqf_);
  LOAD_SYMBOL(dgesc2_);
  LOAD_SYMBOL(dgesdd_);
  LOAD_SYMBOL(dgesv_);
  LOAD_SYMBOL(dgesvd_);
  LOAD_SYMBOL(dgesvx_);
  LOAD_SYMBOL(dgetc2_);
  LOAD_SYMBOL(dgetf2_);
  LOAD_SYMBOL(dgetrf_);
  LOAD_SYMBOL(dgetri_);
  LOAD_SYMBOL(dgetrs_);
  LOAD_SYMBOL(dggbak_);
  LOAD_SYMBOL(dggbal_);
  // LOAD_SYMBOL(dgges_);
  // LOAD_SYMBOL(dggesx_);
  LOAD_SYMBOL(dggev_);
  LOAD_SYMBOL(dggevx_);
  LOAD_SYMBOL(dggglm_);
  LOAD_SYMBOL(dgghrd_);
  LOAD_SYMBOL(dgglse_);
  LOAD_SYMBOL(dggqrf_);
  LOAD_SYMBOL(dggrqf_);
  LOAD_SYMBOL(dggsvd_);
  LOAD_SYMBOL(dggsvp_);
  LOAD_SYMBOL(dgtcon_);
  LOAD_SYMBOL(dgtrfs_);
  LOAD_SYMBOL(dgtsv_);
  LOAD_SYMBOL(dgtsvx_);
  LOAD_SYMBOL(dgttrf_);
  LOAD_SYMBOL(dgttrs_);
  LOAD_SYMBOL(dgtts2_);
  LOAD_SYMBOL(dhgeqz_);
  LOAD_SYMBOL(dhsein_);
  LOAD_SYMBOL(dhseqr_);
  LOAD_SYMBOL(disnan_);
  LOAD_SYMBOL(dlabad_);
  LOAD_SYMBOL(dlabrd_);
  LOAD_SYMBOL(dlacn2_);
  LOAD_SYMBOL(dlacon_);
  LOAD_SYMBOL(dlacpy_);
  LOAD_SYMBOL(dladiv_);
  LOAD_SYMBOL(dlae2_);
  LOAD_SYMBOL(dlaebz_);
  LOAD_SYMBOL(dlaed0_);
  LOAD_SYMBOL(dlaed1_);
  LOAD_SYMBOL(dlaed2_);
  LOAD_SYMBOL(dlaed3_);
  LOAD_SYMBOL(dlaed4_);
  LOAD_SYMBOL(dlaed5_);
  LOAD_SYMBOL(dlaed6_);
  LOAD_SYMBOL(dlaed7_);
  LOAD_SYMBOL(dlaed8_);
  LOAD_SYMBOL(dlaed9_);
  LOAD_SYMBOL(dlaeda_);
  LOAD_SYMBOL(dlaein_);
  LOAD_SYMBOL(dlaev2_);
  LOAD_SYMBOL(dlaexc_);
  LOAD_SYMBOL(dlag2_);
  LOAD_SYMBOL(dlag2s_);
  LOAD_SYMBOL(dlags2_);
  LOAD_SYMBOL(dlagtf_);
  LOAD_SYMBOL(dlagtm_);
  LOAD_SYMBOL(dlagts_);
  LOAD_SYMBOL(dlagv2_);
  LOAD_SYMBOL(dlahqr_);
  LOAD_SYMBOL(dlahr2_);
  LOAD_SYMBOL(dlahrd_);
  LOAD_SYMBOL(dlaic1_);
  LOAD_SYMBOL(dlaisnan_);
  LOAD_SYMBOL(dlaln2_);
  LOAD_SYMBOL(dlals0_);
  LOAD_SYMBOL(dlalsa_);
  LOAD_SYMBOL(dlalsd_);
  LOAD_SYMBOL(dlamrg_);
  LOAD_SYMBOL(dlaneg_);
  LOAD_SYMBOL(dlangb_);
  LOAD_SYMBOL(dlange_);
  LOAD_SYMBOL(dlangt_);
  LOAD_SYMBOL(dlanhs_);
  LOAD_SYMBOL(dlansb_);
  LOAD_SYMBOL(dlansp_);
  LOAD_SYMBOL(dlanst_);
  LOAD_SYMBOL(dlansy_);
  LOAD_SYMBOL(dlantb_);
  LOAD_SYMBOL(dlantp_);
  LOAD_SYMBOL(dlantr_);
  LOAD_SYMBOL(dlanv2_);
  LOAD_SYMBOL(dlapll_);
  LOAD_SYMBOL(dlapmt_);
  LOAD_SYMBOL(dlapy2_);
  LOAD_SYMBOL(dlapy3_);
  LOAD_SYMBOL(dlaqgb_);
  LOAD_SYMBOL(dlaqge_);
  LOAD_SYMBOL(dlaqp2_);
  LOAD_SYMBOL(dlaqps_);
  LOAD_SYMBOL(dlaqr0_);
  LOAD_SYMBOL(dlaqr1_);
  LOAD_SYMBOL(dlaqr2_);
  LOAD_SYMBOL(dlaqr3_);
  LOAD_SYMBOL(dlaqr4_);
  LOAD_SYMBOL(dlaqr5_);
  LOAD_SYMBOL(dlaqsb_);
  LOAD_SYMBOL(dlaqsp_);
  LOAD_SYMBOL(dlaqsy_);
  LOAD_SYMBOL(dlaqtr_);
  LOAD_SYMBOL(dlar1v_);
  LOAD_SYMBOL(dlar2v_);
  LOAD_SYMBOL(dlarf_);
  LOAD_SYMBOL(dlarfb_);
  LOAD_SYMBOL(dlarfg_);
  LOAD_SYMBOL(dlarft_);
  LOAD_SYMBOL(dlarfx_);
  LOAD_SYMBOL(dlargv_);
  LOAD_SYMBOL(dlarnv_);
  LOAD_SYMBOL(dlarra_);
  LOAD_SYMBOL(dlarrb_);
  LOAD_SYMBOL(dlarrc_);
  LOAD_SYMBOL(dlarrd_);
  LOAD_SYMBOL(dlarre_);
  LOAD_SYMBOL(dlarrf_);
  LOAD_SYMBOL(dlarrj_);
  LOAD_SYMBOL(dlarrk_);
  LOAD_SYMBOL(dlarrr_);
  LOAD_SYMBOL(dlarrv_);
  LOAD_SYMBOL(dlartg_);
  LOAD_SYMBOL(dlartv_);
  LOAD_SYMBOL(dlaruv_);
  LOAD_SYMBOL(dlarz_);
  LOAD_SYMBOL(dlarzb_);
  LOAD_SYMBOL(dlarzt_);
  LOAD_SYMBOL(dlas2_);
  LOAD_SYMBOL(dlascl_);
  LOAD_SYMBOL(dlasd0_);
  LOAD_SYMBOL(dlasd1_);
  LOAD_SYMBOL(dlasd2_);
  LOAD_SYMBOL(dlasd3_);
  LOAD_SYMBOL(dlasd4_);
  LOAD_SYMBOL(dlasd5_);
  LOAD_SYMBOL(dlasd6_);
  LOAD_SYMBOL(dlasd7_);
  LOAD_SYMBOL(dlasd8_);
  LOAD_SYMBOL(dlasda_);
  LOAD_SYMBOL(dlasdq_);
  LOAD_SYMBOL(dlasdt_);
  LOAD_SYMBOL(dlaset_);
  LOAD_SYMBOL(dlasq1_);
  LOAD_SYMBOL(dlasq2_);
  LOAD_SYMBOL(dlasq3_);
  LOAD_SYMBOL(dlasq4_);
  LOAD_SYMBOL(dlasq5_);
  LOAD_SYMBOL(dlasq6_);
  LOAD_SYMBOL(dlasr_);
  LOAD_SYMBOL(dlasrt_);
  LOAD_SYMBOL(dlassq_);
  LOAD_SYMBOL(dlasv2_);
  LOAD_SYMBOL(dlaswp_);
  LOAD_SYMBOL(dlasy2_);
  LOAD_SYMBOL(dlasyf_);
  LOAD_SYMBOL(dlatbs_);
  LOAD_SYMBOL(dlatdf_);
  LOAD_SYMBOL(dlatps_);
  LOAD_SYMBOL(dlatrd_);
  LOAD_SYMBOL(dlatrs_);
  LOAD_SYMBOL(dlatrz_);
  LOAD_SYMBOL(dlatzm_);
  LOAD_SYMBOL(dlauu2_);
  LOAD_SYMBOL(dlauum_);
  // LOAD_SYMBOL(dlazq3_);
  // LOAD_SYMBOL(dlazq4_);
  LOAD_SYMBOL(dopgtr_);
  LOAD_SYMBOL(dopmtr_);
  LOAD_SYMBOL(dorg2l_);
  LOAD_SYMBOL(dorg2r_);
  LOAD_SYMBOL(dorgbr_);
  LOAD_SYMBOL(dorghr_);
  LOAD_SYMBOL(dorgl2_);
  LOAD_SYMBOL(dorglq_);
  LOAD_SYMBOL(dorgql_);
  LOAD_SYMBOL(dorgqr_);
  LOAD_SYMBOL(dorgr2_);
  LOAD_SYMBOL(dorgrq_);
  LOAD_SYMBOL(dorgtr_);
  LOAD_SYMBOL(dorm2l_);
  LOAD_SYMBOL(dorm2r_);
  LOAD_SYMBOL(dormbr_);
  LOAD_SYMBOL(dormhr_);
  LOAD_SYMBOL(dorml2_);
  LOAD_SYMBOL(dormlq_);
  LOAD_SYMBOL(dormql_);
  LOAD_SYMBOL(dormqr_);
  LOAD_SYMBOL(dormr2_);
  LOAD_SYMBOL(dormr3_);
  LOAD_SYMBOL(dormrq_);
  LOAD_SYMBOL(dormrz_);
  LOAD_SYMBOL(dormtr_);
  LOAD_SYMBOL(dpbcon_);
  LOAD_SYMBOL(dpbequ_);
  LOAD_SYMBOL(dpbrfs_);
  LOAD_SYMBOL(dpbstf_);
  LOAD_SYMBOL(dpbsv_);
  LOAD_SYMBOL(dpbsvx_);
  LOAD_SYMBOL(dpbtf2_);
  LOAD_SYMBOL(dpbtrf_);
  LOAD_SYMBOL(dpbtrs_);
  LOAD_SYMBOL(dpocon_);
  LOAD_SYMBOL(dpoequ_);
  LOAD_SYMBOL(dporfs_);
  LOAD_SYMBOL(dposv_);
  LOAD_SYMBOL(dposvx_);
  LOAD_SYMBOL(dpotf2_);
  LOAD_SYMBOL(dpotrf_);
  LOAD_SYMBOL(dpotri_);
  LOAD_SYMBOL(dpotrs_);
  LOAD_SYMBOL(dppcon_);
  LOAD_SYMBOL(dppequ_);
  LOAD_SYMBOL(dpprfs_);
  LOAD_SYMBOL(dppsv_);
  LOAD_SYMBOL(dppsvx_);
  LOAD_SYMBOL(dpptrf_);
  LOAD_SYMBOL(dpptri_);
  LOAD_SYMBOL(dpptrs_);
  LOAD_SYMBOL(dptcon_);
  LOAD_SYMBOL(dpteqr_);
  LOAD_SYMBOL(dptrfs_);
  LOAD_SYMBOL(dptsv_);
  LOAD_SYMBOL(dptsvx_);
  LOAD_SYMBOL(dpttrf_);
  LOAD_SYMBOL(dpttrs_);
  LOAD_SYMBOL(dptts2_);
  LOAD_SYMBOL(drscl_);
  LOAD_SYMBOL(dsbev_);
  LOAD_SYMBOL(dsbevd_);
  LOAD_SYMBOL(dsbevx_);
  LOAD_SYMBOL(dsbgst_);
  LOAD_SYMBOL(dsbgv_);
  LOAD_SYMBOL(dsbgvd_);
  LOAD_SYMBOL(dsbgvx_);
  LOAD_SYMBOL(dsbtrd_);
  LOAD_SYMBOL(dsgesv_);
  LOAD_SYMBOL(dspcon_);
  LOAD_SYMBOL(dspev_);
  LOAD_SYMBOL(dspevd_);
  LOAD_SYMBOL(dspevx_);
  LOAD_SYMBOL(dspgst_);
  LOAD_SYMBOL(dspgv_);
  LOAD_SYMBOL(dspgvd_);
  LOAD_SYMBOL(dspgvx_);
  LOAD_SYMBOL(dsprfs_);
  LOAD_SYMBOL(dspsv_);
  LOAD_SYMBOL(dspsvx_);
  LOAD_SYMBOL(dsptrd_);
  LOAD_SYMBOL(dsptrf_);
  LOAD_SYMBOL(dsptri_);
  LOAD_SYMBOL(dsptrs_);
  LOAD_SYMBOL(dstebz_);
  LOAD_SYMBOL(dstedc_);
  LOAD_SYMBOL(dstegr_);
  LOAD_SYMBOL(dstein_);
  LOAD_SYMBOL(dstemr_);
  LOAD_SYMBOL(dsteqr_);
  LOAD_SYMBOL(dsterf_);
  LOAD_SYMBOL(dstev_);
  LOAD_SYMBOL(dstevd_);
  LOAD_SYMBOL(dstevr_);
  LOAD_SYMBOL(dstevx_);
  LOAD_SYMBOL(dsycon_);
  LOAD_SYMBOL(dsyev_);
  LOAD_SYMBOL(dsyevd_);
  LOAD_SYMBOL(dsyevr_);
  LOAD_SYMBOL(dsyevx_);
  LOAD_SYMBOL(dsygs2_);
  LOAD_SYMBOL(dsygst_);
  LOAD_SYMBOL(dsygv_);
  LOAD_SYMBOL(dsygvd_);
  LOAD_SYMBOL(dsygvx_);
  LOAD_SYMBOL(dsyrfs_);
  LOAD_SYMBOL(dsysv_);
  LOAD_SYMBOL(dsysvx_);
  LOAD_SYMBOL(dsytd2_);
  LOAD_SYMBOL(dsytf2_);
  LOAD_SYMBOL(dsytrd_);
  LOAD_SYMBOL(dsytrf_);
  LOAD_SYMBOL(dsytri_);
  LOAD_SYMBOL(dsytrs_);
  LOAD_SYMBOL(dtbcon_);
  LOAD_SYMBOL(dtbrfs_);
  LOAD_SYMBOL(dtbtrs_);
  LOAD_SYMBOL(dtgevc_);
  LOAD_SYMBOL(dtgex2_);
  LOAD_SYMBOL(dtgexc_);
  LOAD_SYMBOL(dtgsen_);
  LOAD_SYMBOL(dtgsja_);
  LOAD_SYMBOL(dtgsna_);
  LOAD_SYMBOL(dtgsy2_);
  LOAD_SYMBOL(dtgsyl_);
  LOAD_SYMBOL(dtpcon_);
  LOAD_SYMBOL(dtprfs_);
  LOAD_SYMBOL(dtptri_);
  LOAD_SYMBOL(dtptrs_);
  LOAD_SYMBOL(dtrcon_);
  LOAD_SYMBOL(dtrevc_);
  LOAD_SYMBOL(dtrexc_);
  LOAD_SYMBOL(dtrrfs_);
  LOAD_SYMBOL(dtrsen_);
  LOAD_SYMBOL(dtrsna_);
  LOAD_SYMBOL(dtrsyl_);
  LOAD_SYMBOL(dtrti2_);
  LOAD_SYMBOL(dtrtri_);
  LOAD_SYMBOL(dtrtrs_);
  LOAD_SYMBOL(dtzrqf_);
  LOAD_SYMBOL(dtzrzf_);
  LOAD_SYMBOL(ieeeck_);
  LOAD_SYMBOL(ilaenv_);
  LOAD_SYMBOL(ilaver_);
  LOAD_SYMBOL(iparmq_);
  LOAD_SYMBOL(lsamen_);
  LOAD_SYMBOL(sbdsdc_);
  LOAD_SYMBOL(sbdsqr_);
  LOAD_SYMBOL(sdisna_);
  LOAD_SYMBOL(sgbbrd_);
  LOAD_SYMBOL(sgbcon_);
  LOAD_SYMBOL(sgbequ_);
  LOAD_SYMBOL(sgbrfs_);
  LOAD_SYMBOL(sgbsv_);
  LOAD_SYMBOL(sgbsvx_);
  LOAD_SYMBOL(sgbtf2_);
  LOAD_SYMBOL(sgbtrf_);
  LOAD_SYMBOL(sgbtrs_);
  LOAD_SYMBOL(sgebak_);
  LOAD_SYMBOL(sgebal_);
  LOAD_SYMBOL(sgebd2_);
  LOAD_SYMBOL(sgebrd_);
  LOAD_SYMBOL(sgecon_);
  LOAD_SYMBOL(sgeequ_);
  // LOAD_SYMBOL(sgees_);
  // LOAD_SYMBOL(sgeesx_);
  LOAD_SYMBOL(sgeev_);
  LOAD_SYMBOL(sgeevx_);
  LOAD_SYMBOL(sgegs_);
  LOAD_SYMBOL(sgegv_);
  LOAD_SYMBOL(sgehd2_);
  LOAD_SYMBOL(sgehrd_);
  LOAD_SYMBOL(sgelq2_);
  LOAD_SYMBOL(sgelqf_);
  LOAD_SYMBOL(sgels_);
  LOAD_SYMBOL(sgelsd_);
  LOAD_SYMBOL(sgelss_);
  LOAD_SYMBOL(sgelsx_);
  LOAD_SYMBOL(sgelsy_);
  LOAD_SYMBOL(sgeql2_);
  LOAD_SYMBOL(sgeqlf_);
  LOAD_SYMBOL(sgeqp3_);
  LOAD_SYMBOL(sgeqpf_);
  LOAD_SYMBOL(sgeqr2_);
  LOAD_SYMBOL(sgeqrf_);
  LOAD_SYMBOL(sgerfs_);
  LOAD_SYMBOL(sgerq2_);
  LOAD_SYMBOL(sgerqf_);
  LOAD_SYMBOL(sgesc2_);
  LOAD_SYMBOL(sgesdd_);
  LOAD_SYMBOL(sgesv_);
  LOAD_SYMBOL(sgesvd_);
  LOAD_SYMBOL(sgesvx_);
  LOAD_SYMBOL(sgetc2_);
  LOAD_SYMBOL(sgetf2_);
  LOAD_SYMBOL(sgetrf_);
  LOAD_SYMBOL(sgetri_);
  LOAD_SYMBOL(sgetrs_);
  LOAD_SYMBOL(sggbak_);
  LOAD_SYMBOL(sggbal_);
  // LOAD_SYMBOL(sgges_);
  // LOAD_SYMBOL(sggesx_);
  LOAD_SYMBOL(sggev_);
  LOAD_SYMBOL(sggevx_);
  LOAD_SYMBOL(sggglm_);
  LOAD_SYMBOL(sgghrd_);
  LOAD_SYMBOL(sgglse_);
  LOAD_SYMBOL(sggqrf_);
  LOAD_SYMBOL(sggrqf_);
  LOAD_SYMBOL(sggsvd_);
  LOAD_SYMBOL(sggsvp_);
  LOAD_SYMBOL(sgtcon_);
  LOAD_SYMBOL(sgtrfs_);
  LOAD_SYMBOL(sgtsv_);
  LOAD_SYMBOL(sgtsvx_);
  LOAD_SYMBOL(sgttrf_);
  LOAD_SYMBOL(sgttrs_);
  LOAD_SYMBOL(sgtts2_);
  LOAD_SYMBOL(shgeqz_);
  LOAD_SYMBOL(shsein_);
  LOAD_SYMBOL(shseqr_);
  LOAD_SYMBOL(sisnan_);
  LOAD_SYMBOL(slabad_);
  LOAD_SYMBOL(slabrd_);
  LOAD_SYMBOL(slacn2_);
  LOAD_SYMBOL(slacon_);
  LOAD_SYMBOL(slacpy_);
  LOAD_SYMBOL(sladiv_);
  LOAD_SYMBOL(slae2_);
  LOAD_SYMBOL(slaebz_);
  LOAD_SYMBOL(slaed0_);
  LOAD_SYMBOL(slaed1_);
  LOAD_SYMBOL(slaed2_);
  LOAD_SYMBOL(slaed3_);
  LOAD_SYMBOL(slaed4_);
  LOAD_SYMBOL(slaed5_);
  LOAD_SYMBOL(slaed6_);
  LOAD_SYMBOL(slaed7_);
  LOAD_SYMBOL(slaed8_);
  LOAD_SYMBOL(slaed9_);
  LOAD_SYMBOL(slaeda_);
  LOAD_SYMBOL(slaein_);
  LOAD_SYMBOL(slaev2_);
  LOAD_SYMBOL(slaexc_);
  LOAD_SYMBOL(slag2_);
  LOAD_SYMBOL(slag2d_);
  LOAD_SYMBOL(slags2_);
  LOAD_SYMBOL(slagtf_);
  LOAD_SYMBOL(slagtm_);
  LOAD_SYMBOL(slagts_);
  LOAD_SYMBOL(slagv2_);
  LOAD_SYMBOL(slahqr_);
  LOAD_SYMBOL(slahr2_);
  LOAD_SYMBOL(slahrd_);
  LOAD_SYMBOL(slaic1_);
  LOAD_SYMBOL(slaisnan_);
  LOAD_SYMBOL(slaln2_);
  LOAD_SYMBOL(slals0_);
  LOAD_SYMBOL(slalsa_);
  LOAD_SYMBOL(slalsd_);
  LOAD_SYMBOL(slamrg_);
  LOAD_SYMBOL(slaneg_);
  LOAD_SYMBOL(slangb_);
  LOAD_SYMBOL(slange_);
  LOAD_SYMBOL(slangt_);
  LOAD_SYMBOL(slanhs_);
  LOAD_SYMBOL(slansb_);
  LOAD_SYMBOL(slansp_);
  LOAD_SYMBOL(slanst_);
  LOAD_SYMBOL(slansy_);
  LOAD_SYMBOL(slantb_);
  LOAD_SYMBOL(slantp_);
  LOAD_SYMBOL(slantr_);
  LOAD_SYMBOL(slanv2_);
  LOAD_SYMBOL(slapll_);
  LOAD_SYMBOL(slapmt_);
  LOAD_SYMBOL(slapy2_);
  LOAD_SYMBOL(slapy3_);
  LOAD_SYMBOL(slaqgb_);
  LOAD_SYMBOL(slaqge_);
  LOAD_SYMBOL(slaqp2_);
  LOAD_SYMBOL(slaqps_);
  LOAD_SYMBOL(slaqr0_);
  LOAD_SYMBOL(slaqr1_);
  LOAD_SYMBOL(slaqr2_);
  LOAD_SYMBOL(slaqr3_);
  LOAD_SYMBOL(slaqr4_);
  LOAD_SYMBOL(slaqr5_);
  LOAD_SYMBOL(slaqsb_);
  LOAD_SYMBOL(slaqsp_);
  LOAD_SYMBOL(slaqsy_);
  LOAD_SYMBOL(slaqtr_);
  LOAD_SYMBOL(slar1v_);
  LOAD_SYMBOL(slar2v_);
  LOAD_SYMBOL(slarf_);
  LOAD_SYMBOL(slarfb_);
  LOAD_SYMBOL(slarfg_);
  LOAD_SYMBOL(slarft_);
  LOAD_SYMBOL(slarfx_);
  LOAD_SYMBOL(slargv_);
  LOAD_SYMBOL(slarnv_);
  LOAD_SYMBOL(slarra_);
  LOAD_SYMBOL(slarrb_);
  LOAD_SYMBOL(slarrc_);
  LOAD_SYMBOL(slarrd_);
  LOAD_SYMBOL(slarre_);
  LOAD_SYMBOL(slarrf_);
  LOAD_SYMBOL(slarrj_);
  LOAD_SYMBOL(slarrk_);
  LOAD_SYMBOL(slarrr_);
  LOAD_SYMBOL(slarrv_);
  LOAD_SYMBOL(slartg_);
  LOAD_SYMBOL(slartv_);
  LOAD_SYMBOL(slaruv_);
  LOAD_SYMBOL(slarz_);
  LOAD_SYMBOL(slarzb_);
  LOAD_SYMBOL(slarzt_);
  LOAD_SYMBOL(slas2_);
  LOAD_SYMBOL(slascl_);
  LOAD_SYMBOL(slasd0_);
  LOAD_SYMBOL(slasd1_);
  LOAD_SYMBOL(slasd2_);
  LOAD_SYMBOL(slasd3_);
  LOAD_SYMBOL(slasd4_);
  LOAD_SYMBOL(slasd5_);
  LOAD_SYMBOL(slasd6_);
  LOAD_SYMBOL(slasd7_);
  LOAD_SYMBOL(slasd8_);
  LOAD_SYMBOL(slasda_);
  LOAD_SYMBOL(slasdq_);
  LOAD_SYMBOL(slasdt_);
  LOAD_SYMBOL(slaset_);
  LOAD_SYMBOL(slasq1_);
  LOAD_SYMBOL(slasq2_);
  LOAD_SYMBOL(slasq3_);
  LOAD_SYMBOL(slasq4_);
  LOAD_SYMBOL(slasq5_);
  LOAD_SYMBOL(slasq6_);
  LOAD_SYMBOL(slasr_);
  LOAD_SYMBOL(slasrt_);
  LOAD_SYMBOL(slassq_);
  LOAD_SYMBOL(slasv2_);
  LOAD_SYMBOL(slaswp_);
  LOAD_SYMBOL(slasy2_);
  LOAD_SYMBOL(slasyf_);
  LOAD_SYMBOL(slatbs_);
  LOAD_SYMBOL(slatdf_);
  LOAD_SYMBOL(slatps_);
  LOAD_SYMBOL(slatrd_);
  LOAD_SYMBOL(slatrs_);
  LOAD_SYMBOL(slatrz_);
  LOAD_SYMBOL(slatzm_);
  LOAD_SYMBOL(slauu2_);
  LOAD_SYMBOL(slauum_);
  // LOAD_SYMBOL(slazq3_);
  // LOAD_SYMBOL(slazq4_);
  LOAD_SYMBOL(sopgtr_);
  LOAD_SYMBOL(sopmtr_);
  LOAD_SYMBOL(sorg2l_);
  LOAD_SYMBOL(sorg2r_);
  LOAD_SYMBOL(sorgbr_);
  LOAD_SYMBOL(sorghr_);
  LOAD_SYMBOL(sorgl2_);
  LOAD_SYMBOL(sorglq_);
  LOAD_SYMBOL(sorgql_);
  LOAD_SYMBOL(sorgqr_);
  LOAD_SYMBOL(sorgr2_);
  LOAD_SYMBOL(sorgrq_);
  LOAD_SYMBOL(sorgtr_);
  LOAD_SYMBOL(sorm2l_);
  LOAD_SYMBOL(sorm2r_);
  LOAD_SYMBOL(sormbr_);
  LOAD_SYMBOL(sormhr_);
  LOAD_SYMBOL(sorml2_);
  LOAD_SYMBOL(sormlq_);
  LOAD_SYMBOL(sormql_);
  LOAD_SYMBOL(sormqr_);
  LOAD_SYMBOL(sormr2_);
  LOAD_SYMBOL(sormr3_);
  LOAD_SYMBOL(sormrq_);
  LOAD_SYMBOL(sormrz_);
  LOAD_SYMBOL(sormtr_);
  LOAD_SYMBOL(spbcon_);
  LOAD_SYMBOL(spbequ_);
  LOAD_SYMBOL(spbrfs_);
  LOAD_SYMBOL(spbstf_);
  LOAD_SYMBOL(spbsv_);
  LOAD_SYMBOL(spbsvx_);
  LOAD_SYMBOL(spbtf2_);
  LOAD_SYMBOL(spbtrf_);
  LOAD_SYMBOL(spbtrs_);
  LOAD_SYMBOL(spocon_);
  LOAD_SYMBOL(spoequ_);
  LOAD_SYMBOL(sporfs_);
  LOAD_SYMBOL(sposv_);
  LOAD_SYMBOL(sposvx_);
  LOAD_SYMBOL(spotf2_);
  LOAD_SYMBOL(spotrf_);
  LOAD_SYMBOL(spotri_);
  LOAD_SYMBOL(spotrs_);
  LOAD_SYMBOL(sppcon_);
  LOAD_SYMBOL(sppequ_);
  LOAD_SYMBOL(spprfs_);
  LOAD_SYMBOL(sppsv_);
  LOAD_SYMBOL(sppsvx_);
  LOAD_SYMBOL(spptrf_);
  LOAD_SYMBOL(spptri_);
  LOAD_SYMBOL(spptrs_);
  LOAD_SYMBOL(sptcon_);
  LOAD_SYMBOL(spteqr_);
  LOAD_SYMBOL(sptrfs_);
  LOAD_SYMBOL(sptsv_);
  LOAD_SYMBOL(sptsvx_);
  LOAD_SYMBOL(spttrf_);
  LOAD_SYMBOL(spttrs_);
  LOAD_SYMBOL(sptts2_);
  LOAD_SYMBOL(srscl_);
  LOAD_SYMBOL(ssbev_);
  LOAD_SYMBOL(ssbevd_);
  LOAD_SYMBOL(ssbevx_);
  LOAD_SYMBOL(ssbgst_);
  LOAD_SYMBOL(ssbgv_);
  LOAD_SYMBOL(ssbgvd_);
  LOAD_SYMBOL(ssbgvx_);
  LOAD_SYMBOL(ssbtrd_);
  LOAD_SYMBOL(sspcon_);
  LOAD_SYMBOL(sspev_);
  LOAD_SYMBOL(sspevd_);
  LOAD_SYMBOL(sspevx_);
  LOAD_SYMBOL(sspgst_);
  LOAD_SYMBOL(sspgv_);
  LOAD_SYMBOL(sspgvd_);
  LOAD_SYMBOL(sspgvx_);
  LOAD_SYMBOL(ssprfs_);
  LOAD_SYMBOL(sspsv_);
  LOAD_SYMBOL(sspsvx_);
  LOAD_SYMBOL(ssptrd_);
  LOAD_SYMBOL(ssptrf_);
  LOAD_SYMBOL(ssptri_);
  LOAD_SYMBOL(ssptrs_);
  LOAD_SYMBOL(sstebz_);
  LOAD_SYMBOL(sstedc_);
  LOAD_SYMBOL(sstegr_);
  LOAD_SYMBOL(sstein_);
  LOAD_SYMBOL(sstemr_);
  LOAD_SYMBOL(ssteqr_);
  LOAD_SYMBOL(ssterf_);
  LOAD_SYMBOL(sstev_);
  LOAD_SYMBOL(sstevd_);
  LOAD_SYMBOL(sstevr_);
  LOAD_SYMBOL(sstevx_);
  LOAD_SYMBOL(ssycon_);
  LOAD_SYMBOL(ssyev_);
  LOAD_SYMBOL(ssyevd_);
  LOAD_SYMBOL(ssyevr_);
  LOAD_SYMBOL(ssyevx_);
  LOAD_SYMBOL(ssygs2_);
  LOAD_SYMBOL(ssygst_);
  LOAD_SYMBOL(ssygv_);
  LOAD_SYMBOL(ssygvd_);
  LOAD_SYMBOL(ssygvx_);
  LOAD_SYMBOL(ssyrfs_);
  LOAD_SYMBOL(ssysv_);
  LOAD_SYMBOL(ssysvx_);
  LOAD_SYMBOL(ssytd2_);
  LOAD_SYMBOL(ssytf2_);
  LOAD_SYMBOL(ssytrd_);
  LOAD_SYMBOL(ssytrf_);
  LOAD_SYMBOL(ssytri_);
  LOAD_SYMBOL(ssytrs_);
  LOAD_SYMBOL(stbcon_);
  LOAD_SYMBOL(stbrfs_);
  LOAD_SYMBOL(stbtrs_);
  LOAD_SYMBOL(stgevc_);
  LOAD_SYMBOL(stgex2_);
  LOAD_SYMBOL(stgexc_);
  LOAD_SYMBOL(stgsen_);
  LOAD_SYMBOL(stgsja_);
  LOAD_SYMBOL(stgsna_);
  LOAD_SYMBOL(stgsy2_);
  LOAD_SYMBOL(stgsyl_);
  LOAD_SYMBOL(stpcon_);
  LOAD_SYMBOL(stprfs_);
  LOAD_SYMBOL(stptri_);
  LOAD_SYMBOL(stptrs_);
  LOAD_SYMBOL(strcon_);
  LOAD_SYMBOL(strevc_);
  LOAD_SYMBOL(strexc_);
  LOAD_SYMBOL(strrfs_);
  LOAD_SYMBOL(strsen_);
  LOAD_SYMBOL(strsna_);
  LOAD_SYMBOL(strsyl_);
  LOAD_SYMBOL(strti2_);
  LOAD_SYMBOL(strtri_);
  LOAD_SYMBOL(strtrs_);
  LOAD_SYMBOL(stzrqf_);
  LOAD_SYMBOL(stzrzf_);
  LOAD_SYMBOL(dlamch_);
  // LOAD_SYMBOL(dlamc1_);
  // LOAD_SYMBOL(dlamc2_);
  LOAD_SYMBOL(dlamc3_);
  // LOAD_SYMBOL(dlamc4_);
  // LOAD_SYMBOL(dlamc5_);
  LOAD_SYMBOL(dsecnd_);
  LOAD_SYMBOL(lsame_);
  LOAD_SYMBOL(second_);
  LOAD_SYMBOL(slamch_);
  // LOAD_SYMBOL(slamc1_);
  // LOAD_SYMBOL(slamc2_);
  LOAD_SYMBOL(slamc3_);
  // LOAD_SYMBOL(slamc4_);
  // LOAD_SYMBOL(slamc5_);

#undef LOAD_SYMBOL
 return TRUE;
}

static void *libhandle;

jint JNI_OnLoad(JavaVM *vm, UNUSED void *reserved) {
  JNIEnv *env;
  if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {
    return -1;
  }

  jclass booleanW_class = (*env)->FindClass(env, "org/netlib/util/booleanW");
  if (!booleanW_class) {
    return -1;
  }
  booleanW_val_fieldID = (*env)->GetFieldID(env, booleanW_class, "val", "Z");
  if (!booleanW_val_fieldID) {
    return -1;
  }

  jclass intW_class = (*env)->FindClass(env, "org/netlib/util/intW");
  if (!intW_class) {
    return -1;
  }
  intW_val_fieldID = (*env)->GetFieldID(env, intW_class, "val", "I");
  if (!intW_val_fieldID) {
    return -1;
  }

  jclass floatW_class = (*env)->FindClass(env, "org/netlib/util/floatW");
  if (!floatW_class) {
    return -1;
  }
  floatW_val_fieldID = (*env)->GetFieldID(env, floatW_class, "val", "F");
  if (!floatW_val_fieldID) {
    return -1;
  }

  jclass doubleW_class = (*env)->FindClass(env, "org/netlib/util/doubleW");
  if (!doubleW_class) {
    return -1;
  }
  doubleW_val_fieldID = (*env)->GetFieldID(env, doubleW_class, "val", "D");
  if (!doubleW_val_fieldID) {
    return -1;
  }

  jclass StringW_class = (*env)->FindClass(env, "org/netlib/util/StringW");
  if (!StringW_class) {
    return -1;
  }
  StringW_val_fieldID = (*env)->GetFieldID(env, StringW_class, "val", "Ljava/lang/String;");
  if (!StringW_val_fieldID) {
    return -1;
  }

  jstring property_nativeLibPath;
  if (!get_system_property(env, (*env)->NewStringUTF(env, "dev.ludovic.netlib.lapack.nativeLibPath"), NULL, &property_nativeLibPath)) {
    return -1;
  }
  jstring property_nativeLib;
  if (!get_system_property(env, (*env)->NewStringUTF(env, "dev.ludovic.netlib.lapack.nativeLib"), (*env)->NewStringUTF(env, "liblapack.so.3"), &property_nativeLib)) {
    return -1;
  }

  char name[1024];
  if (property_nativeLibPath) {
    const char *utf = (*env)->GetStringUTFChars(env, property_nativeLibPath, NULL);
    snprintf(name, sizeof(name), "%s", utf);
    (*env)->ReleaseStringUTFChars(env, property_nativeLibPath, utf);
  } else if (property_nativeLib) {
    const char *utf = (*env)->GetStringUTFChars(env, property_nativeLib, NULL);
    snprintf(name, sizeof(name), "%s", utf);
    (*env)->ReleaseStringUTFChars(env, property_nativeLib, utf);
  } else {
    /* either property_nativeLibPath or property_nativeLib should always be non-NULL */
    return -1;
  }

  libhandle = dlopen(name, RTLD_LAZY | RTLD_GLOBAL);
  if (!libhandle) {
    return -1;
  }

  if (!load_symbols()) {
    return -1;
  }

  return JNI_VERSION_1_6;
}

void JNI_OnUnload(UNUSED JavaVM *vm, UNUSED void *reserved) {
  dlclose(libhandle);
}
